<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>VDO.Ninja P2P File Share (ArrayBuffer)</title>
  <style>
    body { font-family: sans-serif; background: #111; color: #eee; }
    #fileList .folder { border: 1px solid #333; margin: 0.5em 0; padding: 0.5em; border-radius: 6px; }
    button { margin-left: 0.5em; }
    .file-item { display: flex; justify-content: space-between; margin: 0.25em 0; }
    .folder-header { display: flex; justify-content: space-between; align-items: center; background: #222; padding: 0.25em; border-radius: 4px; }
  </style>
</head>
<body>
  <h3>VDO.Ninja File Share (ArrayBuffer)</h3>
  <input type="file" id="fileInput" webkitdirectory multiple />
  <div id="fileList"></div>
  <iframe id="ninjaFrame" width="0" height="0" src="https://vdo.ninja/?director&room=testroom&password=1234"></iframe>
  <pre id="log"></pre>

<script>
const APP_NS = "p2pFileShare";
const CHUNK_SIZE = 32 * 1024; // 32KB chunks
const iframe = document.getElementById("ninjaFrame");
const files = {};
const incomingTransfers = {};
const incomingGroups = {};

function log(...a) {
  const pre = document.getElementById("log");
  pre.textContent += a.join(" ") + "\n";
  pre.scrollTop = pre.scrollHeight;
}

function generateId() { return Math.random().toString(36).slice(2,10); }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }
function formatBytes(a){ if(a===0) return '0 B'; const units=['B','KB','MB','GB','TB']; const e=Math.floor(Math.log(a)/Math.log(1024)); return (a/Math.pow(1024,e)).toFixed(2)+' '+units[e]; }
function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[c]); }
function readAsArrayBuffer(blob){ return new Promise((res,rej)=>{ const r=new FileReader(); r.onload=()=>res(r.result); r.onerror=rej; r.readAsArrayBuffer(blob); }); }

function postToIframe(msg) {
  iframe.contentWindow.postMessage(msg, "*");
}

// -------------------------------
// File adding and announcing
// -------------------------------
document.getElementById('fileInput').addEventListener('change', e => {
  const list = e.target.files;
  for (const f of list) addFile(f);
});

function addFile(file) {
  const id = generateId();
  const groupId = file.webkitRelativePath ? file.webkitRelativePath.split('/')[0] : id;
  files[id] = { id, file, name: file.webkitRelativePath || file.name, size: file.size, groupId };
  renderFileItem(files[id]);
  log(`Added: ${files[id].name} (${formatBytes(files[id].size)})`);
  sendFileMeta(id);
}

function sendFileMeta(id) {
  const meta = files[id];
  const fileMeta = {
    id, name: meta.name, size: meta.size, groupId: meta.groupId, type: "file-meta"
  };
  postToIframe({ sendData: { [APP_NS]: { type: "announce", payload: fileMeta } }, type: "pcs" });
  log(`Announced file ${meta.name}`);
}

// -------------------------------
// Handle messages from iframe
// -------------------------------
window.addEventListener("message", (event) => {
  const data = event.data;
  if (!data || !data.data) return;
  const msg = data.data;
  if (!msg[APP_NS]) return;
  const payload = msg[APP_NS];
  const senderUUID = data.UUID || "unknown";
  handleDataReceived(payload, senderUUID);
});

function handleDataReceived(payload, senderUUID) {
  switch (payload.type) {
    case "announce": {
      const meta = payload.payload;
      if (!incomingGroups[meta.groupId]) {
        incomingGroups[meta.groupId] = { senderUUID, files: {} };
        renderFolder(meta.groupId);
      }
      incomingGroups[meta.groupId].files[meta.id] = meta;
      renderFileInFolder(meta.groupId, meta);
      break;
    }

    case "request-file": {
      const req = payload.payload;
      const meta = files[req.id];
      if (meta && meta.file) sendFileChunks(senderUUID, req.id);
      break;
    }

    case "request-folder": {
      const groupId = payload.payload.groupId;
      const groupFiles = Object.values(files).filter(f => f.groupId === groupId);
      log(`Peer requested folder ${groupId} (${groupFiles.length} files)`);
      (async () => {
        for (const f of groupFiles) await sendFileChunks(senderUUID, f.id);
      })();
      break;
    }

    case "chunk": handleIncomingChunk(payload.payload); break;
    case "complete": finalizeReceivedFile(payload.payload.id); break;
  }
}

// -------------------------------
// Sending file chunks (ArrayBuffer)
// -------------------------------
async function sendFileChunks(targetUUID, id) {
  const meta = files[id];
  const f = meta.file;
  const totalChunks = Math.ceil(f.size / CHUNK_SIZE);
  let offset = 0, index = 0;

  log(`Uploading ${meta.name} (${formatBytes(meta.size)}) to ${targetUUID}`);
  while (offset < f.size) {
    const slice = f.slice(offset, offset + CHUNK_SIZE);
    const buffer = await readAsArrayBuffer(slice);
    const msg = { type: "chunk", payload: { id, index, total: totalChunks, buffer } };
    iframe.contentWindow.postMessage({ sendData: { [APP_NS]: msg }, type: "pcs", UUID: targetUUID }, "*", [buffer]);
    offset += CHUNK_SIZE;
    index++;
    await sleep(10);
  }

  const complete = { type: "complete", payload: { id } };
  postToIframe({ sendData: { [APP_NS]: complete }, type: "pcs", UUID: targetUUID });
  log(`Finished sending ${meta.name}`);
}

// -------------------------------
// Receiving file chunks (ArrayBuffer)
// -------------------------------
function handleIncomingChunk(chunk) {
  if (!incomingTransfers[chunk.id]) {
    incomingTransfers[chunk.id] = { buffers: [], total: chunk.total };
  }
  incomingTransfers[chunk.id].buffers[chunk.index] = chunk.buffer;
  if (incomingTransfers[chunk.id].buffers.filter(Boolean).length === chunk.total) {
    finalizeReceivedFile(chunk.id);
  }
}

function finalizeReceivedFile(id) {
  const transfer = incomingTransfers[id];
  if (!transfer) return;
  const blob = new Blob(transfer.buffers);
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = incomingGroups[Object.keys(incomingGroups).find(g => incomingGroups[g].files[id])]?.files[id]?.name || `file-${id}`;
  a.textContent = `Download ${a.download}`;
  a.style.display = "block";
  document.getElementById("fileList").appendChild(a);
  log(`File ${a.download} ready to download`);
  delete incomingTransfers[id];
}

// -------------------------------
// UI rendering
// -------------------------------
function renderFolder(groupId) {
  const container = document.getElementById("fileList");
  const folderDiv = document.createElement("div");
  folderDiv.id = `folder-${groupId}`;
  folderDiv.className = "folder";
  folderDiv.innerHTML = `
    <div class="folder-header">
      <strong>üìÅ ${groupId}</strong>
      <button id="dl-folder-${groupId}">Download All</button>
    </div>
    <div class="folder-files" id="folder-files-${groupId}" style="margin-left:1em;"></div>
  `;
  container.appendChild(folderDiv);

  document.getElementById(`dl-folder-${groupId}`).addEventListener('click', () => {
    const senderUUID = incomingGroups[groupId].senderUUID;
    postToIframe({ sendData: { [APP_NS]: { type: "request-folder", payload: { groupId } } }, type: "pcs", UUID: senderUUID });
    log(`Requested all files from folder ${groupId}`);
  });
}

function renderFileInFolder(groupId, meta) {
  const folderFiles = document.getElementById(`folder-files-${groupId}`);
  const div = document.createElement("div");
  div.className = "file-item";
  div.innerHTML = `<span>${escapeHtml(meta.name)}</span><button id="req-${meta.id}">Download</button>`;
  folderFiles.appendChild(div);
  document.getElementById(`req-${meta.id}`).addEventListener("click", () => {
    const senderUUID = incomingGroups[groupId].senderUUID;
    postToIframe({ sendData: { [APP_NS]: { type: "request-file", payload: { id: meta.id, name: meta.name } } }, type: "pcs", UUID: senderUUID });
    log(`Requested file ${meta.name} from ${senderUUID}`);
  });
}
</script>
</body>
</html>
