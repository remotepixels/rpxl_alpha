<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>VDO.Ninja File Share ‚Äî Groups & On-Demand Transfer</title>
<style>
  body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; margin: 18px; background:#f7f8fb; color:#111; }
  h1 { margin:0 0 10px; font-size:20px; }
  .row { display:flex; gap:8px; align-items:center; margin-bottom:10px; }
  input[type=text] { padding:8px; font:inherit; }
  button { padding:8px 10px; font:inherit; cursor:pointer; border-radius:6px; border:0; background:#2563eb; color:white; }
  button.ghost { background:#6b7280; }
  #container { margin-top:8px; }
  #dropZone { border:2px dashed #cbd5e1; padding:18px; border-radius:8px; background:white; text-align:center; color:#374151; }
  #offers { margin-top:12px; }
  .group { border:1px solid #e6e9ef; background:#fff; padding:8px; border-radius:8px; margin-bottom:8px; }
  .group-header { display:flex; justify-content:space-between; align-items:center; gap:12px; }
  .group-files { margin-top:8px; padding-left:8px; }
  .file-row { display:flex; justify-content:space-between; gap:8px; padding:6px 0; border-bottom:1px dashed #f1f5f9; }
  .file-row:last-child { border-bottom: none; }
  .small { font-size:12px; color:#6b7280; }
  #peers { background:#fff; padding:8px; border-radius:8px; border:1px solid #e6e9ef; margin-top:8px; }
  #log { margin-top:12px; height:140px; overflow:auto; background:#0f172a; color:#c7d2fe; padding:8px; border-radius:6px; font-family:monospace; font-size:12px; }
  a.download-link { display:inline-block; margin-top:6px; color:#064e3b; text-decoration:none; }
</style>
</head>
<body>
  <h1>VDO.Ninja File Share ‚Äî Groups & On-Demand</h1>

  <div class="row">
    <label>Room:</label>
    <input id="roomInput" type="text" value="myFileRoom" />
    <button id="joinBtn">Join Room</button>
    <button id="leaveBtn" class="ghost">Leave</button>
  </div>

  <div id="container"></div>

  <div class="row">
    <div style="flex:1">
      <div id="dropZone">Drag & drop files or folders here (or click to pick)</div>
      <div id="offers"></div>
    </div>

    <div style="width:320px">
      <h4 style="margin:0 0 6px">Connected Peers</h4>
      <div id="peers">(none)</div>

      <h4 style="margin-top:12px;margin-bottom:6px">Activity Log</h4>
      <pre id="log"></pre>
    </div>
  </div>

<script>
/* ================== CONFIG ================== */
const APP_NS = 'vdoFileGroups';
const CHUNK_SIZE = 256 * 1024; // 256KB per chunk
/* ============================================ */

let directorFrame = null;
let dataIframe = null;
let roomName = '';
let connectedPeers = {}; // streamID -> label
const files = {};        // id -> {id, file, name, size, mime, relativePath, groupId}
const groups = {};       // groupId -> {files: [fileId], name, senderUUID}
const incoming = {};     // incoming file assembly: id -> {meta, chunks: {}, total}

/* ----------------- UI refs ----------------- */
const roomInput = document.getElementById('roomInput');
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const container = document.getElementById('container');
const dropZone = document.getElementById('dropZone');
const offersDiv = document.getElementById('offers');
const peersDiv = document.getElementById('peers');
const logEl = document.getElementById('log');

/* ----------------- Helpers ----------------- */
function log(...args){ console.log(...args); logEl.textContent += args.join(' ') + '\n'; logEl.scrollTop = logEl.scrollHeight; }
function generateId(){ return Math.random().toString(36).slice(2,10); }
function formatBytes(n){ if(n===0) return '0 B'; const units=['B','KB','MB','GB']; const e=Math.floor(Math.log(n)/Math.log(1024)); return (n/Math.pow(1024,e)).toFixed(2)+' '+units[e]; }
function escapeHtml(s){ return String(s).replace(/[&<>\"']/g, c=>({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[c]); }

/* ----- base64 utils ----- */
function arrayBufferToBase64(buffer){
  let binary = '';
  const bytes = new Uint8Array(buffer);
  const len = bytes.byteLength;
  for (let i=0;i<len;i++) binary += String.fromCharCode(bytes[i]);
  return btoa(binary);
}
function base64ToArrayBuffer(base64){
  const binary = atob(base64);
  const len = binary.length;
  const bytes = new Uint8Array(len);
  for (let i=0;i<len;i++) bytes[i] = binary.charCodeAt(i);
  return bytes.buffer;
}

/* ------------- Post wrapper -------------- */
function postToIframe(obj){
  if (!dataIframe || !dataIframe.contentWindow) return log('No data iframe to post to');
  dataIframe.contentWindow.postMessage(obj, '*');
}

/* ---------------- Join / Leave ---------------- */
joinBtn.onclick = () => {
  const r = (roomInput.value || '').trim();
  if (!r) return alert('Enter a room name');
  joinRoom(r);
};
leaveBtn.onclick = () => {
  if (directorFrame) { directorFrame.remove(); directorFrame = null; }
  if (dataIframe) { dataIframe.remove(); dataIframe = null; }
  connectedPeers = {}; groups = {}; for (const k in files) delete files[k];
  offersDiv.innerHTML = ''; peersDiv.innerHTML = '(none)'; log('Left room');
};

function joinRoom(r){
  roomName = r;
  // hidden director (bridge)
  if (!directorFrame){
    directorFrame = document.createElement('iframe');
    directorFrame.style.display = 'none';
    directorFrame.src = `https://vdo.ninja/?director&room=${encodeURIComponent(r)}&hidden&cleanish`;
    document.body.appendChild(directorFrame);
  }
  // visible data iframe
  if (dataIframe) dataIframe.remove();
  dataIframe = document.createElement('iframe');
  dataIframe.src = `https://vdo.ninja/?room=${encodeURIComponent(r)}&dataonly&cleanish`;
  dataIframe.style.width = '100%';
  dataIframe.style.height = '140px';
  dataIframe.style.marginTop = '8px';
  dataIframe.allow = 'camera;microphone;autoplay;fullscreen;';
  container.innerHTML = '';
  container.appendChild(dataIframe);
  log('Joined room:', r);
}

/* --------------- iframe messaging ---------------- */
window.addEventListener('message', e => {
  const d = e.data;
  if (!d) return;
  // data messages (sendData from other peer)
  if (d.dataReceived && d.dataReceived[APP_NS]) {
    const payload = d.dataReceived[APP_NS];
    const senderUUID = d.UUID || d.from || d.sender || null; // vdo uses UUID in some events; fallback
    handleIncomingData(payload, senderUUID);
  }
  // peer events
  if (d.action) handleAction(d);
  if (d.streamIDs) {
    // streamIDs is an object mapping id -> label
    connectedPeers = d.streamIDs || {};
    updatePeersUI();
  }
});

function handleAction(d){
  // guest-connected, view-connection, push-connection
  if (d.action === 'guest-connected' && d.streamID) {
    connectedPeers[d.streamID] = d.value?.label || 'Guest';
    updatePeersUI();
    log('Guest connected', d.streamID, connectedPeers[d.streamID]);
  } else if (d.action === 'push-connection' && d.value === false && d.streamID){
    delete connectedPeers[d.streamID];
    updatePeersUI();
    log('Peer disconnected', d.streamID);
  } else if (d.action === 'view-connection'){
    if (d.value) connectedPeers[d.streamID] = 'Viewer'; else delete connectedPeers[d.streamID];
    updatePeersUI();
  }
}

function updatePeersUI(){
  const keys = Object.keys(connectedPeers);
  if (!keys.length) peersDiv.textContent = '(none)';
  else peersDiv.innerHTML = keys.map(k => `<div><strong>${escapeHtml(connectedPeers[k])}</strong><div class="small">${k}</div></div>`).join('');
}

/* ------------- Incoming data handler -------------- */
function handleIncomingData(payload, senderUUID){
  if (!payload || !payload.type) return;
  switch (payload.type) {
    case 'announce':
      handleAnnounce(payload.payload, senderUUID);
      break;
    case 'request-file':
      handleRequestFile(payload.payload, senderUUID);
      break;
    case 'request-folder':
      handleRequestFolder(payload.payload, senderUUID);
      break;
    case 'chunk':
      handleChunk(payload.payload, senderUUID);
      break;
    case 'complete':
      handleComplete(payload.payload, senderUUID);
      break;
    default:
      log('Unknown payload type', payload.type);
  }
}

/* --------------- Announce (receiver) --------------- */
function handleAnnounce(meta, senderUUID){
  // meta: { id, name, size, mime, groupId, relativePath, timestamp }
  if (!meta || !meta.id) return;
  // store group mapping on receiver for UI (not storing the file itself)
  if (!groups[meta.groupId]) groups[meta.groupId] = { files: {}, name: meta.groupName || meta.groupId, senderUUID };
  groups[meta.groupId].files[meta.id] = meta;
  groups[meta.groupId].senderUUID = senderUUID || groups[meta.groupId].senderUUID;
  renderGroupsUI();
  log('Received announce from', senderUUID, meta.name || meta.id);
}

/* --------------- Request handlers (sender side) --------------- */
async function handleRequestFile(payload, requesterUUID){
  // payload: { id }
  if (!payload || !payload.id) return;
  const id = payload.id;
  const meta = files[id];
  if (!meta) { log('Requested file not found locally', id); return; }
  log('Peer requested file', meta.name, '->', requesterUUID);
  await sendFileChunksToPeer(meta, requesterUUID);
}

async function handleRequestFolder(payload, requesterUUID){
  // payload: { groupId }
  if (!payload || !payload.groupId) return;
  const groupId = payload.groupId;
  log('Peer requested folder', groupId, '->', requesterUUID);
  // find all local files that belong to that group
  const groupFileIds = Object.keys(files).filter(fid => files[fid].groupId === groupId);
  // send sequentially (to avoid bursts)
  for (const fid of groupFileIds) {
    await sendFileChunksToPeer(files[fid], requesterUUID);
    await sleep(120); // small gap between files
  }
}

/* ------------ Chunk sending (sender -> specific peer) ------------ */
async function sendFileChunksToPeer(meta, targetUUID){
  const file = meta.file;
  if (!file) return;
  const total = Math.ceil(file.size / CHUNK_SIZE) || 1;
  let offset = 0, index = 0;
  log(`Start sending ${meta.name} (${meta.size} bytes) to ${targetUUID}`);
  while (offset < file.size) {
    const slice = file.slice(offset, offset + CHUNK_SIZE);
    const ab = await readAsArrayBuffer(slice);
    const b64 = arrayBufferToBase64(ab);
    postToIframe({
      sendData: { [APP_NS]: { type: 'chunk', payload: { id: meta.id, index, total, data: b64, name: meta.name, groupId: meta.groupId } } },
      type: 'pcs',
      UUID: targetUUID
    });
    offset += CHUNK_SIZE; index++;
    // small yield to avoid blocking
    await sleep(10);
  }
  // final message
  postToIframe({
    sendData: { [APP_NS]: { type: 'complete', payload: { id: meta.id, name: meta.name, groupId: meta.groupId } } },
    type: 'pcs',
    UUID: targetUUID
  });
  log(`Finished sending ${meta.name} to ${targetUUID}`);
}

/* --------------- Receiving chunks & finalize --------------- */
function handleChunk(chunkMsg, senderUUID){
  // chunkMsg: { id, index, total, data (b64), name, groupId }
  if (!incoming[chunkMsg.id]) incoming[chunkMsg.id] = { meta: { name: chunkMsg.name, groupId: chunkMsg.groupId, senderUUID }, chunks: {}, total: chunkMsg.total };
  incoming[chunkMsg.id].chunks[chunkMsg.index] = chunkMsg.data;
  const receivedCount = Object.keys(incoming[chunkMsg.id].chunks).length;
  log(`Receiving ${chunkMsg.name} [${chunkMsg.id}] ${receivedCount}/${chunkMsg.total} from ${senderUUID}`);
}

function handleComplete(payload, senderUUID){
  // payload: { id, name, groupId }
  const id = payload.id;
  const entry = incoming[id];
  if (!entry) { log('Complete received but no incoming entry for', id); return; }
  // join base64 chunks in index order
  const indices = Object.keys(entry.chunks).map(Number).sort((a,b)=>a-b);
  const joined = indices.map(i => entry.chunks[i]).join('');
  const ab = base64ToArrayBuffer(joined);
  const blob = new Blob([ab]);
  const fname = entry.meta.name || payload.name || `file-${id}`;
  const url = URL.createObjectURL(blob);

  // render link in the UI (under offers area)
  const parentGroup = payload.groupId || entry.meta.groupId;
  const groupEl = document.getElementById(`group-${parentGroup}`) || offersDiv;
  const a = document.createElement('a');
  a.href = url;
  a.download = fname;
  a.className = 'download-link';
  a.textContent = `‚¨á ${fname} (${formatBytes(blob.size)})`;
  groupEl.appendChild(a);
  groupEl.appendChild(document.createElement('br'));

  log(`Completed download ready: ${fname} (${formatBytes(blob.size)})`);
  delete incoming[id];
}

/* ----------------- UI: Drop & add files ----------------- */
dropZone.addEventListener('click', ()=> {
  const ip = document.createElement('input'); ip.type = 'file'; ip.multiple = true; ip.webkitdirectory = true;
  ip.onchange = (e) => { handleFileList(e.target.files); };
  ip.click();
});
['dragenter','dragover'].forEach(ev => {
  dropZone.addEventListener(ev, e => { e.preventDefault(); dropZone.style.background = '#eef'; });
});
['dragleave','drop'].forEach(ev => {
  dropZone.addEventListener(ev, e => { e.preventDefault(); dropZone.style.background = ''; });
});
dropZone.addEventListener('drop', async (e) => {
  e.preventDefault();
  dropZone.style.background = '';
  const items = e.dataTransfer.items;
  if (!items) return handleFileList(e.dataTransfer.files);
  // handle directory entries with webkitGetAsEntry where available
  const fileEntries = [];
  for (let i=0;i<items.length;i++){
    const it = items[i];
    const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
    if (entry && entry.isDirectory) {
      await readDirectoryEntries(entry, '', fileEntries);
    } else if (it.getAsFile) {
      const f = it.getAsFile();
      // try to detect relativePath if present
      if (f) fileEntries.push(f);
    }
  }
  handleFileList(fileEntries);
});

async function readDirectoryEntries(dirEntry, pathPrefix, outList){
  const reader = dirEntry.createReader();
  const read = ()=> new Promise((res,rej)=> reader.readEntries(res,rej));
  let entries = await read();
  while(entries.length){
    for (const e of entries){
      if (e.isDirectory) await readDirectoryEntries(e, pathPrefix + dirEntry.name + '/', outList);
      else if (e.isFile) {
        await new Promise(res => e.file(file => {
          file.relativePath = (pathPrefix ? pathPrefix + dirEntry.name + '/' : dirEntry.name + '/') + file.name;
          outList.push(file); res();
        }));
      }
    }
    entries = await read();
  }
}

function handleFileList(list){
  // group everything dropped together by a groupId
  const groupId = generateId();
  groups[groupId] = groups[groupId] || { files: {}, name: `group-${groupId}`, senderUUID: null };
  for (let i=0;i<list.length;i++){
    const f = list[i];
    const id = generateId();
    const relativePath = f.relativePath || f.webkitRelativePath || f.name;
    files[id] = { id, file: f, name: f.name, size: f.size, mime: f.type, relativePath, groupId };
    groups[groupId].files[id] = { id, name: files[id].name, size: files[id].size, relativePath, groupId };
    // announce metadata to peers
    const meta = { id, name: files[id].name, size: files[id].size, mime: files[id].mime, groupId, relativePath, timestamp: Date.now(), groupName: groups[groupId].name };
    postToIframe({ sendData: { [APP_NS]: { type: 'announce', payload: meta } }, type: 'pcs' });
    log('Announced file', files[id].name, 'group', groupId);
  }
  // also render locally (so sender can see its own group)
  renderGroupsUI();
}

/* ---------------- UI: render groups (receiver & sender view) ---------------- */
function renderGroupsUI(){
  offersDiv.innerHTML = '';
  for (const gid of Object.keys(groups)){
    const g = groups[gid];
    const groupEl = document.createElement('div');
    groupEl.className = 'group';
    groupEl.id = `group-${gid}`;
    groupEl.innerHTML = `
      <div class="group-header">
        <div>
          <strong>üìÅ ${escapeHtml(g.name)}</strong>
          <div class="small">${Object.keys(g.files).length} file(s)</div>
        </div>
        <div>
          <button class="ghost" data-gid="${gid}" style="margin-right:8px">Toggle</button>
          <button data-download-all="${gid}">Download All</button>
        </div>
      </div>
      <div class="group-files" id="group-files-${gid}" style="display:none"></div>
    `;
    offersDiv.appendChild(groupEl);

    // populate files list
    const listEl = groupEl.querySelector(`#group-files-${gid}`);
    listEl.innerHTML = '';
    for (const fid of Object.keys(g.files)) {
      const meta = g.files[fid];
      const fileRow = document.createElement('div');
      fileRow.className = 'file-row';
      fileRow.innerHTML = `<div><div>${escapeHtml(meta.name)}</div><div class="small">${escapeHtml(meta.relativePath)} ‚Äî ${formatBytes(meta.size)}</div></div>
                           <div><button data-req="${fid}">Download</button></div>`;
      listEl.appendChild(fileRow);
    }

    // toggle button
    groupEl.querySelector('.ghost').addEventListener('click', () => {
      listEl.style.display = listEl.style.display === 'none' ? 'block' : 'none';
    });

    // per-file download handlers send a request-file targeted to the sender of that group
    groupEl.querySelectorAll('[data-req]').forEach(btn => {
      btn.addEventListener('click', () => {
        const fid = btn.getAttribute('data-req');
        const senderUUID = groups[gid].senderUUID || inferSenderForGroup(gid);
        if (!senderUUID) { log('No sender known for this group yet'); return alert('Sender unknown yet'); }
        postToIframe({ sendData: { [APP_NS]: { type: 'request-file', payload: { id: fid } } }, type: 'pcs', UUID: senderUUID });
        log('Requested file', files[fid].name, 'from', senderUUID);
      });
    });

    // download all button
    groupEl.querySelector(`[data-download-all="${gid}"]`).addEventListener('click', async () => {
      const senderUUID = groups[gid].senderUUID || inferSenderForGroup(gid);
      if (!senderUUID) return alert('Sender unknown yet');
      postToIframe({ sendData: { [APP_NS]: { type: 'request-folder', payload: { groupId: gid } } }, type: 'pcs', UUID: senderUUID });
      log('Requested folder', gid, 'from', senderUUID);
    });
  }
}

/* ------------ Utility: infer sender if not set -------------- */
function inferSenderForGroup(groupId){
  // if group.senderUUID is missing, try to pick the first connected peer (best-effort)
  const g = groups[groupId];
  if (g && g.senderUUID) return g.senderUUID;
  const ids = Object.keys(connectedPeers);
  return ids.length ? ids[0] : null;
}

/* ------------ File reading helper ------------- */
function readAsArrayBuffer(blob){ return new Promise((res,rej)=>{ const r = new FileReader(); r.onload = ()=> res(r.result); r.onerror = rej; r.readAsArrayBuffer(blob); }); }
function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

/* -------------- Misc: expose files to sender UI ------------- */
/* When the sender drops files, we already added them to `files` and `groups`.
   Optionally you may want to show the sender UI differently. For simplicity we
   reuse the same groups UI; the sender will see its own group and can click
   Download (which will request itself ‚Äî but sender can upload directly without
   going through request if you prefer). */

/* ----------------- Start/Finish ----------------- */
log('Ready. Join a room and drop files.');

/* ----------------- End of script ----------------- */
</script>
</body>
</html>
