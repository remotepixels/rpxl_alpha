<!doctype html>
<html lang="en">

<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="-1" />
  <meta name="msapplication-TileColor" content="#2e2e2e" />
  <meta name="description"
    content="Serverless web app that allows you transmit to a high quality stream to clients to view and comment on using WEBRTC and VDO.NINJA. Communication between clients is handled using low latency and very little bandwidth, dedicating as much bandwidth to the main strea, often the feed from an edit machine. Also, we think Capybara's are awesome though that might not be relevant in this case.">
  <meta name="keywords" content="Gui Felix, Advertising, Visual Effects, Motion Graphics, Remote Pixels, vdo.ninja" />
  <meta name="robots" content="index, follow" />
  <meta name="viewport"
    content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/icons/favicon.ico">
  <meta name="color-scheme" content="light dark">

  <title>File Share</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@200" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="mainWindow" class="mainWindow">
    <!--top menu bar-->
    <div id="topmenu" class="toolbar top hidden">
      <div class="toolset" id="shareTools">
        <button class="tool" id="shareBtn" aria-expanded="false" role="button">
          <span class="material-symbols-outlined">ios_share</span>
        </button>
      </div>
      <div class="toolset">
        <span class="tool toolwider">Status : <span id="senderStatus">Idle</span></span>
        <span class="tool toolwider">Peers : <span id="peersList">(0)</span></span>
      </div>
      <div class="toolset">
        <button class="tool toolmoresettings" id="logBtn" aria-expanded="false" role="button">
          <span class="material-symbols-outlined">terminal</span></button>
      </div>
    </div>
    <div class="logAndFiles">
      <pre class="log hidden" id="log"></pre>
      <div class="file-list" id="fileList"></div>
      <div class="copyCredit"><a href="https://vdo.ninja" target="_blank">Powered by vdo.ninja</a></div>
    </div>

  </div>

  <div id="container" class="" style="display:block; position:fixed; width:100%; height:200px; bottom:0px;z-index:12">
  </div>

  <div class="drop" id="dropArea">
    <div class="material-symbols-outlined largeIcon">drive_folder_upload</div>
    <div>
      <h1>Drag & drop files or folders here</h1>
    </div>
  </div>

  <!----- Copied links to clipboard ------>
  <div id="popupClipboard" class="toolpopup hidden">
    <div class="material-symbols-outlined largeIcon">assignment_turned_in</div>
    <div>
      <h1>Link copied to clipboard</h1>
    </div>
  </div>
</body>

</html>

<script lang="javascript">

  // Namespace used in messages sent through VDO.Ninja
  const APP_NS = 'FileShareDemo';

  // ----------------------------------------
  let iframe = null;
  let connectedPeers = {}; // map streamID -> label
  let roomName = '';
  const files = {}; // id -> {file, name, size, chunks:[], progress}
  const folderMap = {}; // keeps track of folder DOM nodes

  const dropArea = document.getElementById('dropArea');
  const fileList = document.getElementById('fileList');
  const logEl = document.getElementById('log');
  const peersList = document.getElementById('peersList');
  const senderStatus = document.getElementById('senderStatus');
  const shareBtn = document.getElementById('shareBtn');
  const logBtn = document.getElementById('logBtn');
  const popupClipboard = document.getElementById('popupClipboard');

  const devURL = window.location.origin;

  let localUUID = crypto.randomUUID();

// senddata schema ref
//   {
//   sendData: {
//     [APP_NS]: {
//       dataType: "<type>",
//       payload: { ... }
//     }
//   },
//   type: "pcs",
//   streamID: "<targetStreamID>"   // optional â†’ broadcast if omitted
// }

  log('Local Browser UUID:', localUUID);

  function log(...args) {
    console.log(...args);
    logEl.textContent += args.join(' ') + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  shareBtn.addEventListener('pointerdown', () => {
    navigator.clipboard.writeText(`${devURL}/transfer/vdo_ninja_file_share.html?SID=${roomName}`);
    popupClipboard.classList.remove("hidden");
    setTimeout(() => {
      popupClipboard.classList.add("hidden");
    }, 2000);
    console.log('Session link copied to clipboard');
  });

  logBtn.addEventListener('pointerdown', () => {
    document.getElementById('log').classList.toggle('hidden');
  });

  checkSessionURL();  //autoconnect if session ID in URL

  //check if session ID is present in URL and autoconnect
  function checkSessionURL() {
    const queryURL = window.location.search.slice(1);
    //let decodeURL;
    const params = new URLSearchParams(queryURL);
    if (params.has('SID')) {
      const SID = params.get('SID');
      roomName = encodeURIComponent(SID);
      if (!roomName || roomName.length !== 20) {
        //console.log('INCORRECTLY FORMATED SESSION ID');
        return;
      } else {
        console.log('SESSION ID FOUND IN URL:', roomName);
        createIframe(roomName)
        document.getElementById('shareTools').classList.add('hidden');
        document.getElementById('dropArea').classList.add('hidden');
        document.getElementById('topmenu').classList.remove('hidden');
        //document.getElementById('file-list').classList.remove('hidden');
        return;
      }
    } else {
      var length = 20;
      const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      roomName = Array.from({ length }, () => chars.charAt(Math.floor(Math.random() * chars.length))).join('');
      console.log('NO SESSION ID IN URL, GENERATING NEW ONE : ', roomName);
      createIframe(roomName);
    }
  }

  // --- Join room / create iframe ---
  function createIframe(room) {
    if (iframe) iframe.remove();
    const container = document.getElementById('container');
    iframe = document.createElement('iframe');
    iframe.allow = 'camera;microphone;fullscreen;display-capture;autoplay;';
    iframe.src = `https://alpha.rpxl.app/vdo/?director&room=${room}&push=${localUUID}&dataonly&cleanish`;
    iframe.style.width = '100%';
    iframe.style.height = '200px';
    container.appendChild(iframe);
  }

  // Set up event listener (cross-browser compatible)
  var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
  var eventer = window[eventMethod];
  var messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";

  // Add the event listener
  eventer(messageEvent, function (e) {
    if (e.source !== iframe.contentWindow) return;
    //console.log("events",e);
    // --- Connection events ---
    if ("action" in e.data) {
      if (e.data.action === "guest-connected" && e.data.streamID) {
        connectedPeers[e.data.streamID] = e.data.value?.label || "Guest";
        console.log("Guest connected:", e.data.streamID, "Label:", connectedPeers[e.data.streamID]);
      }
      else if (e.data.action === "push-connection" && e.data.value === false && e.data.streamID) {
        console.log("Guest disconnected:", e.data.streamID);
        delete connectedPeers[e.data.streamID];
      }
      else if (e.data.action === "view-connection") {
        if (e.data.value) {
          connectedPeers[e.data.streamID] = "Viewer";
          handleGuestJoin(e.data.streamID);
        } else {
          delete connectedPeers[e.data.streamID];
        }
        updatePeersUI();
      }
    }

    // --- Data received from peers ---
    if (e.data.dataReceived && e.data.dataReceived[APP_NS]) {
      //console.log("Data received:", e.data.dataReceived);
      handleDataReceived(e.data)
    }
  }, false);

  //handle user connects and disconnects
  function handleAction(data) {
    if (data.action === 'view-connection') {
      if (data.value) { connectedPeers[data.streamID] = 'Viewer'; } else { delete connectedPeers[data.streamID]; }
      updatePeersUI();
      handleGuestJoin(data.streamID);
     }
  }

  async function handleGuestJoin(guestUUID) {
    log('Guest connected :', guestUUID);
    //delay to ensure peer connection is ready
    await sleep(500);

    const keys = Object.keys(files);
    if (keys.length > 0) {
      log(`Auto-sending ${keys.length} files to new guest ${guestUUID}...`);
      //await sendAllFilesToPeer(guestUUID);
      for (const id of keys) {
        await sendToPeer(targetStreamID, "file-announce", meta);
      }
    } else {
      log('No files to send.');
    }
  }

  function updatePeersUI() {
    const total = Object.keys(connectedPeers).length;
    let statusText = '';

//must status bits here eventually but you know, other more important things to dofor now in stead of writing really long comments so i can find this spot again
    peersList.textContent = total === 0
      ? '(0)'
      : `(${total})`;
  }

  //--- drag & drop / file handling ---
  dropArea.addEventListener('pointerdown', () => {
    const ip = document.createElement('input'); ip.type = 'file'; ip.multiple = true; ip.webkitdirectory = true;
    ip.addEventListener('change', (ev) => { handleFileList(ev.target.files); });
    ip.click();
  });

  const dropOverlay = document.getElementById('dropArea');
  let dragCounter = 0; // helps handle nested dragenter/dragleave events

  window.addEventListener('dragenter', (e) => {
    e.preventDefault();
    dragCounter++;
    dropOverlay.classList.add('dragover');
  });

  window.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dragCounter--;
    if (dragCounter === 0) dropOverlay.classList.remove('dragover');
  });

  window.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  window.addEventListener('drop', (e) => {
    e.preventDefault();
    dragCounter = 0;
    dropOverlay.classList.remove('dragover');
  });

  dropArea.addEventListener('drop', async (e) => {
    const items = e.dataTransfer.items;
    if (!items) return handleFileList(e.dataTransfer.files);

    //hide dop area after 1st drop and show main interface
    document.getElementById('dropArea').classList.add('hidden');
    document.getElementById('topmenu').classList.remove('hidden');

    // Use directory traversal when available
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
      if (entry && entry.isDirectory) {
        await readDirectory(entry);
      } else if (entry && entry.isFile) {
        entry.file(file => addFile(file));
      } else if (it.getAsFile) {
        addFile(it.getAsFile());
      }
    }
  });

  //filter hidden files
  function isHiddenFile(fileOrPath) {
    const name = typeof fileOrPath === 'string' ? fileOrPath : fileOrPath.name || '';
    return name.startsWith('.') || name === ''; // covers .DS_Store, .gitignore, etc.
  }

  // Recursive directory traversal
  async function readDirectory(dirEntry, path = '') {
    const reader = dirEntry.createReader();
    const readEntries = () => new Promise((res, rej) => reader.readEntries(res, rej));
    let entries = await readEntries();
    while (entries.length) {
      for (const e of entries) {
        if (e.isDirectory && !e.name.startsWith('.')) {
          await readDirectory(e, path + dirEntry.name + '/');
        } else if (e.isFile) {
          e.file((file) => {
            file.relativePath =
              (path ? path + dirEntry.name + '/' : dirEntry.name + '/') + file.name;
            if (!isHiddenFile(file)) addFile(file);
          });
        }
      }
      entries = await readEntries();
    }
  }

  // Called when user drops files/folders
  function handleFileList(list) {
    for (let i = 0; i < list.length; i++) {
      const file = list[i];
      if (!isHiddenFile(file)) addFile(file);
      else log(`Skipping hidden file: ${file.name}`);
    }
  }

  function addFile(file) {
    const id = generateId();
    const relativePath = file.relativePath || file.name;
    const pathParts = relativePath.split('/');
    const fileName = pathParts.pop();
    const folderPath = pathParts.join('/');

    files[id] = {
      id,
      name: fileName,
      size: file.size,
      folderPath,
      uploadedBy: localUUID,
      timestamp: Date.now()
    };

    renderTreeItem(files[id]);
    log(`Added: ${relativePath} (${formatBytes(file.size)})`);

    // Notify peers
    sendBroadcast("file-announce", meta);
  }

  //send file data when one is added or deleted
function sendFile(id, targetStreamID = null) {
  const meta = files[id];
  if (!meta) return;

  if (targetStreamID) {
    sendToPeer(targetStreamID, "file-announce", meta);
  } else {
    sendBroadcast("file-announce", meta);
  }
}
  

//wrap all post to iframe
function sendToPeer(targetStreamID, dataType, payload = {}) {
  postToIframe({
    sendData: {
      [APP_NS]: {
        dataType,
        payload
      }
    },
    type: "pcs",
    streamID: targetStreamID   // âœ… critical: VDO.Ninja sends only to target
  });
}

function sendBroadcast(dataType, payload = {}) {
  postToIframe({
    sendData: {
      [APP_NS]: {
        dataType,
        payload
      }
    },
    type: "pcs"
  });
}



  // Call your existing safe wrapper
  // postToIframe({
  //   ...msg,
  //   streamID: targetStreamID   // âœ… CRITICAL: transport-level targeting
  // });

  // console.log(`Sending file meta to peer: ${targetStreamID}`, meta);
//}




    // function sendToPeer(targetUUID) {
    //   iframe.contentWindow.postMessage({
    //     sendData: { [APP_NS]: meta, dataType: "file-announce" },
    //     type: "pcs",   // use "pcs" for peer connection send
    //     streamID: targetUUID   // target the specific peer
    //   }, "*");
    //   console.log(`Sending file meta to guest: ${targetUUID}`);
    // }

    // If a specific guestUUID was provided â†’ send only to them
  //   if (guestUUID) {
  //     sendToPeer(guestUUID);
  //   } else {
  //     // Otherwise broadcast to all connected peers
  //     for (const targetUUID of peerKeys) {
  //       sendToPeer(targetUUID);
  //     }
  //     console.log(`Broadcasted file meta to all ${peerKeys.length} peers`);
  //   }
  // }

  //Build folder tree recursively (for hosts add delete icon, for clients add a download icon)
  function renderTreeItem(f) {
    const isReceiver = f.uploadedBy !== localUUID; // true if file came from another peer

    const treeRoot = document.getElementById('fileList');
    const pathParts = f.folderPath ? f.folderPath.split('/') : [];
    let currentContainer = treeRoot;
    let currentPath = '';

    for (const part of pathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!folderMap[currentPath]) {
        const folderDiv = document.createElement('div');
        folderDiv.className = 'folder';
        folderDiv.dataset.path = currentPath;

        const iconType = isReceiver ? 'folder-download' : 'folder-delete';
        const iconLabel = isReceiver ? 'download' : 'delete';

        folderDiv.innerHTML = `
        <div class="folder-header" data-folder="${currentPath}">
          <span class="material-symbols-outlined folder-icon">folder</span>
          <strong class="folder-text">${escapeHtml(part)}</strong>
          <span class="material-symbols-outlined ${iconType}">${iconLabel}</span>
        </div>
        <div class="folder-contents"></div>
      `;

        currentContainer.appendChild(folderDiv);
        folderMap[currentPath] = folderDiv.querySelector('.folder-contents');

        // Expand/collapse folder
        folderDiv.querySelector('.folder-header').addEventListener('pointerdown', (e) => {
          if (e.target.classList.contains(iconType)) return; // skip toggle when clicking icon
          const contents = folderDiv.querySelector('.folder-contents');
          contents.style.display =
            contents.style.display === 'none' ? 'block' : 'none';
        });

        // Folder action (download or delete)
        folderDiv.querySelector(`.${iconType}`).addEventListener('pointerdown', async (e) => {
          e.stopPropagation();
          const folderPath = e.target.closest('.folder-header').dataset.folder;

          if (isReceiver) {
            requestDownload(folderPath, true); // download folder
          } else {
            if (confirm(`Delete entire directory "${folderPath}" and all its files?`)) {
              await deleteDirectory(folderPath);
            }
          }
        });
      }

      currentContainer = folderMap[currentPath];
    }

    // Create file entry
    const fileDiv = document.createElement('div');
    fileDiv.className = 'file-item';
    fileDiv.id = `data-${f.id}`;
    fileDiv.dataset.id = f.id;
    fileDiv.style.display = 'flex';
    fileDiv.style.justifyContent = 'space-between';
    fileDiv.style.alignItems = 'center';
    fileDiv.style.padding = '2px 10px';

    const fileIconClass = isReceiver ? 'file-download' : 'file-delete';
    const fileIconLabel = isReceiver ? 'download' : 'delete';

    fileDiv.innerHTML = `
    <span class="file-name">${escapeHtml(f.name)}</span>
    <span class="file-size">${formatBytes(f.size)}</span>
    <span class="material-symbols-outlined ${fileIconClass}">${fileIconLabel}</span>
  `;
    currentContainer.appendChild(fileDiv);

    // File action (download or delete)
    fileDiv.querySelector(`.${fileIconClass}`).addEventListener('pointerdown', async (e) => {
      e.stopPropagation();
      if (isReceiver) {
        requestDownload(f.id, false); // single file download
      } else {
        deleteFile(f.id);
      }
    });
  }

  //handle file delete and folders deletes
  async function deleteDirectory(path) {
    if (!path) return;
    log(`Deleting directory: ${path}`);

    // Find all file IDs inside that folder (recursively)
    const toDelete = Object.keys(files).filter(id =>
      files[id].folderPath.startsWith(path)
    );

    // Delete contained files
    for (const id of toDelete) {
      const el = document.querySelector(`.file-item[data-id="${id}"]`);
      if (el) el.remove();
      await sendFileRemoved(id, path);
      delete files[id];
    }

    // Remove the folder DOM
    const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
    if (folderDiv) folderDiv.remove();

    // Remove from folderMap
    delete folderMap[path];

    //announce directory removal to peers
    await sendDirectoryRemoved(path);

    //clean any now-empty parents
    cleanupEmptyFolders(path);
  }

  async function sendDirectoryRemoved(path, targetUUID = null) {
    const peerKeys = Object.keys(connectedPeers);
    if (peerKeys.length === 0) {
      console.log("No connected guests");
      return;
    }

    // iframe.contentWindow.postMessage({
    //   sendData: {[APP_NS]: path, dataType: "directory-removed" },
    //   type: "pcs"
    // }, "*");
sendBroadcast("directory-removed", { path });

    log(`Announced directory removal: ${path}`);
  }

  async function deleteFile(id) {
    const file = files[id];
    if (!file) return;

    const folderPath = file.folderPath || '';
    // Remove from files map and DOM
    delete files[id];
    const el = document.querySelector(`.file-item[data-id="${id}"]`);
    if (el) el.remove();

    log(`Deleted file : / ${folderPath} / ${file.name}`);

    // Clean up empty folders (locally)
    cleanupEmptyFolders(folderPath);
    // Send updated file list to peers
    await sendFileRemoved(id, folderPath);
  }

  async function sendFileRemoved(id, path) {
    const total = Object.keys(connectedPeers).length;
    if (total == 0) {
      console.log("no peers");
      return;
    }

sendBroadcast("file-removed", { id });

    // iframe.contentWindow.postMessage({
    //   sendData: { [APP_NS]: { id }, dataType: "file-removed" },
    //   type: "pcs"
    // }, "*");
    log(`Announced file removal`);
  }

  //client side data receiving
  async function handleDataReceived(msg) {
  const data = msg[APP_NS];
  // const msg = message[APP_NS];
   const dt = msg.dataType;
   const payload = msg.payload;
    //console.log("handling recieved data:", msg);// print the messages inbound to the console log
    console.log("!!!!!!!!! Received P2P message:", msg, "datatype :", dt);
    if (!msg && !dt) return;

    switch (msg.dataType) {
      //file and directory listing and removal
      case 'file-announce': {
        const f = data.payload || data;
        //Ignore files that were uploaded by yourself
        if (f.uploadedBy === localUUID) {
          console.log(`Ignoring file ${f.name} (uploaded by self)`);
          break;
        }
        //Optionally ignore duplicates if already have this file
        if (files[f.id]) {
          console.log(`Ignoring file ${f.name} (already listed)`);
          break;
        }
        files[f.id] = {
          id: f.id,
          name: f.name,
          size: f.size,
          folderPath: f.folderPath || '',
          uploadedBy: f.uploadedBy || null
        };
        renderTreeItem(files[f.id]);
        log(`Received file meta : ${f.folderPath} / ${f.name} - from ${f.uploadedBy}`);
        break;
      }
      case 'file-removed': {
        const f = data.payload || data;
        const id = f.id;
        const file = files[id];

        if (file) {
          delete files[id];
          const el = document.querySelector(`.file-item[data-id="${id}"]`);
          if (el) el.remove();
          log(`File removed remotely: ${file.name}`);
          cleanupEmptyFolders(file.folderPath);
        }
        break;
      }
      case 'directory-removed': {
        const { path } = data.payload || data;
        log(`Directory removed remotely: ${path}`);
        // Remove folder DOM
        const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
        if (folderDiv) folderDiv.remove();
        // Clean folder map reference
        delete folderMap[path];
        // Remove any remaining files (if not already cleaned)
        for (const id of Object.keys(files)) {
          if (files[id].folderPath.startsWith(path)) {
            delete files[id];
            const el = document.querySelector(`.file-item[data-id="${id}"]`);
            if (el) el.remove();
          }
        }
        cleanupEmptyFolders(path);
        break;
      }








      //this part of the application needs work
      //file transfering 
      // case 'request-file': {
       // console.log(`File request received from ${requester} for file - ${id}`);
       // const { id, filehost, localUUID } = data.payload || data;
        //const from = msg.from || null;

        //Ignore if this request came from self or isnâ€™t meant for us
        // if (filehost !== localUUID) {
        //   console.log(`Ignoring request-file for ${requester} â€” not host`);
        //   break;
        // }

      //   console.log(`File request received from`);
      //   respondToFileRequest(id, filehost, localUUID);
      //   break;
      // }

// in your existing window.addEventListener("message", (e) => { ... })
// if (e.data.dataReceived && e.data.dataReceived[APP_NS]) {
//   const msg = e.data.dataReceived[APP_NS];
//   const dt = msg.dataType;
//   const payload = msg.payload;

//   switch (dt) {
    case 'request-file':
      // payload: { id, requester, isFolder }
      // Only hosts should call respondToFileRequest; ensure you are the file owner
      // payload.requester is streamID of requester
      respondToFileRequest(payload.id, /* filehostStreamID */ localUUID /*or your own streamID*/, payload.requester);
      break;

    case 'file-chunk':
      // payload delivered to receiver
      handleIncomingChunk(payload, msg);
      break;

    case 'chunk-group-ack':
      handleChunkGroupAck(payload);
      break;

    case 'request-missing':
      // payload: { id, missing: [idx...] }
      // If we're the sender and have the file, resend those indices
      if (outgoingFiles[payload.id]) {
        const of = outgoingFiles[payload.id];
        // resending requested indices sequentially
        (async () => {
          const file = of.file;
          for (const idx of payload.missing || []) {
            const start = idx * FILE_CHUNK_BYTES;
            const end = Math.min(file.size, start + FILE_CHUNK_BYTES);
            const slice = file.slice(start, end);
            try {
              const buffer = await readBlobAsArrayBuffer(slice);
              const chunkMsg = {
                sendData: {
                  [APP_NS]: {
                    dataType: "file-chunk",
                    payload: {
                      id: payload.id,
                      index: idx,
                      totalChunks: of.totalChunks,
                      buffer: arrayBufferToBase64(buffer),
                      target: of.to,
                      from: localUUID
                    }
                  }
                }
              };
              postToIframeTarget(chunkMsg, of.to);
              await sleep(CHUNK_SEND_DELAY);
            } catch (err) {
              console.error('Failed resend chunk', idx, err);
            }
          }
        })();
      }
      break;

    case 'file-transfer-complete':
      // receiver finalization is handled in finalizeIncomingFile when all chunks present
      // but optionally you can auto-check and finalize if all chunks already present
      console.log('file-transfer-complete', payload);
      break;

    case 'file-not-found':
      log('Peer reports file not found:', payload.id);
      break;

    case 'file-transfer-error':
      log('Peer transfer error:', payload.id, payload.message);
      break;

    // keep your other handlers...
    default:
      console.warn('Unhandled dataType', dt, payload);
  }
}






    //   case 'file-chunk': {
    //     const { id, } = data.payload || data;

    //     const target = data.target || null;
    //     console.log("recieved chunk", id, target)
    //     //Ignore if itâ€™s our own chunk or not targeted to us
    //     if (target !== localUUID) {
    //       //console.log(`Ignoring file-chunk for ${id} â€” not meant for me`);
    //       break;
    //     }
    //     await handleIncomingChunk(data.payload, msg);
    //     break;
    //   }
    //   case 'file-transfer-complete': {
    //     // finalize the file
    //     const { id, target } = data.payload || data;
    //     const from = msg.from || null;

    //     // Ignore if self-sent or not meant for this client
    //     if (from === localUUID || (target && target !== localUUID)) {
    //       console.log(`Ignoring transfer-complete for ${id} â€” not meant for me`);
    //       break;
    //     }

    //     console.log(`Finalizing file: ${id}`);
    //     finalizeIncomingFile(id);
    //     break;

    //   }
    //   case 'file-not-found': {
    //     const { id } = data.payload || data;
    //     log(`Peer reports file not found: ${id}`);
    //     if (incomingFiles[id] && incomingFiles[id].reject) incomingFiles[id].reject(new Error('file-not-found'));
    //     break;
    //   }
    //   case 'file-transfer-error': {
    //     const { id, message } = data.payload || data;
    //     log(`Peer reported transfer error for ${id}:`, message);
    //     if (incomingFiles[id] && incomingFiles[id].reject) incomingFiles[id].reject(new Error(message || 'transfer-error'));
    //     break;
    //   }
    //   case 'chunk-ack': {
    //     const { id, index } = data.payload || data;
    //     if (outgoingFiles[id]) {
    //       outgoingFiles[id].acks = outgoingFiles[id].acks || {};
    //       outgoingFiles[id].acks[index] = true;
    //       // resolve waiting promise if present
    //       const key = `${id}:${index}`;
    //       const resolver = outgoingFiles[id].resolvers && outgoingFiles[id].resolvers[key];
    //       if (resolver) {
    //         try { resolver(); } catch (e) { }
    //         delete outgoingFiles[id].resolvers[key];
    //       }
    //     }
    //     break;
    //   }
    //   case 'request-missing': {
    //     // receiver asks for specific indices to be resent
    //     const { id, missing } = data.payload || data;
    //     log(`Peer requested missing chunks for ${id}:`, missing);
    //     if (!outgoingFiles[id]) {
    //       log('No outgoing state for', id);
    //       break;
    //     }
    //     const of = outgoingFiles[id];
    //     const file = of.meta?.file || files[id]?.file;
    //     if (!file) {
    //       log('Cannot resend missing - file not present');
    //       break;
    //     }
    //     // retransmit requested indices sequentially
    //     for (const idx of missing) {
    //       const start = idx * FILE_CHUNK_BYTES;
    //       const end = Math.min(file.size, start + FILE_CHUNK_BYTES);
    //       const blobSlice = file.slice(start, end);
    //       try {
    //         const buffer = await readBlobAsArrayBuffer(blobSlice);
    //         // send but do not necessarily await each ACK if you want faster behaviour
    //         await sendChunkWithRetry(of.to, id, idx, of.totalChunks, buffer);
    //       } catch (err) {
    //         log('Failed to resend chunk', idx, err);
    //       }
    //       await sleep(CHUNK_SEND_DELAY);
    //     }
    //     break;
    //   }
    // }
  // }

  // Remove any empty parent folders (recursively up)
  function cleanupEmptyFolders(startPath = null) {
    // climb up the tree from there and clean each ancestor if empty.
    if (startPath) {
      let parts = startPath.split('/');
      while (parts.length > 0) {
        const currentPath = parts.join('/');
        const folder = document.querySelector(`.folder[data-path="${currentPath}"]`);
        if (!folder) {
          parts.pop();
          continue;
        }

        const contents = folder.querySelector('.folder-contents');
        if (!contents || contents.children.length === 0) {
          log(`Removing empty folder: ${currentPath}`);
          folder.remove();
          delete folderMap[currentPath];
        }

        parts.pop(); // move up one level
      }
      return;
    }

    // If no path specified, do a full cleanup sweep
    const folders = document.querySelectorAll('.folder');
    for (const folder of folders) {
      const contents = folder.querySelector('.folder-contents');
      if (!contents || contents.children.length === 0) {
        const path = folder.dataset.path;
        log(`Removing empty folder: / ${path}`);
        folder.remove();
        delete folderMap[path];
      }
    }
  }

  // // --- helpers: post message wrapper ---
  // function postToIframe(msg) {
  //   if (!iframe || !iframe.contentWindow) return;
  //   try {
  //     //iframe.contentWindow.postMessage({ "getStreamIDs": true }, "*");
  //     iframe.contentWindow.postMessage(msg);
  //     console.log("message sent to iframe:", msg);
  //   } catch (e) {
  //     console.error("postToIframe failed:", e);
  //   }
  // }

  function createFileProgressUI(id, name) {
    const item = document.getElementById(`${id}_icon`);
    if (!item) return;

    const progress = document.createElement('div');

    item.innerHTML = `
      <div class="roundProgressBarBG">
      <div class="roundProgressBarFill" id="progress-bar-${id}" style=""></div>
          <div class="roundProgressBarCenter"></div>
      </div>`
  }

  function updateFileProgressUI(id, percent) {
    const bar = document.getElementById(`progress-bar-${id}`);
    const pct = Math.max(0, Math.min(100, Number(percent) || 0));
    const deg = pct * 3.6; // 100% -> 360Â°
    bar.style.backgroundImage = `conic-gradient(dodgerblue ${deg}deg, light-dark(var(--color-light-white), var(--color-dark-grey)) ${deg}deg)`;
  }


// ========================================================
//  FILE TRANSFER ENGINE â€” CLEAN & UNIFIED
//  Uses: sendToPeer(), sendBroadcast()
// ========================================================

const FILE_CHUNK_BYTES = 64 * 1024;
const GROUP_SIZE = 8;
const ACK_TIMEOUT_MS = 2000;
const MAX_CHUNK_RETRIES = 4;
const CHUNK_SEND_DELAY = 8;

const outgoingFiles = {};
const incomingFiles = {};
let activeTransfers = 0;

// ------------------------- UTILITIES ---------------------------

function arrayBufferToBase64(buffer) {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.length; i += 0x8000) {
    binary += String.fromCharCode.apply(null, bytes.subarray(i, i + 0x8000));
  }
  return btoa(binary);
}

function base64ToArrayBuffer(base64) {
  const bin = atob(base64);
  const len = bin.length;
  const out = new Uint8Array(len);
  for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i);
  return out.buffer;
}

function readBlobAsArrayBuffer(blob) {
  return new Promise((resolve, reject) => {
    const fr = new FileReader();
    fr.onload = () => resolve(fr.result);
    fr.onerror = reject;
    fr.readAsArrayBuffer(blob);
  });
}

function sleep(ms) {
  return new Promise(r => setTimeout(r, ms));
}

// ========================================================
// 1) RECEIVER REQUESTS FILE
// ========================================================

function requestDownload(fileID, isFolder = false) {
  const meta = files[fileID];
  if (!meta) return console.error("requestDownload: no such file");

  const hostStreamID = meta.uploadedBy; // MUST be streamID of host

  sendToPeer(hostStreamID, "request-file", {
    id: fileID,
    requester: localUUID,
    isFolder
  });

  log(`Requested file ${fileID} from ${hostStreamID}`);
}

// ========================================================
// 2) HOST RECEIVES REQUEST â†’ starts sending
// ========================================================

async function respondToFileRequest(fileID, requesterStreamID) {
  const meta = files[fileID];
  const file = meta?.file;

  if (!file) {
    sendToPeer(requesterStreamID, "file-not-found", { id: fileID });
    return;
  }

  const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);

  outgoingFiles[fileID] = {
    id: fileID,
    file,
    meta,
    totalChunks,
    to: requesterStreamID,
    groupStatus: {}
  };

  activeTransfers++;

  try {
    await sendChunksToPeer(fileID, requesterStreamID);
  } catch (err) {
    sendToPeer(requesterStreamID, "file-transfer-error", {
      id: fileID,
      message: err.message || "transfer-failed"
    });
  }

  delete outgoingFiles[fileID];
  activeTransfers--;
}

// ========================================================
// 3) HOST â†’ send chunks in groups
// ========================================================

async function sendChunksToPeer(fileID, targetStreamID) {
  const of = outgoingFiles[fileID];
  const file = of.file;
  const total = of.totalChunks;

  const groupCount = Math.ceil(total / GROUP_SIZE);

  for (let group = 0; group < groupCount; group++) {
    let acknowledged = false;

    for (let attempt = 0; attempt <= MAX_CHUNK_RETRIES; attempt++) {
      // ----- send group -----
      const start = group * GROUP_SIZE;
      const end = Math.min(total, start + GROUP_SIZE);

      for (let idx = start; idx < end; idx++) {
        const s = idx * FILE_CHUNK_BYTES;
        const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
        const buf = await readBlobAsArrayBuffer(file.slice(s, e));

        sendToPeer(targetStreamID, "file-chunk", {
          id: fileID,
          index: idx,
          totalChunks: total,
          buffer: arrayBufferToBase64(buf),
          target: targetStreamID,
          from: localUUID
        });

        await sleep(CHUNK_SEND_DELAY);
      }

      // ----- wait for ACK -----
      acknowledged = await waitForGroupAck(fileID, group, targetStreamID);
      if (acknowledged) break;
    }

    if (!acknowledged) throw new Error(`Group ${group} failed`);
  }

  // all done
  sendToPeer(targetStreamID, "file-transfer-complete", {
    id: fileID,
    totalChunks: of.totalChunks
  });
}

// ========================================================
// 4) WAIT FOR GROUP ACK (Promise)
// ========================================================

const ackWaiters = {};  // key = `${id}:${group}` â†’ resolve()

function waitForGroupAck(id, group, fromStreamID) {
  return new Promise(resolve => {
    const key = `${id}:${group}`;
    ackWaiters[key] = resolve;

    setTimeout(() => {
      if (ackWaiters[key]) {
        delete ackWaiters[key];
        resolve(false);
      }
    }, ACK_TIMEOUT_MS);
  });
}

// ========================================================
// 5) RECEIVER HANDLES CHUNK
// ========================================================

async function handleIncomingChunk(payload) {
  const { id, index, totalChunks, buffer, target, from } = payload;

  if (target !== localUUID) return;

  if (!incomingFiles[id]) {
    incomingFiles[id] = {
      id,
      totalChunks,
      buffers: {},
      received: 0,
      sender: from
    };
  }

  const inf = incomingFiles[id];
  if (!inf.buffers[index]) {
    inf.buffers[index] = buffer;
    inf.received++;
  }

  const group = Math.floor(index / GROUP_SIZE);
  const groupComplete = isGroupComplete(inf, group);

  if (groupComplete) {
    sendToPeer(from, "chunk-group-ack", {
      id,
      groupIndex: group,
      from: localUUID
    });
  }

  if (inf.received === inf.totalChunks) finalizeIncomingFile(id);
}

function isGroupComplete(inf, groupIndex) {
  const start = groupIndex * GROUP_SIZE;
  const end = Math.min(inf.totalChunks, start + GROUP_SIZE);
  for (let i = start; i < end; i++) {
    if (!inf.buffers[i]) return false;
  }
  return true;
}

// ========================================================
// 6) RECEIVER SENDS GROUP ACK â†’ notify sender
// ========================================================

function handleChunkGroupAck(payload) {
  const { id, groupIndex, from } = payload;
  const key = `${id}:${groupIndex}`;

  if (ackWaiters[key]) {
    ackWaiters[key](true);
    delete ackWaiters[key];
  }
}

// ========================================================
// 7) RECEIVER FINALIZES FILE
// ========================================================

function finalizeIncomingFile(id) {
  const inf = incomingFiles[id];
  if (!inf) return;

  const buffers = [];
  for (let i = 0; i < inf.totalChunks; i++) {
    const b64 = inf.buffers[i];
    if (!b64) {
      requestMissingChunks(id, inf.sender);
      return;
    }
    buffers.push(base64ToArrayBuffer(b64));
  }

  const blob = new Blob(buffers);
  const meta = files[id];
  const filename = meta?.name || `file-${id}`;
  const url = URL.createObjectURL(blob);

  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  a.click();

  URL.revokeObjectURL(url);
  delete incomingFiles[id];

  log(`Completed download: ${filename}`);
}

// ========================================================
// 8) REQUEST MISSING CHUNKS
// ========================================================

function requestMissingChunks(id, senderStreamID) {
  const inf = incomingFiles[id];
  if (!inf) return;

  const missing = [];
  for (let i = 0; i < inf.totalChunks; i++) {
    if (!inf.buffers[i]) missing.push(i);
  }

  sendToPeer(senderStreamID, "request-missing", {
    id,
    missing
  });
}

// ========================================================
// 9) SENDER HANDLES request-missing
// ========================================================

async function handleRequestMissing(payload) {
  const { id, missing } = payload;
  const of = outgoingFiles[id];
  if (!of) return;

  const file = of.file;

  for (const idx of missing) {
    const s = idx * FILE_CHUNK_BYTES;
    const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
    const buf = await readBlobAsArrayBuffer(file.slice(s, e));

    sendToPeer(of.to, "file-chunk", {
      id,
      index: idx,
      totalChunks: of.totalChunks,
      buffer: arrayBufferToBase64(buf),
      target: of.to,
      from: localUUID
    });

    await sleep(CHUNK_SEND_DELAY);
  }
}

















  // // utility: read arrayBuffer from slice
  // function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
 function generateId() { return Math.random().toString(36).slice(2, 10); }
 function formatBytes(a) { if (a === 0) return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const e = Math.floor(Math.log(a) / Math.log(1024)); return (a / Math.pow(1024, e)).toFixed(2) + ' ' + units[e]; }
 function escapeHtml(s) { return String(s).replace(/[&<>\"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" })[c]); }






























































//   // ------------- Download + queue + chunking implementation -------------
//   // Config
//   const CHUNK_SIZE = 512 * 1024; // 256 KB Chunk size (bytes) for file transfer. Lower = more messages, smaller memory.
//   const MAX_CONCURRENT_TRANSFERS = 5;    // browser concurrency limit
//   const FILE_CHUNK_BYTES = CHUNK_SIZE;   // reuse CHUNK_SIZE you already have
//   const CHUNK_SEND_DELAY = 3;           // ms between chunk sends to avoid congestion
//   const CHUNK_ACK_TIMEOUT = 5000;    // ms to wait for an ack
//   const CHUNK_MAX_RETRIES = 3;       // number of retries per chunk

//   // Keep outgoing file send state: outgoingFiles[id] = { acks: {}, resolvers: {}, retries: {}, totalChunks, meta, paused }
//   const outgoingFiles = {};

//   // Queue state
//   const downloadQueue = [];   // items: { id, fromUUID }
//   let activeTransfers = 0;

//   // Keep partial incoming file assembly
//   // incomingFiles[id] = { chunks:[], totalChunks, receivedCount, meta: { name, size, folderPath, uploadedBy } }
//   const incomingFiles = {};

//   // Called by UI when user requests a download
//   // idOrPath: either file id (for single file) or folder path (when isFolder true)
//   async function requestDownload(idOrPath, isFolder = false) {
//     //if (!iframe) return alert('Join a room first');
//     if (isFolder) {
//       // enqueue all files under this folder
//       const toDownload = Object.keys(files).filter(fid => files[fid].folderPath.startsWith(idOrPath));
//       if (!toDownload.length) return alert('No files in directory');
//       for (const fid of toDownload) enqueueDownload(fid);
//       log(`Enqueued ${toDownload.length} files for folder download: ${idOrPath}`);
//     } else {
//       // single file id
//       const fid = idOrPath;
//       if (!files[fid]) return alert('File not found');
//       enqueueDownload(fid, localUUID);
//       log(`Enqueued file: / ${files[fid].folderPath} / ${files[fid].name}`);
//     }
//     processDownloadQueue();
//   }

//   // add to queue
//   function enqueueDownload(id, fromUUID = null) {
//     downloadQueue.push({ id, fromUUID });
//     files[id] = files[id] || {}; // ensure entry exists
//     files[id].status = 'queued';
//   }

//   // main queue worker
// async function processDownloadQueue() {
//   if (activeTransfers >= MAX_CONCURRENT_TRANSFERS) return;
//   if (!downloadQueue.length) return;

//   while (activeTransfers < MAX_CONCURRENT_TRANSFERS && downloadQueue.length) {
//     const item = downloadQueue.shift();
//     activeTransfers++;

//     const fileId = item.id;
//     const fileHost = files[fileId].uploadedBy;

//     files[fileId].status = 'transferring';
//     log(`Requested file : / ${files[fileId]?.folderPath} / ${files[fileId]?.name} from user : ${fileHost || 'meta not present yet'}`);

//     try {
//       await requestFileFromPeer(fileId, fileHost);
//     } catch (err) {
//       log(`Download failed for ${fileId}: ${err.message}`);
//       files[fileId].status = 'failed';
//     } finally {
//       activeTransfers--;
//     }
//   }
// }


//   // ask peers for a file (will trigger peer-side responder)
//   function requestFileFromPeer(id, filehost) {
//     return new Promise((resolve, reject) => {
//     iframe.contentWindow.postMessage({
//       sendData: {[APP_NS]:  { id, filehost, localUUID }, dataType: "request-file" },
//       type: "pcs",   // use "pcs" for peer connection send
//       streamID: filehost   // target the specific peer
//     }, "*");


//       // Setup a timeout in case no one responds
//       let timedOut = false;
//       const timeout = setTimeout(() => {
//         timedOut = true;
//         log(`Request timed out for file ${id}`);
//         reject(new Error('request-timeout'));
//       }, 10_000); // 10s timeout - adjust as necessary

//       // Save callback to be invoked when file is fully received.
//       // We'll use incomingFiles to track; check completion in handleDataReceived.
//       incomingFiles[id] = incomingFiles[id] || { chunks: {}, totalChunks: null, receivedCount: 0, resolve, reject, meta: files[id] || {} };
//       incomingFiles[id].resolve = () => {
//         if (timedOut) return;
//         clearTimeout(timeout);
//         files[id].status = 'downloaded';
//         log(`Download complete: ${id}`);
//         resolve();
//       };
//       incomingFiles[id].reject = (err) => {
//         if (timedOut) return;
//         clearTimeout(timeout);
//         files[id].status = 'failed';
//         reject(err || new Error('receive-failed'));
//       };

//     console.log("asking for", id, 'from host', filehost)
//     });
//   }

//   // ---- Sender: respond to 'request-file' by streaming chunks ----


//   // Respond to a file request. Accepts either a payload object or (id, filehost, requester)
//   async function respondToFileRequest(id, filehost, requester) {
//   // normalize params: allow both respondToFileRequest({ id, filehost, requester }) OR respondToFileRequest(id, filehost, requester)
//   // const isObj = typeof payloadOrId === 'object' && payloadOrId !== null;
//   // const id = isObj ? payloadOrId.id : payloadOrId;
//   // const filehost = isObj ? payloadOrId.filehost : maybeFilehost;
//   // const requester = isObj ? payloadOrId.requester : maybeRequester;

//   if (!id || !requester) {
//     console.warn('respondToFileRequest: missing id or requester', { id, requester, filehost });
//     return;
//   }

//   const meta = files[id];
//   console.log("meta", meta)
//   // If file not found (or file property missing) -> notify the requester only
//   if (!meta || !meta.file) {
//     console.log(`Requested file not found locally: ${id} -> notifying ${requester}`);
//     iframe.contentWindow.postMessage({
//       sendData: {
//         [APP_NS]: {
//           dataType: 'file-not-found',
//           payload: { id },
//           filehost: localUUID // optional: who responded
//         }
//       },
//       type: 'pcs',
//       streamID: requester   // send only to the requester
//     }, '*');
//     return;
//   }

//   // File exists â€” start streaming to requester only
//   const file = meta.file;
//   const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);
//   console.log(`Streaming file ${meta.name} (${id}) to ${requester} in ${totalChunks} chunks`);

//   // initialize outgoingFiles state (keep existing structure)
//   outgoingFiles[id] = outgoingFiles[id] || {
//     acks: {},
//     resolvers: {},
//     retries: {},
//     totalChunks,
//     meta,
//     target: requester,
//     paused: false
//   };

//   // kick off the actual chunk sender (example function name sendFileChunksToPeer)
//   // make sure your chunk sender uses streamID: requester and the same sendData envelope
//   sendFileChunksToPeer(id, requester).catch(err => {
//     console.error('Error streaming file to', requester, err);
//     // optionally notify requester of failure
//     iframe.contentWindow.postMessage({
//       sendData: {
//         [APP_NS]: {
//           dataType: 'file-send-failed',
//           payload: { id, reason: err?.message || 'send-error' },
//           filehost: localUUID
//         }
//       },
//       type: 'pcs',
//       streamID: requester
//     }, '*');
//   });
// }

//   // async function respondToFileRequest(id, filehost, requester) {
//   //   //const { id, filehost, requester } = payload;
//   //   //console.log("requested files to send", id, filehost, requester)
//   //   const meta = files[id];
//   //   if (!meta || !meta.file) {
//   //     // tell requester file not found
//   //     postToIframe({
//   //       type: 'pcs',
//   //       target: requester,
//   //       sendData: { [APP_NS]: { type: 'file-not-found', payload: { id }, target: requester } },

//   //     });
//   //     log('Requested file not found locally:', id);
//   //     return;
//   //   }

//   //   const file = meta.file;
//   //   const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);
//   //   log(`Streaming file ${meta.name} to ${requester} in ${totalChunks} chunks`);

//   //   // initialize outgoing state
//   //   outgoingFiles[id] = outgoingFiles[id] || {
//   //     acks: {},           // index -> true if acked
//   //     resolvers: {},      // key -> resolve functions for ack waiting
//   //     retries: {},        // index -> retry count
//   //     totalChunks,
//   //     meta,
//   //     target: requester,
//   //     paused: false
//   //   };

//   //   // send sequentially; you can also dispatch some in parallel for speed but ensure DataChannel isn't saturated
//   //   for (let i = 0; i < totalChunks; i++) {
//   //     if (!outgoingFiles[id] || outgoingFiles[id].paused) {
//   //       log(`Send paused or cancelled for ${id} at chunk ${i}`);
//   //       return;
//   //     }

//   //     const start = i * FILE_CHUNK_BYTES;
//   //     const end = Math.min(file.size, start + FILE_CHUNK_BYTES);
//   //     const blobSlice = file.slice(start, end);

//   //     let buffer;
//   //     try {
//   //       buffer = await readBlobAsArrayBuffer(blobSlice);
//   //     } catch (err) {
//   //       log('Error reading chunk', i, err);
//   //       postToIframe({
//   //         type: 'pcs',
//   //         target: requester,
//   //         sendData: { [APP_NS]: { type: 'file-transfer-error', payload: { id, message: err.message || 'chunk-read-error' }, target: requester } },
//   //         // type: 'pcs',
//   //         // target: requester
//   //       });
//   //       return;
//   //     }

//   //     try {
//   //       await sendChunkWithRetry(requester, id, i, totalChunks, buffer);
//   //     } catch (err) {
//   //       log(`Giving up on chunk ${i} for ${id}:`, err);
//   //       // inform receiver that the transfer failed (so it can request-missing / abort)
//   //       postToIframe({
//   //         type: 'pcs',
//   //         target: requester,
//   //         sendData: { [APP_NS]: { type: 'file-transfer-error', payload: { id, message: `chunk-failed-${i}` }, target: requester } },
//   //         // type: 'pcs',
//   //         // target: requester
//   //       });
//   //       return;
//   //     }

//   //     // small delay to avoid exhausting the datachannel
//   //     await sleep(CHUNK_SEND_DELAY);
//   //   }

//   //   // finalise
//   //   postToIframe({
//   //     sendData: { [APP_NS]: { type: 'file-transfer-complete', payload: { id, totalChunks, timestamp: Date.now() }, target: requester } },
//   //     type: 'pcs',
//   //     target: requester
//   //   });
//   //   log(`Finished streaming file ${meta.name} â†’ ${requester}`);
//   // }

//   // function sendChunkRaw(requester, id, index, total, arrayBuffer) {
//   //   // Use base64 fallback as before (structured clone transferables might be blocked)
//   //   const b64 = arrayBufferToBase64(arrayBuffer);
//   //   const msg = {
//   //     sendData: { [APP_NS]: { type: 'file-chunk', payload: { id, index, total, isBase64: true, data: b64, size: arrayBuffer.byteLength }, target: requester } },
//   //     type: 'pcs',
//   //     to: requester
//   //   };
//   //   postToIframe(msg);
//   // }

//   function waitForChunkAck(id, index, timeoutMs = CHUNK_ACK_TIMEOUT) {
//     const key = `${id}:${index}`;
//     return new Promise((resolve, reject) => {
//       // if already acked, resolve immediately
//       if (outgoingFiles[id] && outgoingFiles[id].acks && outgoingFiles[id].acks[index]) return resolve();

//       // create resolver
//       outgoingFiles[id] = outgoingFiles[id] || {};
//       outgoingFiles[id].resolvers = outgoingFiles[id].resolvers || {};
//       let called = false;
//       outgoingFiles[id].resolvers[key] = () => {
//         if (called) return;
//         called = true;
//         clearTimeout(timer);
//         delete outgoingFiles[id].resolvers[key];
//         resolve();
//       };

//       const timer = setTimeout(() => {
//         if (called) return;
//         called = true;
//         delete outgoingFiles[id].resolvers[key];
//         reject(new Error('ack-timeout'));
//       }, timeoutMs);
//     });
//   }

//   async function sendChunkWithRetry(targetUUID, id, index, total, arrayBuffer) {
//     outgoingFiles[id] = outgoingFiles[id] || { acks: {}, retries: {}, resolvers: {} };
//     const retries = outgoingFiles[id].retries;
//     retries[index] = retries[index] || 0;

//     while (retries[index] <= CHUNK_MAX_RETRIES) {
//       // if ack already received, break
//       if (outgoingFiles[id].acks && outgoingFiles[id].acks[index]) return;

//       // send
//       sendChunkRaw(targetUUID, id, index, total, arrayBuffer);
//       try {
//         await waitForChunkAck(id, index, CHUNK_ACK_TIMEOUT);
//         // ack received
//         outgoingFiles[id].acks[index] = true;
//         return;
//       } catch (err) {
//         // timeout -> retry
//         retries[index] = (retries[index] || 0) + 1;
//         log(`Retry ${retries[index]} for chunk ${index} of ${id}`);
//         if (retries[index] > CHUNK_MAX_RETRIES) break;
//         // short backoff
//         await sleep(200 + 200 * retries[index]);
//       }
//     }

//     throw new Error(`failed-to-get-ack-for-chunk-${index}`);
//   }

//   // Try to post buffer directly; fallback to base64 if structured clone fails.
//   async function sendChunkToPeer(targetUUID, id, index, total, arrayBuffer) {
//     const payload = { id, index, total, isBase64: false, size: arrayBuffer.byteLength };

//     const msg = {
//       sendData: { [APP_NS]: { type: "file-chunk", payload } },
//       type: "pcs",
//       to: targetUUID,
//       buffer: arrayBuffer // include for easier debug
//     };

//     try {
//       const b64 = arrayBufferToBase64(arrayBuffer);
//       postToIframe({
//         sendData: { [APP_NS]: { type: 'file-chunk', payload: { id, index, total, isBase64: true, data: b64 } } },
//         type: 'pcs',
//         to: targetUUID
//       });

//       //Pass arrayBuffer as transferable
//       //postToIframe(msg, [arrayBuffer]);
//     } catch (err) {
//       console.warn("Transferable send failed, falling back to base64", err);
//       const b64 = arrayBufferToBase64(arrayBuffer);
//       const fallbackMsg = {
//         sendData: {
//           [APP_NS]: {
//             type: "file-chunk",
//             payload: { ...payload, isBase64: true, data: b64 },
//           },
//         },
//         type: "pcs",
//         to: targetUUID,
//       };
//       postToIframe(fallbackMsg);
//     }
//   }

//   async function handleIncomingChunk(payload, rawEvent = null) {
//     const { id, index, total, isBase64, size, uploadedBy } = payload;

//     // --- ensure entry exists ---
//     let entry = incomingFiles[id];
//     if (!entry) {
//       entry = incomingFiles[id] = {
//         chunks: {},
//         totalChunks: total || 0,
//         receivedChunks: 0,
//         bytesReceived: 0,
//         uploadedBy: localUUID,
//         size: (size || total * CHUNK_SIZE || 0),
//         startedAt: Date.now(),
//         meta: {},
//       };
//     }

//     let buffer = null;
//     if (rawEvent?.data?.buffer instanceof ArrayBuffer) {
//       buffer = rawEvent.data.buffer;
//     } else if (isBase64 && payload.data) {
//       buffer = base64ToArrayBuffer(payload.data);
//     } else if (payload.buffer instanceof ArrayBuffer) {
//       buffer = payload.buffer;
//     } else if (payload.data instanceof ArrayBuffer) {
//       buffer = payload.data;
//     }

//     if (!buffer) {
//       console.warn("Failed to normalize buffer", payload);
//       return;
//     }

//     // Avoid duplicate storing if chunk already arrived
//     if (!entry.chunks[index]) {
//       entry.chunks[index] = buffer;
//       entry.receivedChunks = Object.keys(entry.chunks).length;
//       entry.bytesReceived += buffer.byteLength;
//     } else {
//       // duplicate chunk; ignore but still ack to sender
//       log(`Duplicate chunk ${index} for ${id} ignored`);
//     }

//     entry.totalChunks = total || entry.totalChunks;
//     createFileProgressUI(id, id);

//     // send ack back to the original uploader (if known)
//     //const uploader = payload.uploadedBy;
//     if (payload.uploadedBy != localUUID) {
//       postToIframe({
//         sendData: { [APP_NS]: { type: 'chunk-ack', payload: { id, index } } },
//         type: 'pcs',
//         to: payload.uploadedBy
//       });
//     }
//     //console.log("uploader:", payload.uploadedBy, "should not be", localUUID);

//     log(`Chunk ${index + 1}/${entry.totalChunks} received for ${id}`);

//     // compute stats for UI (you already have this in your code; keep it)
//     //   // --- calculate transfer stats ---
//     const percent = (index / total) * 100;
//     //   // --- update UI ---
//     updateFileProgressUI(id, percent);

//     // When the receiver thinks it's complete, call finalizeIncomingFile (which may request-missing)
//     if (entry.receivedChunks >= entry.totalChunks) {
//       finalizeIncomingFile(id);
//     }
//   }

//   async function finalizeIncomingFile(id) {
//     const entry = incomingFiles[id];
//     if (!entry) return;
//     const { chunks, totalChunks, meta } = entry;

//     const receivedCount = Object.keys(chunks).length;
//     if (totalChunks && receivedCount !== totalChunks) {
//       // determine missing indices
//       const missing = [];
//       for (let i = 0; i < totalChunks; i++) if (!chunks[i]) missing.push(i);

//       log(`Missing chunks for ${id}: ${missing.length}/${totalChunks}`, missing.slice(0, 20));
//       // Ask uploader to re-send missing chunks
//       const uploader = entry.meta.uploadedBy || null;
//       if (uploader && missing.length) {
//         postToIframe({
//           sendData: { [APP_NS]: { type: 'request-missing', payload: { id, missing } } },
//           type: 'pcs',
//           to: uploader
//         });
//         // Leave entry in incomingFiles â€” more chunks may come
//         return;
//       } else {
//         // no uploader info â€” fail
//         if (entry.reject) entry.reject(new Error('missing-chunks'));
//         return;
//       }
//     }

//     // assemble and download as before
//     const buffers = [];
//     for (let i = 0; i < totalChunks; i++) {
//       const c = chunks[i];
//       if (!c) {
//         log('Missing chunk at index', i);
//         if (entry.reject) entry.reject(new Error('missing-chunk-' + i));
//         return;
//       }
//       buffers.push(c instanceof ArrayBuffer ? c : (ArrayBuffer.isView(c) ? c.buffer : c));
//     }

//     const blob = new Blob(buffers);
//     const safeFolder = (meta.folderPath || '').replace(/\//g, ' - ');
//     const downloadName = `RPXL${safeFolder ? ' - ' + safeFolder : ''} - ${meta.name}`;
//     triggerBrowserDownload(blob, downloadName);
//     files[id] = files[id] || {};
//     files[id].status = 'downloaded';
//     log(`Saved file: ${downloadName}`);
//     if (entry.resolve) entry.resolve();
//     delete incomingFiles[id];
//     processDownloadQueue();
//   }

//   //show bytes nicely
//   function formatBytes(bytes) {
//     if (bytes < 1024) return `${bytes} B`;
//     if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
//     if (bytes < 1024 * 1024 * 1024) return `${(bytes / 1024 / 1024).toFixed(1)} MB`;
//     return `${(bytes / 1024 / 1024 / 1024).toFixed(1)} GB`;
//   }
//   // convert base64 -> ArrayBuffer
//   function base64ToArrayBuffer(base64) {
//     const binary_string = atob(base64);
//     const len = binary_string.length;
//     const bytes = new Uint8Array(len);
//     for (let i = 0; i < len; i++) bytes[i] = binary_string.charCodeAt(i);
//     return bytes.buffer;
//   }
//   function arrayBufferToBase64(buffer) {
//     let binary = '';
//     const bytes = new Uint8Array(buffer);
//     const chunkSize = 0x8000;
//     for (let i = 0; i < bytes.length; i += chunkSize) {
//       binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
//     }
//     return btoa(binary);
//   }

//   // read Blob slice as ArrayBuffer
//   function readBlobAsArrayBuffer(blob) {
//     return new Promise((res, rej) => {
//       const fr = new FileReader();
//       fr.onload = () => res(fr.result);
//       fr.onerror = rej;
//       fr.readAsArrayBuffer(blob);
//     });
//   }

//   // do actual browser download
//   function triggerBrowserDownload(blob, filename) {
//     const url = URL.createObjectURL(blob);
//     const a = document.createElement('a');
//     a.href = url;
//     a.download = filename;
//     document.body.appendChild(a);
//     a.click();
//     a.remove();
//     setTimeout(() => URL.revokeObjectURL(url), 60_000);
//   }

</script>