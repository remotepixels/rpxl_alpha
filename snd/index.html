<!doctype html>
<html lang="en">

<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="-1" />
  <meta name="msapplication-TileColor" content="#2e2e2e" />
  <meta name="description"
    content="Serverless web app that allows you transmit to a high quality stream to clients to view and comment on using WEBRTC and VDO.NINJA. Communication between clients is handled using low latency and very little bandwidth, dedicating as much bandwidth to the main strea, often the feed from an edit machine. Also, we think Capybara's are awesome though that might not be relevant in this case.">
  <meta name="keywords" content="Gui Felix, Advertising, Visual Effects, Motion Graphics, Remote Pixels, vdo.ninja" />
  <meta name="robots" content="index, follow" />
  <meta name="viewport"
    content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/icons/favicon.ico">
  <meta name="color-scheme" content="light dark">

  <title>File Share</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@200" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="mainWindow" class="mainWindow">
    <!--top menu bar-->
    <div id="topmenu" class="toolbar top hidden">
      <div class="toolset" id="shareTools">
        <button class="tool" id="shareBtn" aria-expanded="false" role="button"><span
            class="material-symbols-outlined">ios_share</span></button>
      </div>
      <div class="toolset" id="addTools">
        <button class="tool" id="addBtn" aria-expanded="false" role="button"><span
            class="material-symbols-outlined">playlist_add</span></button>
        <input id="filePicker" type="file" multiple webkitdirectory directory style="display:none">
      </div>
      <div class="toolspacer"></div>
      <div class="toolset">
        <!-- <span class="tool toolwider">Status : <span id="senderStatus">Idle</span></span> -->
        <span class="tool toolwider">Peers : <span id="peersList">(0)</span></span>
      </div>
      <div class="toolspacer"></div>
      <div class="toolset">
        <button class="tool toolmoresettings" id="logBtn" aria-expanded="false" role="button"><span
            class="material-symbols-outlined">terminal</span></button>
      </div>
   </div>

    <div class="logAndFiles">
      <pre class="log hidden" id="log"></pre>
      <div id="subToolBar" class="subtoolbar hidden">
        <span id="transferSpeed">Download: 0 B/s| Upload: 0 B/s </span>
        <span class="toolspacer"></span>
        <span id="filterControls">Show &nbsp;&nbsp;&nbsp;</span>
        <span class="subToolSet">
          <button id="filterAll" class="active subTool">All</button><button id="filterLocal"
            class="subTool">Local</button><button id="filterRemote" class="subTool">Remote</button>
        </span>
        <span class="toolspacer"></span>
        <span id="sortControls">Sort by &nbsp;&nbsp;&nbsp;</span>
        <span class="subToolSet">
          <button id="sortByTime" class="active subTool">Latest</button><button id="sortByName"
            class="subTool">Name</button>
        </span>
      </div>

      <div class="file-list" id="fileList">
        <div id="loadingMessage" class="hidden">Loading files...</div>
      </div>
      <div class="copyCredit"><a href="https://vdo.ninja" target="_blank">Powered by vdo.ninja</a></div>
    </div>
  </div>

  <div id="container" class="" style="display:none; position:fixed; width:100%; height:200px; bottom:0px;z-index:12">
  </div>

  <div class="drop" id="dropArea">
    <div class="material-symbols-outlined largeIcon">drive_folder_upload</div>
    <div>
      <h1>Drag & drop files or folders here</h1>
      <h2>(or click to pick)</h2>
    </div>
  </div>

  <!----- Copied links to clipboard ------>
  <div id="popupClipboard" class="toolpopup hidden">
    <div class="material-symbols-outlined largeIcon">assignment_turned_in</div>
    <div>
      <h1>Link copied to clipboard</h1>
    </div>
  </div>
</body>

</html>

<script lang="javascript">
  // Namespace used in messages sent through VDO.Ninja
  const APP_NS = 'SNDRPXL';
  //globals
  let iframe = null;
  let connectedPeers = {}; // map streamID -> label
  let roomName = '';
  const files = {}; // id -> {file, name, size, chunks:[], progress}
  let folderMap = {}; // keeps track of folder DOM nodes
  let folderState = {}; // path → true/false
  let currentSort = 'latest'; // default sort method
  let currentFilter = 'all'; // values: 'all' | 'local' | 'remote'
  let localUUID = randomID(20);
  let firstInteraction = true;

  const dropArea = document.getElementById('dropArea');
  const fileList = document.getElementById('fileList');
  const logEl = document.getElementById('log');
  const peersList = document.getElementById('peersList');
  const senderStatus = document.getElementById('senderStatus');
  const shareBtn = document.getElementById('shareBtn');
  const addBtn = document.getElementById('addBtn');
  const filePicker = document.getElementById('filePicker');
  const logBtn = document.getElementById('logBtn');
  const popupClipboard = document.getElementById('popupClipboard');
  const loadingEl = document.getElementById('loadingMessage');

  const devURL = window.location.origin;
  const debouncedRerender = debounce(rerenderFileTree, 100);//slow sorting index

  //GENERATE RANDOM SID
  function randomID(len = 20) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    return Array.from(arr, n => chars[n % chars.length]).join('');
  }

  //LOG WINDOW
  function log(...args) {
    console.log(...args);
    logEl.textContent += args.join(' ') + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  log('Local Browser UUID : ', localUUID);
  checkSessionURL();  //autoconnect if session ID in URL

  //CHECK IF THERE IS A CORRECT SID IN THE URL AND AUTOCONNECT
  function checkSessionURL() {
    const queryURL = window.location.search.slice(1);
    //let decodeURL;
    const params = new URLSearchParams(queryURL);
    if (params.has('SID')) {
      const SID = params.get('SID');
      roomName = encodeURIComponent(SID);
      if (!roomName || roomName.length !== 20) {
        //console.log('INCORRECTLY FORMATED SESSION ID');
        return;
      } else {
        console.log('SESSION ID FOUND IN URL:', roomName);
        createIframe(roomName)
        document.getElementById('shareTools').style.display = "none";
        document.getElementById('dropArea').classList.add('hidden');
        document.getElementById('topmenu').classList.remove('hidden');
        document.getElementById('subToolBar').classList.remove('hidden');
        //document.getElementById('file-list').classList.remove('hidden');
        return;
      }
    } else {
      var length = 20;
      roomName = randomID(20);
      createIframe(roomName);
    }
  }

  //CREATE VDONINJA IFRAME 
  function createIframe(room) {
    if (iframe) iframe.remove();
    const container = document.getElementById('container');
    iframe = document.createElement('iframe');
    iframe.allow = 'camera;microphone;fullscreen;display-capture;autoplay;';
    iframe.src = `https://alpha.rpxl.app/vdo/?director&room=${room}&push=${localUUID}&dataonly`;
    iframe.style.width = '100%';
    iframe.style.height = '200px';
    container.appendChild(iframe);
    log('Joined room :', room);
  }

  //SETUP CROSS BROWSER EVENT LISTENER
  var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
  var eventer = window[eventMethod];
  var messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";

  //EVENT LISTENER FOR MESSAGES FROM VDONINJA IFRAME
  eventer(messageEvent, function (e) {
    if (e.source !== iframe.contentWindow) return;

    //CONNECTION EVENTS
    if ("action" in e.data) {
      handleAction(e.data);  // delegate all connection/peer actions
    }

    //FILE AND DATA EVENT HANDLING
    if (e.data.dataReceived && e.data.dataReceived[APP_NS]) {
      //console.log("<------- INCOMING:", e.data.dataReceived);
      const msg = e.data.dataReceived[APP_NS];
      const dt = msg.dataType;
      const payload = msg.payload;
      if (!msg && !dt) return;

      //log incoming and outgoing messages for debug
      console.log("Datatype:", dt, "Payload:", payload);

      switch (msg.dataType) {
        //file and directory listing and removal
        case 'file-announce': {
          //Ignore files that were uploaded by yourself
          if (payload.uploadedBy === localUUID) {
            console.log(`Ignoring file ${payload.name} (uploaded by self)`);
            break;
          }
          //Optionally ignore duplicates if already have this file
          if (files[payload.id]) {
            console.log(`Ignoring file ${payload.name} (already listed)`);
            break;
          }
          files[payload.id] = {
            id: payload.id,
            name: payload.name,
            size: payload.size,
            folderPath: payload.folderPath || '',
            timestamp: payload.timestamp,
            uploadedBy: payload.uploadedBy || null
          };
          debouncedRerender()
          log(`Received file meta : ${payload.folderPath} / ${payload.name} - from ${payload.uploadedBy}`);
          break;
        }
        case 'file-removed': {
          const id = payload.id;
          const file = files[id];
          if (file) {
            delete files[id];
            const el = document.querySelector(`.file-item[data-id="${id}"]`);
            removeElementWithFade(el);
            log(`File removed remotely: ${file.name}`);
            cleanupEmptyFolders(file.folderPath);
          }
          break;
        }
        case 'directory-removed': {
          const path = payload.path;
          log(`Directory removed remotely: ${path}`);
          // Remove files inside folder first
          for (const id of Object.keys(files)) {
            if (files[id].folderPath.startsWith(path)) {
              delete files[id];
              const el = document.querySelector(`.file-item[data-id="${id}"]`);
              removeElementWithFade(el);
            }
          }
          // Now remove the folder itself
          const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
          removeElementWithFade(folderDiv);
          delete folderMap[path];
          // Optional: cleanup any empty parent folders
          cleanupEmptyFolders(path);
          break;
        }
        case 'request-file': {
          console.log("file requested")
          respondToFileRequest(payload.id, payload.requester);
          break;
        }
        case 'file-chunk': {
          // payload delivered to receiver
          handleIncomingChunk(payload, msg);
          break;
        }
        case 'chunk-group-ack': {
          handleChunkGroupAck(payload);
          break;
        }
        case 'request-missing': {
          // payload: { id, missing: [idx...] }
          // If we're the sender and have the file, resend those indices
          if (outgoingFiles[payload.id]) {
            const of = outgoingFiles[payload.id];
            // resending requested indices sequentially
            (async () => {
              const file = of.file;
              for (const idx of payload.missing || []) {
                const start = idx * FILE_CHUNK_BYTES;
                const end = Math.min(file.size, start + FILE_CHUNK_BYTES);
                const slice = file.slice(start, end);
                try {
                  const buffer = await readBlobAsArrayBuffer(slice);
                  const chunkMsg = {
                    sendData: {
                      [APP_NS]: {
                        dataType: "file-chunk",
                        payload: {
                          id: payload.id,
                          index: idx,
                          totalChunks: of.totalChunks,
                          buffer: arrayBufferToBase64(buffer),
                          target: of.to,
                          from: localUUID
                        }
                      }
                    }
                  };
                  postToIframeTarget(chunkMsg, of.to);
                  await sleep(CHUNK_SEND_DELAY);
                } catch (err) {
                  console.error('Failed resend chunk', idx, err);
                }
              }
            })();
          }
          break;
        }
        case 'file-transfer-complete': {
          // receiver finalization is handled in finalizeIncomingFile when all chunks present
          console.log('file-transfer-complete', payload);
          break;
        }
        case 'file-not-found': {
          log('Peer reports file not found:', payload.id);
          break;
        }
        case 'file-transfer-error': {
          log('Peer transfer error:', payload.id, payload.message);
          break;
        }
        // keep your other handlers...
        default:
          console.warn('Unhandled dataType', dt, payload);
      }
    }
  }, false);

  //USER 'ACTION EVENTS' FOR USER CONNECTS AND DISCONNECTS 
  function handleAction(data) {
    if (!data.action) return;

    switch (data.action) {
      case 'guest-connected':
        connectedPeers[data.streamID] = data.value?.label || "Guest";
        console.log("Guest connected:", data.streamID);
        updatePeersUI();
        handleGuestJoin(data.streamID);
        break;

      case 'push-connection':
        if (data.value === false && data.streamID) {
          console.log("Guest disconnected:", data.streamID);
          delete connectedPeers[data.streamID];
          removePeerFiles(data.streamID);
          updatePeersUI();
        }
        break;

      case 'view-connection':
        if (data.value) {
          connectedPeers[data.streamID] = "Viewer";
          handleGuestJoin(data.streamID);
        } else {
          delete connectedPeers[data.streamID];
          removePeerFiles(data.streamID);
        }
        updatePeersUI();
        break;

      default:
        console.warn('Unhandled connection action', data.action);
    }
  }

  //when user connects send them the file list
  async function handleGuestJoin(guestUUID) {
    log('Guest connected :', guestUUID);
    loadingEl.classList.remove('hidden');
    // delay to ensure the peer connection is ready
    await sleep(500);
    const ids = Object.keys(files);

    if (ids.length === 0) {
      log('No files to send.');
      return;
    }
    log(`Auto-sending ${ids.length} files to new guest ${guestUUID}...`);

    for (const id of ids) {
      const meta = files[id];
      sendToPeer(guestUUID, "file-announce", meta);
    }
    // Optionally wait for all announcements to process
    await sleep(50 * ids.length); // small buffer for debounced rendering

    // Hide loading message once file list is rendered
    loadingEl.classList.add('hidden');
  }

  //updated the connected peers count
  function updatePeersUI() {
    const total = Object.keys(connectedPeers).length;
    let statusText = '';

    peersList.textContent = total === 0
      ? '(0)'
      : `(${total})`;
  }

  //REMOVE ANY FILES THE PEER HAS UPLOADED IF THEY DISCONNECT
  function removePeerFiles(peerUUID) {
    // Collect IDs of files uploaded by the disconnected peer
    const toRemove = Object.values(files)
      .filter(f => f.uploadedBy === peerUUID)
      .map(f => f.id);

    for (const id of toRemove) {
      const fileMeta = files[id];
      const folderPath = fileMeta.folderPath; // save for cleanup

      // Remove from files object
      delete files[id];

      // Remove from DOM
      const fileDiv = document.getElementById(`data-${id}`);
      if (fileDiv) fileDiv.remove();

      // Clean up empty folders up the tree
      cleanupEmptyFolders(folderPath);
    }
  }

  //check if mobile and remove the webkit directory option for file inputs
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  if (isMobile) {
    filePicker.removeAttribute('webkitdirectory'); // optional
  }


  //INTERFACE BUTTONS
  //share
  shareBtn.addEventListener('pointerdown', () => {
    navigator.clipboard.writeText(`${devURL}/snd/?SID=${roomName}`);
    popupClipboard.classList.remove("hidden");
    setTimeout(() => {
      popupClipboard.classList.add("hidden");
    }, 2000);
    console.log('Session link copied to clipboard');
  });
  //show log window
  logBtn.addEventListener('pointerdown', () => {
    document.getElementById('log').classList.toggle('hidden');
  });
  //sort by name
  document.getElementById('sortByName').addEventListener('click', () => {
    currentSort = 'name';
    rerenderFileTree();
  });
  //sort by latest
  document.getElementById('sortByTime').addEventListener('click', () => {
    currentSort = 'latest';
    rerenderFileTree();
  });
  //show all files
  document.getElementById('filterAll').addEventListener('click', () => {
    currentFilter = 'all';
    setActiveFilterButton('filterAll');
    debouncedRerender();
  });
  //show only local
  document.getElementById('filterLocal').addEventListener('click', () => {
    currentFilter = 'local';
    setActiveFilterButton('filterLocal');
    debouncedRerender();
  });
  //show only remote
  document.getElementById('filterRemote').addEventListener('click', () => {
    currentFilter = 'remote';
    setActiveFilterButton('filterRemote');
    debouncedRerender();
  });
  //select button active
  function setActiveFilterButton(id) {
    document.querySelectorAll('#filterControls button').forEach(btn => {
      btn.classList.remove('active');
    });
    document.getElementById(id).classList.add('active');
  }

  //DRAG AND DROP AND FILE ADDING HANDLING
  addBtn.addEventListener("pointerdown", () => {
    filePicker.click();
  });

  filePicker.addEventListener("change", (event) => {
    const files = event.target.files;

    // If the user selects a FOLDER, files will contain all files inside
    // with webkitRelativePath set.
    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      if (file.webkitRelativePath && file.webkitRelativePath !== "") {
        //Folder was selected → preserve folder structure
        file.relativePath = file.webkitRelativePath;
      } else {
        //Single file selected
        file.relativePath = file.name;
      }
      if (!isHiddenFile(file)) addFile(file);

      firstInteraction = false;

      document.getElementById('dropArea').classList.add('hidden');
      document.getElementById('dropArea').style.pointerEvents = "none";

      document.getElementById('topmenu').classList.remove('hidden');
      document.getElementById('subToolBar').classList.remove('hidden');
    }
  });

  dropArea.addEventListener('pointerdown', () => {
    if (!firstInteraction) return;
    filePicker.click();
  });

  const dropOverlay = document.getElementById('dropArea');
  let dragCounter = 0; // helps handle nested dragenter/dragleave events

  window.addEventListener('dragenter', (e) => {
    e.preventDefault();
    dragCounter++;
    dropOverlay.classList.add('dragover');
  });

  window.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dragCounter--;
    if (dragCounter === 0) dropOverlay.classList.remove('dragover');
  });

  window.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  window.addEventListener('drop', (e) => {
    e.preventDefault();
    dragCounter = 0;
    dropOverlay.classList.remove('dragover');
  });

  dropArea.addEventListener('drop', async (e) => {
    const items = e.dataTransfer.items;
    if (!items) return handleFileList(e.dataTransfer.files);

    //hide dop area after 1st drop and show main interface
    document.getElementById('dropArea').classList.add('hidden');
    document.getElementById('topmenu').classList.remove('hidden');
    document.getElementById('subToolBar').classList.remove('hidden');

    // Use directory traversal when available
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
      if (entry && entry.isDirectory) {
        await readDirectory(entry);
      } else if (entry && entry.isFile) {
        entry.file(file => addFile(file));
      } else if (it.getAsFile) {
        addFile(it.getAsFile());
      }
    }
  });

  //FILTER HIDDEN (.) FILES AND DO NOT UPLOAD
  function isHiddenFile(pathOrFile) {
    let path = "";

    if (typeof pathOrFile === "string") {
      path = pathOrFile;
    } else if (pathOrFile.webkitRelativePath) {
      path = pathOrFile.webkitRelativePath;
    } else if (pathOrFile.relativePath) {
      path = pathOrFile.relativePath;
    } else {
      path = pathOrFile.name || "";
    }

    if (!path) return true;
    // Split into segments and check each one
    const parts = path.split('/');

    return parts.some(part => part.startsWith('.') && part.length > 1);
  }

  // IF A FOLDER IS DROPPED, RECURSIVELY TRAVERSE
  async function readDirectory(dirEntry, path = '') {
    const reader = dirEntry.createReader();
    const readEntries = () => new Promise((res, rej) => reader.readEntries(res, rej));
    let entries = await readEntries();
    while (entries.length) {
      for (const e of entries) {
        if (e.isDirectory && !e.name.startsWith('.')) {
          await readDirectory(e, path + dirEntry.name + '/');
        } else if (e.isFile) {
          e.file((file) => {
            file.relativePath =
              (path ? path + dirEntry.name + '/' : dirEntry.name + '/') + file.name;
            if (!isHiddenFile(file)) addFile(file);
          });
        }
      }
      entries = await readEntries();
    }
  }

  // Called when user drops files/folders
  function handleFileList(list) {
    for (let i = 0; i < list.length; i++) {
      const file = list[i];
      if (!isHiddenFile(file)) addFile(file);
      else log(`Skipping hidden file: ${file.name}`);
    }
  }

  //ADD FILES
  function addFile(file) {
    const id = generateId();
    const relativePath = file.relativePath || file.name;
    const pathParts = relativePath.split('/');
    const fileName = pathParts.pop();
    const folderPath = pathParts.join('/');

    files[id] = {
      id,
      name: fileName,
      size: file.size,
      folderPath,
      uploadedBy: localUUID,
      timestamp: Date.now(),
      file
    };

    // const debouncedRerender = debounce(rerenderFileTree, 50);
    debouncedRerender()
    //renderTreeItem(files[id]);
    log(`Added: ${relativePath} (${formatBytes(file.size)})`);

    // Notify peers
    sendFile(id);
  }

  //send file data when one is added or deleted
  function sendFile(id, targetStreamID = null) {
    const meta = files[id];
    if (!meta) return;

    if (targetStreamID) {
      sendToPeer(targetStreamID, "file-announce", meta);
    } else {
      sendBroadcast("file-announce", meta);
    }
  }


  //WRAP DATA AND POST TO IFRAME EITHER TO INDIVIDAUL OR ALL (BROADCAST)
  function sendToPeer(targetStreamID, dataType, payload = {}) {
    const msg = {
      sendData: {
        [APP_NS]: {
          dataType,
          payload
        }
      },
      type: "pcs",
      streamID: targetStreamID
    };

    console.log("OUTGOING to VDO.Ninja:", JSON.parse(JSON.stringify(msg)));

    postToIframe(msg);
  }

  function sendBroadcast(dataType, payload = {}) {
    postToIframe({
      sendData: {
        [APP_NS]: {
          dataType,
          payload
        }
      },
      type: "pcs"
    });
  }

  function postToIframe(message) {
    if (!iframe || !iframe.contentWindow) {
      console.warn("postToIframe(): iframe not ready", message);
      return;
    }

    try {
      iframe.contentWindow.postMessage(message, "*");
    } catch (err) {
      console.error("postToIframe() failed:", err, message);
    }
  }

  //SORT FILES BY LATET (DEFAULT) OR NAME
  //stops sort operation running to often
  function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), delay);
    };
  }

  //natural file sorting(file 10 comes after file2)
  function naturalCompare(a, b) {
    const ax = [];
    const bx = [];

    a.replace(/(\d+)|(\D+)/g, (_, $1, $2) => {
      ax.push([$1 || Infinity, $2 || ""]);
    });

    b.replace(/(\d+)|(\D+)/g, (_, $1, $2) => {
      bx.push([$1 || Infinity, $2 || ""]);
    });

    while (ax.length && bx.length) {
      const an = ax.shift();
      const bn = bx.shift();

      // Compare text
      const textCompare = an[1].localeCompare(bn[1]);
      if (textCompare !== 0) return textCompare;

      // Compare numbers
      const numA = parseInt(an[0], 10);
      const numB = parseInt(bn[0], 10);
      if (numA !== numB) return numA - numB;
    }

    return ax.length - bx.length;
  }

  //SORTS THE FILETREE BY DATE/NAME LOCAL/REMOTE OR ALL
  function rerenderFileTree() {
    const treeRoot = document.getElementById('fileList');

    //Save folder expand/collapse state
    folderState = {};
    for (const path in folderMap) {
      const folderDiv = folderMap[path]?.closest('.folder');
      if (!folderDiv) continue;
      const contents = folderDiv.querySelector('.folder-contents');
      folderState[path] = contents && contents.style.display !== 'none';
    }

    //Clear tree
    treeRoot.innerHTML = '';
    folderMap = {};

    //Sort
    const fileArray = Object.values(files);
    if (currentSort === 'name') {
      fileArray.sort((a, b) => a.name.localeCompare(b.name));
    } else {
      fileArray.sort((a, b) => b.timestamp - a.timestamp);
    }
    //Apply filter
    let filtered = fileArray;

    if (currentFilter === 'local') {
      filtered = filtered.filter(f => f.uploadedBy === localUUID);
    }
    else if (currentFilter === 'remote') {
      filtered = filtered.filter(f => f.uploadedBy !== localUUID);
    }


    //Rebuild
    for (const f of filtered) {
      renderTreeItem(f);
    }

    //Restore folder states
    for (const path in folderState) {
      const contents = folderMap[path];
      if (!contents) continue;

  contents.classList.add('open');
    }
  }

  //BUILDS THE ACTUAL FILE TREE
  //(for hosts add delete icon, for clients add a download icon)
  function renderTreeItem(f) {
    const isReceiver = f.uploadedBy !== localUUID; // true if file came from another peer

    const treeRoot = document.getElementById('fileList');
    const pathParts = f.folderPath ? f.folderPath.split('/') : [];
    let currentContainer = treeRoot;
    let currentPath = '';

    for (const part of pathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!folderMap[currentPath]) {
        const folderDiv = document.createElement('div');
        folderDiv.className = 'folder ' + (isReceiver ? 'remote' : 'local');

        folderDiv.dataset.path = currentPath;

        const iconType = isReceiver ? 'folder-download' : 'folder-delete';
        const iconLabel = isReceiver ? 'download' : 'delete';

        folderDiv.innerHTML = `
        <div class="folder-header" data-folder="${currentPath}">
          <span class="material-symbols-outlined folder-icon">folder</span>
          <strong class="folder-text">${escapeHtml(part)}</strong>
          <span class="material-symbols-outlined ${iconType}">${iconLabel}</span>
        </div>
        <div class="folder-contents"></div>
      `;

        currentContainer.appendChild(folderDiv);
        folderMap[currentPath] = folderDiv.querySelector('.folder-contents');

        // Expand/collapse folder
        folderDiv.querySelector('.folder-header').addEventListener('pointerdown', (e) => {
          if (e.target.classList.contains(iconType)) return; // skip toggle when clicking icon

          const contents = folderDiv.querySelector('.folder-contents');
          const isOpen = contents.classList.contains('open');

          if (isOpen) {
            // Closing animation
            contents.classList.remove('open');
            folderState[currentPath] = false;
          } else {
            // Opening animation
            contents.classList.add('open');
            folderState[currentPath] = true;
          }
        });

        // Folder action (download or delete)
        folderDiv.querySelector(`.${iconType}`).addEventListener('pointerdown', async (e) => {
          e.stopPropagation();
          const folderPath = e.target.closest('.folder-header').dataset.folder;

          if (isReceiver) {
            requestDownload(folderPath, true); // download folder
          } else {
            if (confirm(`Remove entire directory "${folderPath}" and all its files from share?`)) {
              await deleteDirectory(folderPath);
              sendDirectoryRemoved(folderPath); //notify peers
            }
          }
        });
      }

      currentContainer = folderMap[currentPath];
    }

    // Create file entry
    const fileDiv = document.createElement('div');
    fileDiv.className = 'file-item ' + (isReceiver ? 'remote' : 'local');

    fileDiv.id = `data-${f.id}`;
    fileDiv.dataset.id = f.id;
    fileDiv.style.display = 'flex';
    fileDiv.style.justifyContent = 'space-between';
    fileDiv.style.alignItems = 'center';
    fileDiv.style.padding = '2px 10px';

    const fileIconClass = isReceiver ? 'file-download' : 'file-delete';
    const fileIconLabel = isReceiver ? 'download' : 'delete';

    fileDiv.innerHTML = `
    <span class="file-name">${escapeHtml(f.name)}</span>
    <span class="file-size">${formatBytes(f.size)}</span>
    <span class="material-symbols-outlined ${fileIconClass}" id="${f.id}_icon">${fileIconLabel}</span>
  `;
    currentContainer.appendChild(fileDiv);

    // File action (download or delete)
    fileDiv.querySelector(`.${fileIconClass}`).addEventListener('pointerdown', async (e) => {
      e.stopPropagation();
      if (isReceiver) {
        requestDownload(f.id, false); // single file download
        //createFileProgressUI(f.id);
      } else {
        deleteFile(f.id);
      }
    });
  }

  //FILE AND FOLDER DELETES
  //animate when deleted
  function removeElementWithFade(el) {
    if (!el) return;

    // Trigger reflow so transition always runs
    el.offsetHeight;

    el.classList.add('fade-slide-out');

    el.addEventListener('transitionend', () => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, { once: true });
  }

  async function deleteDirectory(path) {
    if (!path) return;
    log(`Deleting directory: ${path}`);

    // Find all file IDs inside that folder (recursively)
    const toDelete = Object.keys(files).filter(id =>
      files[id].folderPath.startsWith(path)
    );

    // Delete contained files
    for (const id of toDelete) {
      const el = document.querySelector(`.file-item[data-id="${id}"]`);
      removeElementWithFade(el);
      //if (el) el.remove();
      await sendFileRemoved(id, path);
      delete files[id];
    }

    // Remove the folder DOM
    const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
    if (folderDiv) folderDiv.remove();

    // Remove from folderMap
    delete folderMap[path];

    //announce directory removal to peers
    await sendDirectoryRemoved(path);

    //clean any now-empty parents
    cleanupEmptyFolders(path);
  }

  async function sendDirectoryRemoved(path, targetUUID = null) {
    const peerKeys = Object.keys(connectedPeers);
    if (peerKeys.length === 0) {
      console.log("No connected guests");
      return;
    }

    sendBroadcast("directory-removed", { path });
    log(`Announced directory removal: ${path}`);
  }

  async function deleteFile(id) {
    const file = files[id];
    if (!file) return;

    const folderPath = file.folderPath || '';
    // Remove from files map and DOM
    delete files[id];
    const el = document.querySelector(`.file-item[data-id="${id}"]`);
    removeElementWithFade(el);
    //if (el) el.remove();

    log(`Deleted file : / ${folderPath} / ${file.name}`);

    // Clean up empty folders (locally)
    cleanupEmptyFolders(folderPath);
    // Send updated file list to peers
    await sendFileRemoved(id, folderPath);
  }

  async function sendFileRemoved(id, path) {
    const total = Object.keys(connectedPeers).length;
    if (total == 0) {
      console.log("no peers");
      return;
    }

    sendBroadcast("file-removed", { id });
    log(`Announced file removal`);
  }

  // Remove any empty parent folders (recursively up)
  function cleanupEmptyFolders(startPath = null) {
    // climb up the tree from there and clean each ancestor if empty.
    if (startPath) {
      let parts = startPath.split('/');
      while (parts.length > 0) {
        const currentPath = parts.join('/');
        const folder = document.querySelector(`.folder[data-path="${currentPath}"]`);
        if (!folder) {
          parts.pop();
          continue;
        }

        const contents = folder.querySelector('.folder-contents');
        if (!contents || contents.children.length === 0) {
          log(`Removing empty folder: ${currentPath}`);
          folder.remove();
          delete folderMap[currentPath];
        }

        parts.pop(); // move up one level
      }
      return;
    }

    // If no path specified, do a full cleanup sweep
    const folders = document.querySelectorAll('.folder');
    for (const folder of folders) {
      const contents = folder.querySelector('.folder-contents');
      if (!contents || contents.children.length === 0) {
        const path = folder.dataset.path;
        log(`Removing empty folder: / ${path}`);
        folder.remove();
        delete folderMap[path];
      }
    }
  }

  function createFileProgressUI(id) {
    const item = document.getElementById(`${id}_icon`);
    if (!item) return;

    // Wrap the progress UI
    item.innerHTML = `
    <div class="roundProgressBarBG">
      <div class="roundProgressBarFill" id="progress-bar-${id}"></div>
      <div class="roundProgressBarCenter">
        <div class="pause-btn" id="pause-btn-${id}">⏸</div>
      </div>
    </div>
  `;

    // Style the pause button (you can move to CSS if preferred)
    const pauseBtn = document.getElementById(`pause-btn-${id}`);
    pauseBtn.style.position = "absolute";
    pauseBtn.style.top = "50%";
    pauseBtn.style.left = "50%";
    pauseBtn.style.transform = "translate(-50%, -50%)";
    pauseBtn.style.cursor = "pointer";
    pauseBtn.style.fontSize = "0.8em";
    pauseBtn.style.userSelect = "none";

    // Add click handler
    pauseBtn.addEventListener("click", () => {
      if (pausedDownloads.has(id)) {
        pausedDownloads.delete(id);
        pauseBtn.textContent = "⏸";
        console.log(`Resumed download: ${id}`);
        processDownloadQueue(); // pick up any paused downloads
      } else {
        pausedDownloads.add(id);
        pauseBtn.textContent = "▶";
        console.log(`Paused download: ${id}`);
      }
    });

  }

  function updateFileProgressUI(id, percent) {
    const bar = document.getElementById(`progress-bar-${id}`);
    const pct = Math.max(0, Math.min(100, Number(percent) || 0));
    const deg = pct * 3.6; // 100% -> 360°
    bar.style.backgroundImage = `conic-gradient(dodgerblue ${deg}deg, light-dark(var(--color-light-white), var(--color-dark-grey)) ${deg}deg)`;
  }

  //CALCULATE AND SHOW SPEED OF DOWNLOAD / UPLOAD
  let bytesReceivedInInterval = 0;
  let bytesSentInInterval = 0;

  // Called whenever a chunk is received
  function onChunkReceived(chunkSize) {
    bytesReceivedInInterval += chunkSize;
  }

  // Called whenever a chunk is sent
  function onChunkSent(chunkSize) {
    bytesSentInInterval += chunkSize;
  }
  function formatSpeed(bytes) {
    if (bytes > 1e6) return (bytes / 1e6).toFixed(2) + " MB/s";
    if (bytes > 1e3) return (bytes / 1e3).toFixed(2) + " KB/s";
    return bytes + " B/s";
  }

  setInterval(() => {
    const downloadSpeed = formatSpeed(bytesReceivedInInterval * 2); // interval 500ms → scale to 1s
    const uploadSpeed = formatSpeed(bytesSentInInterval * 2);

    document.getElementById("transferSpeed").textContent =
      `Download: ${downloadSpeed} | Upload: ${uploadSpeed}`;

    // Reset counters
    bytesReceivedInInterval = 0;
    bytesSentInInterval = 0;
  }, 500);

  // UTILITY, CREATE FILE ID'S, NICE FORMAT SIZE AND REMOVE ANY FUNNY CHARACTERS
  // function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
  function generateId() { return Math.random().toString(36).slice(2, 10); }
  function formatBytes(a) { if (a === 0) return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const e = Math.floor(Math.log(a) / Math.log(1024)); return (a / Math.pow(1024, e)).toFixed(2) + ' ' + units[e]; }
  function escapeHtml(s) { return String(s).replace(/[&<>\"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" })[c]); }

  //  FILE TRANSFER ENGINE — CLEAN & UNIFIED
  //  Uses: sendToPeer(), sendBroadcast()
  const FILE_CHUNK_BYTES = 64 * 512;
  const GROUP_SIZE = 16;
  const ACK_TIMEOUT_MS = 2000;
  const MAX_CHUNK_RETRIES = 4;
  const CHUNK_SEND_DELAY = 4;

  const outgoingFiles = {};
  const incomingFiles = {};
  let activeTransfers = 0;
  const pausedDownloads = new Set(); // holds fileIDs of paused downloads

  const downloadQueue = [];        // holds pending fileIDs
  let activeFileDownloads = 0;     // how many are running
  const MAX_PARALLEL_DOWNLOADS = 12; // 

  // UTILITIES 
  function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.length; i += 0x8000) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + 0x8000));
    }
    return btoa(binary);
  }

  function base64ToArrayBuffer(base64) {
    const bin = atob(base64);
    const len = bin.length;
    const out = new Uint8Array(len);
    for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i);
    return out.buffer;
  }

  function readBlobAsArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsArrayBuffer(blob);
    });
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  // RECEIVER REQUESTS FILE
  function requestDownload(fileID, isFolder = false) {

    //FOLDER DOWNLOAD HANDLED FIRST
    if (isFolder) {
      const folderPath = fileID;  // fileID *is* a folder path here
      log(`Requesting folder download: ${folderPath}`);

      // Find all files whose folderPath starts with this folder
      const fileIDs = Object.keys(files).filter(id =>
        files[id].folderPath.startsWith(folderPath)
      );

      for (const id of fileIDs) {
        const meta = files[id];
        const hostStreamID = meta.uploadedBy;

        queueDownload(id, hostStreamID, true);
        createFileProgressUI(id);
      }
      return;
    }

    //SINGLE FILE DOWNLOAD
    const meta = files[fileID];
    if (!meta) return console.error("requestDownload: no such file");

    const hostStreamID = meta.uploadedBy;
    queueDownload(fileID, hostStreamID, false);
    createFileProgressUI(fileID);
  }

  function startFileDownload(fileID, hostStreamID, fromFolder) {
    // If paused, do not start yet
    if (pausedDownloads.has(fileID)) {
      downloadQueue.push({ fileID, hostStreamID, fromFolder });
      return;
    }

    activeFileDownloads++;

    const meta = files[fileID];
    if (!meta) {
      console.error("startFileDownload: missing file", fileID);
      activeFileDownloads--;
      return processDownloadQueue();
    }

    if (fromFolder) meta.fromFolderRequest = true;

    sendToPeer(hostStreamID, "request-file", {
      id: fileID,
      requester: localUUID,
      isFolder: fromFolder
    });

    log(`Starting download: ${meta.name}`);
  }

  // HOST RECEIVES REQUEST → starts sending
  async function respondToFileRequest(fileID, requesterStreamID) {
    const meta = files[fileID];
    const file = meta?.file;

    if (!file) {
      sendToPeer(requesterStreamID, "file-not-found", { id: fileID });
      return;
    }

    const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);

    outgoingFiles[fileID] = {
      id: fileID,
      file,
      meta,
      totalChunks,
      to: requesterStreamID,
      groupStatus: {}
    };

    activeTransfers++;

    try {
      await sendChunksToPeer(fileID, requesterStreamID);
    } catch (err) {
      sendToPeer(requesterStreamID, "file-transfer-error", {
        id: fileID,
        message: err.message || "transfer-failed"
      });
    }

    delete outgoingFiles[fileID];
    activeTransfers--;
  }

  // HOST → send chunks in groups
  async function sendChunksToPeer(fileID, targetStreamID) {
    const of = outgoingFiles[fileID];
    const file = of.file;
    const total = of.totalChunks;

    const groupCount = Math.ceil(total / GROUP_SIZE);

    // How many chunks to send in one burst before yielding
    const SEND_WINDOW = 6;  // you can tune this (4–8 is ideal)

    for (let group = 0; group < groupCount; group++) {
      let acknowledged = false;

      for (let attempt = 0; attempt <= MAX_CHUNK_RETRIES; attempt++) {
        const start = group * GROUP_SIZE;
        const end = Math.min(total, start + GROUP_SIZE);

        // PIPELINED BURST SENDER
        for (let idx = start; idx < end; idx++) {
          const s = idx * FILE_CHUNK_BYTES;
          const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
          const buf = await readBlobAsArrayBuffer(file.slice(s, e));

          onChunkSent(buf.byteLength); // <-- track sent bytes

          sendToPeer(targetStreamID, "file-chunk", {
            id: fileID,
            index: idx,
            totalChunks: total,
            buffer: arrayBufferToBase64(buf),
            target: targetStreamID,
            from: localUUID
          });

          // Don't block the event loop on every chunk
          // Yield occasionally to avoid datachannel congestion collapse
          if ((idx - start) % SEND_WINDOW === 0) {
            await new Promise(res => setTimeout(res, 0));
          }
        }

        // Wait for GROUP ACK
        acknowledged = await waitForGroupAck(fileID, group, targetStreamID);
        if (acknowledged) break;

        console.warn(`Retrying group ${group} (attempt ${attempt + 1})`);
      }

      // All retries failed → give up
      if (!acknowledged) {
        throw new Error(`Group ${group} failed`);
      }
    }

    // Final completion message
    sendToPeer(targetStreamID, "file-transfer-complete", {
      id: fileID,
      totalChunks: of.totalChunks
    });
  }

  //WAIT FOR GROUP ACK (Promise)
  const ackWaiters = {};  // key = `${id}:${group}` → resolve()

  function waitForGroupAck(id, group, fromStreamID) {
    return new Promise(resolve => {
      const key = `${id}:${group}`;
      ackWaiters[key] = resolve;

      setTimeout(() => {
        if (ackWaiters[key]) {
          delete ackWaiters[key];
          resolve(false);
        }
      }, ACK_TIMEOUT_MS);
    });
  }

  // RECEIVER HANDLES CHUNK
  async function handleIncomingChunk(payload) {
    const { id, index, totalChunks, buffer, target, from } = payload;

    if (target !== localUUID) return;

    const chunkSize = base64ToArrayBuffer(buffer).byteLength;
    onChunkReceived(chunkSize);  // <-- track received bytes

    if (!incomingFiles[id]) {
      incomingFiles[id] = {
        id,
        totalChunks,
        buffers: {},
        received: 0,
        sender: from
      };
    }

    const inf = incomingFiles[id];

    // Store chunk if first time
    if (!inf.buffers[index]) {
      inf.buffers[index] = buffer;
      inf.received++;

      const percent = (inf.received / inf.totalChunks) * 100;
      updateFileProgressUI(id, percent);
    }

    // Determine group
    const group = Math.floor(index / GROUP_SIZE);

    //handle group ACK
    if (isGroupComplete(inf, group)) {
      sendToPeer(from, "chunk-group-ack", {
        id,
        groupIndex: group,
        from: localUUID
      });
    }

    //check full file complete
    if (inf.received === inf.totalChunks) {
      updateFileProgressUI(id, 99);
      finalizeIncomingFile(id);
    }
  }

  function isGroupComplete(inf, groupIndex) {
    const start = groupIndex * GROUP_SIZE;
    const end = Math.min(inf.totalChunks, start + GROUP_SIZE);
    for (let i = start; i < end; i++) {
      if (!inf.buffers[i]) return false;
    }
    return true;
  }

  // RECEIVER SENDS GROUP ACK → notify sender
  function handleChunkGroupAck(payload) {
    const { id, groupIndex, from } = payload;
    const key = `${id}:${groupIndex}`;

    if (ackWaiters[key]) {
      ackWaiters[key](true);
      delete ackWaiters[key];
    }
  }

  //DOWNLOAD QUEUE
  function queueDownload(fileID, hostStreamID, fromFolder = false) {
    downloadQueue.push({ fileID, hostStreamID, fromFolder });
    processDownloadQueue();
  }

  function processDownloadQueue() {
    if (activeFileDownloads >= MAX_PARALLEL_DOWNLOADS) return;

    while (activeFileDownloads < MAX_PARALLEL_DOWNLOADS && downloadQueue.length > 0) {
      const { fileID, hostStreamID, fromFolder } = downloadQueue.shift();

      // Skip if paused
      if (pausedDownloads.has(fileID)) {
        // Put it back at the end of the queue so it can resume later
        downloadQueue.push({ fileID, hostStreamID, fromFolder });
        continue;
      }

      startFileDownload(fileID, hostStreamID, fromFolder);
    }
  }
  //pause and resume files
  function pauseDownload(fileID) {
    pausedDownloads.add(fileID);
    console.log(`Paused download: ${fileID}`);
  }

  function resumeDownload(fileID) {
    pausedDownloads.delete(fileID);
    console.log(`Resumed download: ${fileID}`);
    processDownloadQueue();
  }

  // RECEIVER FINALIZES FILE
  function finalizeIncomingFile(id) {
    const inf = incomingFiles[id];
    if (!inf) return;

    const buffers = [];
    for (let i = 0; i < inf.totalChunks; i++) {
      const b64 = inf.buffers[i];
      if (!b64) {
        requestMissingChunks(id, inf.sender);
        return;
      }
      buffers.push(base64ToArrayBuffer(b64));
    }

    const blob = new Blob(buffers);
    const meta = files[id];
    //const filename = meta?.name || `file-${id}`;
    let filename = meta?.name || `file-${id}`;

    //If part of a folder download → flatten name
    if (meta.fromFolderRequest) {
      if (meta.folderPath && meta.folderPath.trim() !== "") {
        const parts = meta.folderPath.split("/").filter(Boolean);
        filename = [...parts, meta.name].join(" - ");
      }
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);
    delete incomingFiles[id];
    delete meta.fromFolderRequest;

    log(`Completed download: ${filename}`);
    if (activeFileDownloads > 0) {
      activeFileDownloads--;
      processDownloadQueue();
    }
  }

  // REQUEST MISSING CHUNKS
  function requestMissingChunks(id, senderStreamID) {
    const inf = incomingFiles[id];
    if (!inf) return;

    const missing = [];
    for (let i = 0; i < inf.totalChunks; i++) {
      if (!inf.buffers[i]) missing.push(i);
    }

    sendToPeer(senderStreamID, "request-missing", {
      id,
      missing
    });
  }

  //SENDER HANDLES request-missing
  async function handleRequestMissing(payload) {
    const { id, missing } = payload;
    const of = outgoingFiles[id];
    if (!of) return;

    const file = of.file;

    for (const idx of missing) {
      const s = idx * FILE_CHUNK_BYTES;
      const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
      const buf = await readBlobAsArrayBuffer(file.slice(s, e));

      sendToPeer(of.to, "file-chunk", {
        id,
        index: idx,
        totalChunks: of.totalChunks,
        buffer: arrayBufferToBase64(buf),
        target: of.to,
        from: localUUID
      });
    }
  }
</script>