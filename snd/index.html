<!doctype html>
<html lang="en">

<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="-1" />
  <meta name="msapplication-TileColor" content="#2e2e2e" />
  <meta name="description"
    content="Serverless web app that allows you transmit to a high quality stream to clients to view and comment on using WEBRTC and VDO.NINJA. Communication between clients is handled using low latency and very little bandwidth, dedicating as much bandwidth to the main strea, often the feed from an edit machine. Also, we think Capybara's are awesome though that might not be relevant in this case.">
  <meta name="keywords" content="Gui Felix, Advertising, Visual Effects, Motion Graphics, Remote Pixels, vdo.ninja" />
  <meta name="robots" content="index, follow" />
  <meta name="viewport"
    content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/icons/favicon.ico">
  <meta name="color-scheme" content="light dark">

  <title>File Share</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
    rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@200" rel="stylesheet">
  <link rel="stylesheet" href="style.css">
</head>

<body>
  <div id="mainWindow" class="mainWindow">
    <!--top menu bar-->
    <div id="topmenu" class="toolbar top hidden">
      <div class="toolset" id="shareTools">
        <button class="tool" id="shareBtn" aria-expanded="false" role="button"><span
            class="material-symbols-outlined">ios_share</span></button>
      </div>
      <div class="toolset" id="addTools">
        <button class="tool" id="addBtn" aria-expanded="false" role="button"><span
            class="material-symbols-outlined">playlist_add</span></button>
        <input id="filePicker" type="file" multiple webkitdirectory directory style="display:none">
      </div>
      <div class="toolspacer"></div>
      <div class="toolset">
        <!-- <span class="tool toolwider">Status : <span id="senderStatus">Idle</span></span> -->
        <span class="tool toolwider">Peers : <span id="peersList">(0)</span></span>
      </div>
      <div class="toolspacer"></div>
      <div class="toolset">
        <button class="tool toolmoresettings" id="logBtn" aria-expanded="false" role="button"><span
            class="material-symbols-outlined">terminal</span></button>
      </div>
    </div>

    <div class="logAndFiles">
      <pre class="log hidden" id="log"></pre>

      <div id="subToolBar" class="subtoolbar hidden">
        <span id="transferSpeed">Download: 0 B/s| Upload: 0 B/s </span>
        <span class="toolspacer"></span>
        <span id="filterControls">Show &nbsp;&nbsp;&nbsp;</span>
        <span class="subToolSet filterSet">
          <button id="filterAll" class="active subTool">All</button><button id="filterLocal"
            class="subTool">Local</button><button id="filterRemote" class="subTool">Remote</button>
        </span>
        <span class="toolspacer"></span>
        <span id="sortControls">Sort by &nbsp;&nbsp;&nbsp;</span>
        <span class="subToolSet sortSet">
          <button id="sortByTime" class="active subTool">Latest</button><button id="sortByName"
            class="subTool">Name</button>
        </span>
      </div>

      <div class="file-list" id="fileList">
        <div id="loadingMessage" class="hidden">Loading files...</div>
      </div>
      <div class="copyCredit"><a href="https://vdo.ninja" target="_blank">Powered by vdo.ninja</a></div>
    </div>
  </div>

  <div id="container" class="" style="display:none; position:fixed; width:100%; height:200px; bottom:0px;z-index:12">
  </div>

  <div class="drop" id="dropArea">
    <div class="material-symbols-outlined largeIcon">drive_folder_upload</div>
    <div>
      <h1>Drag & drop files or folders here</h1>
      <h2>(or click to pick)</h2>
    </div>
  </div>

  <!----- Copied links to clipboard ------>
  <div id="popupClipboard" class="toolpopup hidden">
    <div class="material-symbols-outlined largeIcon">assignment_turned_in</div>
    <div>
      <h1>Link copied to clipboard</h1>
    </div>
  </div>
</body>

</html>

<script lang="javascript">
  // Namespace used in messages sent through VDO.Ninja
  const APP_NS = 'SNDRPXL';
  //globals
  let iframe = null;
  let connectedPeers = {}; // map streamID -> label
  let roomName = '';
  const files = {}; // id -> {file, name, size, chunks:[], progress}
  let folderMap = {}; // keeps track of folder DOM nodes
  let folderState = {}; // path → true/false
  let currentSort = 'latest'; // default sort method
  let currentFilter = 'all'; // values: 'all' | 'local' | 'remote'
  let localUUID = randomID(20);
  let firstInteraction = true;
  let downloadQueue = [];        // holds pending fileIDs

  const dropArea = document.getElementById('dropArea');
  const fileList = document.getElementById('fileList');
  const logEl = document.getElementById('log');
  const peersList = document.getElementById('peersList');
  const senderStatus = document.getElementById('senderStatus');
  const shareBtn = document.getElementById('shareBtn');
  const addBtn = document.getElementById('addBtn');
  const filePicker = document.getElementById('filePicker');
  const logBtn = document.getElementById('logBtn');
  const popupClipboard = document.getElementById('popupClipboard');
  const loadingEl = document.getElementById('loadingMessage');

  const devURL = window.location.origin;
  const debouncedRerender = debounce(rerenderFileTree, 100);//slow sorting index

  //GENERATE RANDOM SID
  function randomID(len = 20) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    return Array.from(arr, n => chars[n % chars.length]).join('');
  }

  //LOG WINDOW
  function log(...args) {
    console.log(...args);
    logEl.textContent += args.join(' ') + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  log('Local Browser UUID : ', localUUID);
  checkSessionURL();  //autoconnect if session ID in URL

  //CHECK IF THERE IS A CORRECT SID IN THE URL AND AUTOCONNECT
  function checkSessionURL() {
    const queryURL = window.location.search.slice(1);
    //let decodeURL;
    const params = new URLSearchParams(queryURL);
    if (params.has('SID')) {
      const SID = params.get('SID');
      roomName = encodeURIComponent(SID);
      if (!roomName || roomName.length !== 20) {
        //console.log('INCORRECTLY FORMATED SESSION ID');
        return;
      } else {
        console.log('SESSION ID FOUND IN URL:', roomName);
        createIframe(roomName)
        document.getElementById('shareTools').style.display = "none";
        document.getElementById('dropArea').classList.add('hidden');
        document.getElementById('topmenu').classList.remove('hidden');
        document.getElementById('subToolBar').classList.remove('hidden');
        //document.getElementById('file-list').classList.remove('hidden');
        return;
      }
    } else {
      var length = 20;
      roomName = randomID(20);
      createIframe(roomName);
    }
  }

  //CREATE VDONINJA IFRAME 
  function createIframe(room) {
    if (iframe) iframe.remove();
    const container = document.getElementById('container');
    iframe = document.createElement('iframe');
    iframe.allow = 'camera;microphone;fullscreen;display-capture;autoplay;';
    iframe.src = `https://alpha.rpxl.app/vdo/?director&room=${room}&push=${localUUID}&datamode&totalbitrate=5000000`;
    iframe.style.width = '100%';
    iframe.style.height = '200px';
    container.appendChild(iframe);
    log('Joined room :', room);
  }

  //SETUP CROSS BROWSER EVENT LISTENER
  var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
  var eventer = window[eventMethod];
  var messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";

  //EVENT LISTENER FOR MESSAGES FROM VDONINJA IFRAME
  eventer(messageEvent, function (e) {
    if (e.source !== iframe.contentWindow) return;

    //CONNECTION EVENTS
    if ("action" in e.data) {
      handleAction(e.data);  // delegate all connection/peer actions
    }

    //FILE AND DATA EVENT HANDLING
    if (e.data.dataReceived && e.data.dataReceived[APP_NS]) {
      const msg = e.data.dataReceived[APP_NS];
      const dt = msg.dataType;
      const payload = msg.payload;
      if (!msg && !dt) return;

      //log incoming and outgoing messages for debug
      //console.log("Datatype:", dt, "Payload:", payload);

      switch (msg.dataType) {
        //file and directory listing and removal
        case 'file-announce': {
          //Ignore files that were uploaded by yourself
          if (payload.uploadedBy === localUUID) {
            //console.log(`Ignoring file ${payload.name} (uploaded by self)`);
            break;
          }
          //Optionally ignore duplicates if already have this file
          if (files[payload.id]) {
            //console.log(`Ignoring file ${payload.name} (already listed)`);
            break;
          }
          files[payload.id] = {
            id: payload.id,
            name: payload.name,
            size: payload.size,
            folderPath: payload.folderPath || '',
            timestamp: payload.timestamp,
            uploadedBy: payload.uploadedBy || null
          };
          debouncedRerender()
          log(`Received file meta : ${payload.folderPath} / ${payload.name} - from ${payload.uploadedBy}`);
          break;
        }
        case 'file-removed': {
          const id = payload.id;
          const file = files[id];
          if (file) {
            delete files[id];
            const el = document.querySelector(`.file-item[data-id="${id}"]`);
            removeElementWithFade(el);
            log(`File removed remotely: ${file.name}`);
            cleanupEmptyFolders(file.folderPath);
          }
          break;
        }
        case 'directory-removed': {
          const path = payload.path;
          log(`Directory removed remotely: ${path}`);
          // Remove files inside folder first
          for (const id of Object.keys(files)) {
            if (files[id].folderPath.startsWith(path)) {
              delete files[id];
              const el = document.querySelector(`.file-item[data-id="${id}"]`);
              removeElementWithFade(el);
            }
          }
          // Now remove the folder itself
          const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
          removeElementWithFade(folderDiv);
          delete folderMap[path];
          // Optional: cleanup any empty parent folders
          cleanupEmptyFolders(path);
          break;
        }
        case 'request-file': {
          log(`file requested: ${payload.folderPath} / ${payload.name} -> ${payload.requester}`)
          respondToFileRequest(payload.id, payload.requester);
          break;
        }
        case 'file-chunk': {
          // payload delivered to receiver
          handleIncomingChunk(payload, msg);
          break;
        }
        case 'chunk-group-ack': {
          handleChunkGroupAck(payload);
          break;
        }
        case 'request-missing': {
          // If we're the sender and have the file, resend those indices
          if (outgoingFiles[payload.id]) {
            const of = outgoingFiles[payload.id];
            // resending requested indices sequentially
            (async () => {
              const file = of.file;
              for (const idx of payload.missing || []) {
                const start = idx * FILE_CHUNK_BYTES;
                const end = Math.min(file.size, start + FILE_CHUNK_BYTES);
                const slice = file.slice(start, end);
                try {
                  const buffer = await readBlobAsArrayBuffer(slice);
                  const chunkMsg = {
                    sendData: {
                      [APP_NS]: {
                        dataType: "file-chunk",
                        payload: {
                          id: payload.id,
                          index: idx,
                          totalChunks: of.totalChunks,
                          buffer: arrayBufferToBase64(buffer),
                          target: of.to,
                          from: localUUID
                        }
                      }
                    }
                  };
                  postToIframeTarget(chunkMsg, of.to);
                  await sleep(CHUNK_SEND_DELAY);
                } catch (err) {
                  console.error('Failed resend chunk', idx, err);
                }
              }
            })();
          }
          break;
        }
        case 'file-transfer-complete': {
          // receiver finalization is handled in finalizeIncomingFile when all chunks present
          log('file transfer complete', payload.name);
          break;
        }
        case 'file-not-found': {
          log('Peer reports file not found:', payload.id);
          break;
        }
        case 'file-transfer-error': {
          log('Peer transfer error:', payload.id, payload.message);
          break;
        }
        case "stop-download": {
          const id = payload.id;
          console.log("Sender: Stop requested for file:", id, payload.name);
          pausedUploads[id] = "stop"; // mark special state
          break;
        }
        default:
          console.warn('Unhandled dataType', dt, payload);
      }
    }
  }, false);

  //USER 'ACTION EVENTS' FOR USER CONNECTS AND DISCONNECTS 
  function handleAction(data) {
    if (!data.action) return;
    switch (data.action) {
      case 'guest-connected':
        connectedPeers[data.streamID] = data.value?.label || "Guest";
        log("Guest connected:", data.streamID);
        updatePeersUI();
        handleGuestJoin(data.streamID);
        break;
      case 'push-connection':
        if (data.value === false && data.streamID) {
          log("Guest disconnected:", data.streamID);
          delete connectedPeers[data.streamID];
          removePeerFiles(data.streamID);
          updatePeersUI();
        }
        break;
      case 'view-connection':
        if (data.value) {
          connectedPeers[data.streamID] = "Viewer";
          handleGuestJoin(data.streamID);
        } else {
          delete connectedPeers[data.streamID];
          removePeerFiles(data.streamID);
        }
        updatePeersUI();
        break;
      default:
      //don't log other messages from vdo.ninja (viewstats etc.)
      //keeps log window cleaner, because otherwise f'n hell
      //console.warn('Unhandled connection action', data.action);
    }
  }

  //SEND FILE LIST TO USER WHEN THEY CONNECT (AFTER. SHORT DELAY)
  async function handleGuestJoin(guestUUID) {
    loadingEl.classList.remove('hidden');
    // delay to ensure the peer connection is ready
    await sleep(500);
    const ids = Object.keys(files);

    if (ids.length === 0) {
      log('No files to send.');
      return;
    }
    log(`Auto-sending ${ids.length} files to new guest ${guestUUID}...`);

    for (const id of ids) {
      const meta = files[id];
      sendToPeer(guestUUID, "file-announce", meta);
    }
    // Optionally wait for all announcements to process
    await sleep(50 * ids.length); // small buffer for debounced rendering
    // Hide loading message once file list is rendered
    loadingEl.classList.add('hidden');
  }

  //UPDATE THE CONNECTED PEERS COUNT IN UI
  function updatePeersUI() {
    const total = Object.keys(connectedPeers).length;
    let statusText = '';

    peersList.textContent = total === 0
      ? '(0)'
      : `(${total})`;
  }

  //REMOVE ANY FILES THE PEER HAS UPLOADED IF THEY DISCONNECT
  function removePeerFiles(peerUUID) {
    // Collect IDs of files uploaded by the disconnected peer
    const toRemove = Object.values(files)
      .filter(f => f.uploadedBy === peerUUID)
      .map(f => f.id);

    for (const id of toRemove) {
      const fileMeta = files[id];
      const folderPath = fileMeta.folderPath; // save for cleanup

      // Remove from files object
      delete files[id];

      // Remove from DOM
      const fileDiv = document.getElementById(`data-${id}`);
      if (fileDiv) fileDiv.remove();

      // Clean up empty folders up the tree
      cleanupEmptyFolders(folderPath);
    }
  }

  //check if mobile and remove the webkit directory option for file inputs
  //doesn't work???
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
  if (isMobile) {
    filePicker.removeAttribute('webkitdirectory'); // optional
  }

  //INTERFACE BUTTONS
  //share
  shareBtn.addEventListener('pointerdown', () => {
    navigator.clipboard.writeText(`${devURL}/snd/?SID=${roomName}`);
    popupClipboard.classList.remove("hidden");
    setTimeout(() => {
      popupClipboard.classList.add("hidden");
    }, 2000);
    //console.log('Session link copied to clipboard');
  });
  //show log window
  logBtn.addEventListener('pointerdown', () => {
    document.getElementById('log').classList.toggle('hidden');
  });
  //sets active filter button
  function setActiveButton(groupSelector, activeId) {
    document.querySelectorAll(groupSelector + ' .subTool').forEach(btn => {
      btn.classList.toggle('active', btn.id === activeId);
    });
  }
  // Filter - all
  document.getElementById('filterAll').addEventListener('click', () => {
    currentFilter = 'all';
    setActiveButton('.filterSet', 'filterAll');
    debouncedRerender();
  });
  // Filter - local
  document.getElementById('filterLocal').addEventListener('click', () => {
    currentFilter = 'local';
    setActiveButton('.filterSet', 'filterLocal');
    debouncedRerender();
  });
  // Filter - remote
  document.getElementById('filterRemote').addEventListener('click', () => {
    currentFilter = 'remote';
    setActiveButton('.filterSet', 'filterRemote');
    debouncedRerender();
  });
  // Sort - latest
  document.getElementById('sortByTime').addEventListener('click', () => {
    currentSort = 'latest';
    setActiveButton('.sortSet', 'sortByTime');
    rerenderFileTree();
  });
  // Sort - name
  document.getElementById('sortByName').addEventListener('click', () => {
    currentSort = 'name';
    setActiveButton('.sortSet', 'sortByName');
    rerenderFileTree();
  });

  //DRAG AND DROP AND FILE ADDING HANDLING
  addBtn.addEventListener("pointerdown", () => {
    filePicker.click();
  });

  filePicker.addEventListener("change", (event) => {
    const files = event.target.files;

    // If the user selects a FOLDER, files will contain all files inside
    // with webkitRelativePath set.
    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      if (file.webkitRelativePath && file.webkitRelativePath !== "") {
        //Folder was selected → preserve folder structure
        file.relativePath = file.webkitRelativePath;
      } else {
        //Single file selected
        file.relativePath = file.name;
      }
      if (!isHiddenFile(file)) addFile(file);

      firstInteraction = false;

      document.getElementById('dropArea').classList.add('hidden');
      document.getElementById('dropArea').style.pointerEvents = "none";

      document.getElementById('topmenu').classList.remove('hidden');
      document.getElementById('subToolBar').classList.remove('hidden');
    }
  });

  dropArea.addEventListener('pointerdown', () => {
    if (!firstInteraction) return;
    filePicker.click();
  });

  const dropOverlay = document.getElementById('dropArea');
  let dragCounter = 0; // helps handle nested dragenter/dragleave events

  window.addEventListener('dragenter', (e) => {
    e.preventDefault();
    dragCounter++;
    dropOverlay.classList.add('dragover');
  });

  window.addEventListener('dragleave', (e) => {
    e.preventDefault();
    dragCounter--;
    if (dragCounter === 0) dropOverlay.classList.remove('dragover');
  });

  window.addEventListener('dragover', (e) => {
    e.preventDefault();
  });

  window.addEventListener('drop', (e) => {
    e.preventDefault();
    dragCounter = 0;
    dropOverlay.classList.remove('dragover');
  });

  dropArea.addEventListener('drop', async (e) => {
    const items = e.dataTransfer.items;
    if (!items) return handleFileList(e.dataTransfer.files);

    //hide dop area after 1st drop and show main interface
    document.getElementById('dropArea').classList.add('hidden');
    document.getElementById('topmenu').classList.remove('hidden');
    document.getElementById('subToolBar').classList.remove('hidden');

    // Use directory traversal when available
    for (let i = 0; i < items.length; i++) {
      const it = items[i];
      const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
      if (entry && entry.isDirectory) {
        await readDirectory(entry);
      } else if (entry && entry.isFile) {
        entry.file(file => addFile(file));
      } else if (it.getAsFile) {
        addFile(it.getAsFile());
      }
    }
  });

  //FILTER HIDDEN (.) FILES AND DO NOT UPLOAD
  function isHiddenFile(pathOrFile) {
    let path = "";

    if (typeof pathOrFile === "string") {
      path = pathOrFile;
    } else if (pathOrFile.webkitRelativePath) {
      path = pathOrFile.webkitRelativePath;
    } else if (pathOrFile.relativePath) {
      path = pathOrFile.relativePath;
    } else {
      path = pathOrFile.name || "";
    }

    if (!path) return true;
    // Split into segments and check each one
    const parts = path.split('/');

    return parts.some(part => part.startsWith('.') && part.length > 1);
  }

  // IF A FOLDER IS DROPPED, RECURSIVELY TRAVERSE
  async function readDirectory(dirEntry, path = '') {
    const reader = dirEntry.createReader();
    const readEntries = () => new Promise((res, rej) => reader.readEntries(res, rej));
    let entries = await readEntries();
    while (entries.length) {
      for (const e of entries) {
        if (e.isDirectory && !e.name.startsWith('.')) {
          await readDirectory(e, path + dirEntry.name + '/');
        } else if (e.isFile) {
          e.file((file) => {
            file.relativePath =
              (path ? path + dirEntry.name + '/' : dirEntry.name + '/') + file.name;
            if (!isHiddenFile(file)) addFile(file);
          });
        }
      }
      entries = await readEntries();
    }
  }

  // Called when user drops files/folders
  function handleFileList(list) {
    for (let i = 0; i < list.length; i++) {
      const file = list[i];
      if (!isHiddenFile(file)) addFile(file);
      else log(`Skipping hidden file: ${file.name}`);
    }
  }

  //ADD FILES
  function addFile(file) {
    const id = generateId();
    const relativePath = file.relativePath || file.name;
    const pathParts = relativePath.split('/');
    const fileName = pathParts.pop();
    const folderPath = pathParts.join('/');

    files[id] = {
      id,
      name: fileName,
      size: file.size,
      folderPath,
      uploadedBy: localUUID,
      timestamp: Date.now(),
      file
    };

    // const debouncedRerender = debounce(rerenderFileTree, 50);
    debouncedRerender()
    log(`Added: ${relativePath} (${formatBytes(file.size)})`);

    // Notify peers
    sendFile(id);
  }

  //WRAPS FILE DATA AND PREPS TO SENDS TO EITHER SPECIFIC STREAMID OR TO ALL
  function sendFile(id, targetStreamID = null) {
    const meta = files[id];
    if (!meta) return;

    if (targetStreamID) {
      sendToPeer(targetStreamID, "file-announce", meta);
    } else {
      sendBroadcast("file-announce", meta);
    }
  }

  //WRAP DATA AND POST TO IFRAME EITHER TO INDIVIDAUL OR ALL (BROADCAST)
  //send to specific peer (file requests and data transfers)
  function sendToPeer(targetStreamID, dataType, payload = {}) {
    const msg = {
      sendData: {
        [APP_NS]: {
          dataType,
          payload
        }
      },
      type: "pcs",
      streamID: targetStreamID
    };

    postToIframe(msg);
  }
  //send to all peers (connects, disconnects, adding or removing files)
  function sendBroadcast(dataType, payload = {}) {
    postToIframe({
      sendData: {
        [APP_NS]: {
          dataType,
          payload
        }
      },
      type: "pcs"
    });
  }
  //send above messages to vdoninja iframe
  function postToIframe(message) {
    if (!iframe || !iframe.contentWindow) {
      console.warn("postToIframe(): iframe not ready", message);
      return;
    }

    try {
      iframe.contentWindow.postMessage(message, "*");
    } catch (err) {
      console.error("postToIframe() failed:", err, message);
    }
  }

  //SORT FILES BY LATET (DEFAULT) OR NAME
  //stops sort operation running to often
  function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), delay);
    };
  }

  //natural file sorting(file 10 comes after file 2)
  function naturalCompare(a, b) {
    const ax = [];
    const bx = [];

    a.replace(/(\d+)|(\D+)/g, (_, $1, $2) => {
      ax.push([$1 || Infinity, $2 || ""]);
    });

    b.replace(/(\d+)|(\D+)/g, (_, $1, $2) => {
      bx.push([$1 || Infinity, $2 || ""]);
    });

    while (ax.length && bx.length) {
      const an = ax.shift();
      const bn = bx.shift();

      // Compare text
      const textCompare = an[1].localeCompare(bn[1]);
      if (textCompare !== 0) return textCompare;

      // Compare numbers
      const numA = parseInt(an[0], 10);
      const numB = parseInt(bn[0], 10);
      if (numA !== numB) return numA - numB;
    }

    return ax.length - bx.length;
  }

  //SORTS THE FILETREE BY DATE/NAME LOCAL/REMOTE OR ALL
  function rerenderFileTree() {
    const treeRoot = document.getElementById('fileList');

    //Save folder expand/collapse state
    folderState = {};
    for (const path in folderMap) {
      const folderDiv = folderMap[path]?.closest('.folder');
      if (!folderDiv) continue;
      const contents = folderDiv.querySelector('.folder-contents');
      folderState[path] = contents && contents.style.display !== 'none';
    }

    //Clear tree
    treeRoot.innerHTML = '';
    folderMap = {};

    //Sort
    const fileArray = Object.values(files);
    if (currentSort === 'name') {
      fileArray.sort((a, b) => a.name.localeCompare(b.name));
    } else {
      fileArray.sort((a, b) => b.timestamp - a.timestamp);
    }
    //Apply filter
    let filtered = fileArray;

    if (currentFilter === 'local') {
      filtered = filtered.filter(f => f.uploadedBy === localUUID);
    }
    else if (currentFilter === 'remote') {
      filtered = filtered.filter(f => f.uploadedBy !== localUUID);
    }

    //Rebuild
    for (const f of filtered) {
      renderTreeItem(f);
    }

    //Restore folder states
    for (const path in folderState) {
      const contents = folderMap[path];
      if (!contents) continue;

      contents.classList.add('open');
    }
  }

  //BUILDS THE ACTUAL FILE TREE
  //(for hosts add delete icon, for clients add a download icon)
  function renderTreeItem(f) {
    const isReceiver = f.uploadedBy !== localUUID; // true if file came from another peer

    const treeRoot = document.getElementById('fileList');
    const pathParts = f.folderPath ? f.folderPath.split('/') : [];
    let currentContainer = treeRoot;
    let currentPath = '';

    for (const part of pathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!folderMap[currentPath]) {
        const folderDiv = document.createElement('div');
        folderDiv.className = 'folder ' + (isReceiver ? 'remote' : 'local');

        folderDiv.dataset.path = currentPath;

        const iconType = isReceiver ? 'folder-download' : 'folder-delete';
        const iconLabel = isReceiver ? 'download' : 'delete';

        folderDiv.innerHTML = `
        <div class="folder-header" data-folder="${currentPath}">
          <span class="material-symbols-outlined folder-icon">folder</span>
          <strong class="folder-text">${escapeHtml(part)}</strong>
          <span class="material-symbols-outlined ${iconType}">${iconLabel}</span>
        </div>
        <div class="folder-contents"></div>
      `;

        currentContainer.appendChild(folderDiv);
        folderMap[currentPath] = folderDiv.querySelector('.folder-contents');

        // Expand/collapse folder
        folderDiv.querySelector('.folder-header').addEventListener('pointerdown', (e) => {
          if (e.target.classList.contains(iconType)) return; // skip toggle when clicking icon

          const contents = folderDiv.querySelector('.folder-contents');
          const isOpen = contents.classList.contains('open');

          if (isOpen) {
            // Closing animation
            contents.classList.remove('open');
            folderState[currentPath] = false;
          } else {
            // Opening animation
            contents.classList.add('open');
            folderState[currentPath] = true;
          }
        });

        // Folder action (download or delete)
        folderDiv.querySelector(`.${iconType}`).addEventListener('pointerdown', async (e) => {
          e.stopPropagation();
          const folderPath = e.target.closest('.folder-header').dataset.folder;

          if (isReceiver) {
            requestDownload(folderPath, true); // download folder
          } else {
            if (confirm(`Remove entire directory "${folderPath}" and all its files from share?`)) {
              await deleteDirectory(folderPath);
              sendDirectoryRemoved(folderPath); //notify peers
            }
          }
        });
      }

      currentContainer = folderMap[currentPath];
    }

    // Create file entry (hidden id, name, size and icon)
    const fileDiv = document.createElement('div');
    fileDiv.className = 'file-item ' + (isReceiver ? 'remote' : 'local');

    fileDiv.id = `data-${f.id}`;
    fileDiv.dataset.id = f.id;
    fileDiv.style.display = 'flex';
    fileDiv.style.justifyContent = 'space-between';
    fileDiv.style.alignItems = 'center';
    fileDiv.style.padding = '2px 10px';

    const fileIconClass = isReceiver ? 'file-download' : 'file-delete';
    const fileIconLabel = isReceiver ? 'download' : 'delete';

    fileDiv.innerHTML = `
    <span class="file-name">${escapeHtml(f.name)}</span>
    <span class="file-size">${formatBytes(f.size)}</span>
    <span class="file-icon-container" id="icon-container_${f.id}">
      <span class="material-symbols-outlined ${fileIconClass}" id="${f.id}_icon">${fileIconLabel}</span>
    </span>
  `;
    currentContainer.appendChild(fileDiv);

    // File action (download or delete based on if it is local or remote)
    fileDiv.querySelector(`.${fileIconClass}`).addEventListener('pointerdown', async (e) => {
      e.stopPropagation();
      if (isReceiver) {
        requestDownload(f.id, false); // single file download
      } else {
        deleteFile(f.id);
      }
    });
  }

  //FILE AND FOLDER DELETES
  //animate when deleted
  function removeElementWithFade(el) {
    if (!el) return;

    // Trigger reflow so transition always runs
    el.offsetHeight;

    el.classList.add('fade-slide-out');

    el.addEventListener('transitionend', () => {
      if (el.parentNode) el.parentNode.removeChild(el);
    }, { once: true });
  }

  //REMOVE DIRECTORY(S)
  async function deleteDirectory(path) {
    if (!path) return;
    log(`Deleting directory: ${path}`);

    // Find all file IDs inside that folder (recursively)
    const toDelete = Object.keys(files).filter(id =>
      files[id].folderPath.startsWith(path)
    );

    // Delete contained files
    for (const id of toDelete) {
      const el = document.querySelector(`.file-item[data-id="${id}"]`);
      removeElementWithFade(el);
      //if (el) el.remove();
      await sendFileRemoved(id, path);
      delete files[id];
    }

    // Remove the folder DOM
    const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
    if (folderDiv) folderDiv.remove();

    // Remove from folderMap
    delete folderMap[path];
    //announce directory removal to peers
    await sendDirectoryRemoved(path);
    //clean any now-empty parents
    cleanupEmptyFolders(path);
  }

  //ANNOUNCE DIRECTORY REMOVAL TO ALL PEERS
  async function sendDirectoryRemoved(path, targetUUID = null) {
    const peerKeys = Object.keys(connectedPeers);
    if (peerKeys.length === 0) {
      console.log("No connected guests");
      return;
    }

    sendBroadcast("directory-removed", { path });
    log(`Announced directory removal: ${path}`);
  }

  //REMOVE FILE
  async function deleteFile(id) {
    const file = files[id];
    if (!file) return;

    const folderPath = file.folderPath || '';
    // Remove from files map and DOM
    delete files[id];
    const el = document.querySelector(`.file-item[data-id="${id}"]`);
    removeElementWithFade(el);

    log(`Deleted file : / ${folderPath} / ${file.name}`);
    // Clean up empty folders (locally)
    cleanupEmptyFolders(folderPath);
    // Send updated file list to peers
    await sendFileRemoved(id, folderPath);
  }

  //ANNOUNCE FILE REMOVAL TO ALL PEERS
  async function sendFileRemoved(id, path) {
    const total = Object.keys(connectedPeers).length;
    if (total == 0) {
      console.log("no peers");
      return;
    }

    sendBroadcast("file-removed", { id });
    log(`Announced file removal`);
  }

  //CLEANUP AND REMOVE ANY EMPTY FOLDERS
  function cleanupEmptyFolders(startPath = null) {
    // climb up the tree from there and clean each ancestor if empty.
    if (startPath) {
      let parts = startPath.split('/');
      while (parts.length > 0) {
        const currentPath = parts.join('/');
        const folder = document.querySelector(`.folder[data-path="${currentPath}"]`);
        if (!folder) {
          parts.pop();
          continue;
        }

        const contents = folder.querySelector('.folder-contents');
        if (!contents || contents.children.length === 0) {
          log(`Removing empty folder: ${currentPath}`);
          folder.remove();
          delete folderMap[currentPath];
        }

        parts.pop(); // move up one level
      }
      return;
    }

    // If no path specified, do a full cleanup sweep
    const folders = document.querySelectorAll('.folder');
    for (const folder of folders) {
      const contents = folder.querySelector('.folder-contents');
      if (!contents || contents.children.length === 0) {
        const path = folder.dataset.path;
        log(`Removing empty folder: / ${path}`);
        folder.remove();
        delete folderMap[path];
      }
    }
  }

  //FILE DOWNLOAD UI, CIRCLE, RESTORE BACK AND CALC DL SPEED PROGRESS BARS
  function createFileProgressUI(id) {
    const container = document.getElementById(`icon-container_${id}`);
    if (!container) return;


    // Clear previous content and insert progress UI
    container.innerHTML = `
    <div class="roundProgressBarBG">
      <div class="roundProgressBarFill" id="progress-bar-${id}"></div>
      <div class="roundProgressBarCenter">
        <div class="stop-btn" id="stop-btn-${id}">✕</div>
      </div>
    </div>
  `;

    const stopBtn = document.getElementById(`stop-btn-${id}`);
    if (!stopBtn) return;

    // Style stop button
    stopBtn.style.position = "absolute";
    stopBtn.style.top = "50%";
    stopBtn.style.left = "50%";
    stopBtn.style.transform = "translate(-50%, -50%)";
    stopBtn.style.cursor = "pointer";
    stopBtn.style.fontSize = "0.8em";
    stopBtn.style.userSelect = "none";
    stopBtn.style.opacity = "0.5";

    // Stop button handler
    stopBtn.addEventListener("pointerdown", () => {
      console.log(`Stopping download: ${id}`);

      // stop local
      pausedDownloads.delete(id);
      delete incomingFiles[id];

      // remove from queue
      downloadQueue = downloadQueue.filter(job => job.fileID !== id);

      // notify sender
      sendToPeer(files[id].uploadedBy, "stop-download", { id });

      // restore icon cleanly
      restoreDownloadIcon(id);
    });
  }

  function restoreDownloadIcon(id) {
    const container = document.getElementById(`icon-container_${id}`);
    if (!container) return;

    if (!container) return;

    // Restore original icon
    container.innerHTML = `
    <span class="material-symbols-outlined file-download" id="${id}_icon">download</span>
  `;

    const icon = document.getElementById(`${id}_icon`);
    if (!icon) return;

    // Reattach the normal download behavior
    icon.addEventListener("pointerdown", (e) => {
      e.stopPropagation();
      requestDownload(id, false);
      createFileProgressUI(id);
    });
  }

  function updateFileProgressUI(id, percent) {
    const bar = document.getElementById(`progress-bar-${id}`);
    if (!bar) return; // safely ignore if element removed
    if (pausedDownloads.has(id)) return;

    const pct = Math.max(0, Math.min(100, Number(percent) || 0));
    const deg = pct * 3.6; // 100% -> 360°
    bar.style.backgroundImage = `conic-gradient(dodgerblue ${deg}deg, light-dark(var(--color-light-white), var(--color-dark-grey)) ${deg}deg)`;
  }

  //CALCULATE AND SHOW SPEED OF DOWNLOAD / UPLOAD
  let bytesReceivedInInterval = 0;
  let bytesSentInInterval = 0;
  // Called whenever a chunk is received
  function onChunkReceived(chunkSize) {
    bytesReceivedInInterval += chunkSize;
  }

  // Called whenever a chunk is sent
  function onChunkSent(chunkSize) {
    bytesSentInInterval += chunkSize;
  }
  function formatSpeed(bytes) {
    if (bytes > 1e6) return (bytes / 1e6).toFixed(2) + " MB/s";
    if (bytes > 1e3) return (bytes / 1e3).toFixed(2) + " KB/s";
    return bytes + " B/s";
  }

  setInterval(() => {
    const downloadSpeed = formatSpeed(bytesReceivedInInterval * 2); // interval 500ms → scale to 1s
    const uploadSpeed = formatSpeed(bytesSentInInterval * 2);

    document.getElementById("transferSpeed").textContent = `Download: ${downloadSpeed} | Upload: ${uploadSpeed}`;
    // Reset counters
    bytesReceivedInInterval = 0;
    bytesSentInInterval = 0;
  }, 500);

  // UTILITY, CREATE FILE ID'S, NICE FORMAT SIZE AND REMOVE ANY FUNNY CHARACTERS
  function generateId() { return Math.random().toString(36).slice(2, 10); }
  function formatBytes(a) { if (a === 0) return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const e = Math.floor(Math.log(a) / Math.log(1024)); return (a / Math.pow(1024, e)).toFixed(2) + ' ' + units[e]; }
  function escapeHtml(s) { return String(s).replace(/[&<>\"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" })[c]); }

  //  FILE TRANSFER ENGINE
  const FILE_CHUNK_BYTES = 512 * 1024;
  const GROUP_SIZE = 16;
  const ACK_TIMEOUT_MS = 2500;
  const MAX_CHUNK_RETRIES = 4;
  const CHUNK_SEND_DELAY = 2;
  let activeFileDownloads = 0;     // how many are running

  const outgoingFiles = {};
  const incomingFiles = {};
  let activeTransfers = 0;
  const pausedDownloads = new Set(); // holds fileIDs of paused downloads
  const MAX_PARALLEL_DOWNLOADS = 6; // 
  const pausedUploads = {};  // sender-side pause flags


  // UTILITIES 
  function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.length; i += 0x8000) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + 0x8000));
    }
    return btoa(binary);
  }

  function base64ToArrayBuffer(base64) {
    const bin = atob(base64);
    const len = bin.length;
    const out = new Uint8Array(len);
    for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i);
    return out.buffer;
  }

  function readBlobAsArrayBuffer(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsArrayBuffer(blob);
    });
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  // RECEIVER REQUESTS FILE
  function requestDownload(fileID, isFolder = false) {

    //FOLDER DOWNLOAD HANDLED FIRST
    if (isFolder) {
      const folderPath = fileID;  // fileID *is* a folder path here
      log(`Requesting folder : ${folderPath}`);

      // Find all files whose folderPath starts with this folder
      const fileIDs = Object.keys(files).filter(id =>
        files[id].folderPath.startsWith(folderPath)
      );

      for (const id of fileIDs) {
        const meta = files[id];
        const hostStreamID = meta.uploadedBy;

        queueDownload(id, hostStreamID, true);
        createFileProgressUI(id);
      }
      return;
    }

    //SINGLE FILE DOWNLOAD
    const meta = files[fileID];
    if (!meta) return log("requestDownload: no such file");

    log(`Requesting file : ${fileID}`);
    const hostStreamID = meta.uploadedBy;
    queueDownload(fileID, hostStreamID, false);
    createFileProgressUI(fileID);
  }

  function startFileDownload(fileID, hostStreamID, fromFolder) {
    // If paused, do not start yet
    if (pausedDownloads.has(fileID)) {
      downloadQueue.push({ fileID, hostStreamID, fromFolder });
      return;
    }

    activeFileDownloads++;

    const meta = files[fileID];
    if (!meta) {
      console.error("startFileDownload: missing file", fileID);
      activeFileDownloads--;
      return processDownloadQueue();
    }

    if (fromFolder) meta.fromFolderRequest = true;

    sendToPeer(hostStreamID, "request-file", {
      id: fileID,
      requester: localUUID,
      isFolder: fromFolder
    });

    log(`Starting download: ${meta.name}`);
  }

  // HOST RECEIVES REQUEST → starts sending
  async function respondToFileRequest(fileID, requesterStreamID) {
    const meta = files[fileID];
    const file = meta?.file;

    if (!file) {
      sendToPeer(requesterStreamID, "file-not-found", { id: fileID });
      return;
    }

    const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);

    outgoingFiles[fileID] = {
      id: fileID,
      file,
      meta,
      totalChunks,
      to: requesterStreamID,
      groupStatus: {}
    };

    activeTransfers++;

    try {
      await sendChunksToPeer(fileID, requesterStreamID);
    } catch (err) {
      sendToPeer(requesterStreamID, "file-transfer-error", {
        id: fileID,
        message: err.message || "transfer-failed"
      });
    }

    delete outgoingFiles[fileID];
    activeTransfers--;
  }

  // HOST → send chunks in groups
  async function sendChunksToPeer(fileID, targetStreamID) {
    const of = outgoingFiles[fileID];
    const file = of.file;
    const total = of.totalChunks;

    const groupCount = Math.ceil(total / GROUP_SIZE);

    // How many chunks to send in one burst before yielding
    const SEND_WINDOW = 10  // you can tune this (10 default)

    for (let group = 0; group < groupCount; group++) {
      let acknowledged = false;

      for (let attempt = 0; attempt <= MAX_CHUNK_RETRIES; attempt++) {
        const start = group * GROUP_SIZE;
        const end = Math.min(total, start + GROUP_SIZE);

        while (pausedUploads[fileID]) {
          await sleep(200);
        }

        // PIPELINED BURST SENDER
        for (let idx = start; idx < end; idx++) {
          //abort if stopped
          if (pausedUploads[fileID] === "stop") {
            log("Upload aborted by user:", fileID);
            delete pausedUploads[fileID];
            return; // exit the entire upload function
          }

          const s = idx * FILE_CHUNK_BYTES;
          const e = Math.min(file.size, s + FILE_CHUNK_BYTES);

          while (pausedUploads[fileID]) {
            await sleep(200);
          }

          const buf = await file.slice(s, e).arrayBuffer();

          onChunkSent(buf.byteLength); // <-- track sent bytes

          sendToPeer(targetStreamID, "file-chunk", {
            id: fileID,
            index: idx,
            totalChunks: total,
            buffer: arrayBufferToBase64(buf),
            target: targetStreamID,
            from: localUUID
          });
        }

        await Promise.resolve();
        // Wait for GROUP ACK
        acknowledged = await waitForGroupAck(fileID, group, targetStreamID);
        if (acknowledged) break;

        console.warn(`Retrying group ${group} (attempt ${attempt + 1})`);
      }

      // All retries failed → give up
      if (!acknowledged) {
        throw new Error(`Group ${group} failed`);
      }
    }

    // Final completion message
    sendToPeer(targetStreamID, "file-transfer-complete", {
      id: fileID,
      totalChunks: of.totalChunks
    });
  }

  //WAIT FOR GROUP ACK (Promise)
  const ackWaiters = {};  // key = `${id}:${group}` → resolve()

  function waitForGroupAck(id, group, fromStreamID) {
    return new Promise(resolve => {
      const key = `${id}:${group}`;
      ackWaiters[key] = resolve;

      setTimeout(() => {
        if (ackWaiters[key]) {
          delete ackWaiters[key];
          resolve(false);
        }
      }, ACK_TIMEOUT_MS);
    });
  }

  // RECEIVER HANDLES CHUNK
  async function handleIncomingChunk(payload) {
    const { id, index, totalChunks, buffer, target, from } = payload;

    if (target !== localUUID) return;

    const chunkSize = base64ToArrayBuffer(buffer).byteLength;
    onChunkReceived(chunkSize);  // <-- track received bytes

    if (!incomingFiles[id]) {
      incomingFiles[id] = {
        id,
        totalChunks,
        buffers: {},
        received: 0,
        sender: from
      };
    }

    const inf = incomingFiles[id];

    // Store chunk if first time
    if (!inf.buffers[index]) {
      inf.buffers[index] = buffer;
      inf.received++;

      const percent = (inf.received / inf.totalChunks) * 100;
      //if (pausedDownloads.has(id)) return;
      updateFileProgressUI(id, percent);
    }

    // Determine group
    const group = Math.floor(index / GROUP_SIZE);

    //handle group ACK
    if (isGroupComplete(inf, group)) {
      sendToPeer(from, "chunk-group-ack", {
        id,
        groupIndex: group,
        from: localUUID
      });
    }

    //check full file complete
    if (inf.received === inf.totalChunks) {
      updateFileProgressUI(id, 99);
      finalizeIncomingFile(id);
    }
  }

  function isGroupComplete(inf, groupIndex) {
    const start = groupIndex * GROUP_SIZE;
    const end = Math.min(inf.totalChunks, start + GROUP_SIZE);
    for (let i = start; i < end; i++) {
      if (!inf.buffers[i]) return false;
    }
    return true;
  }

  // RECEIVER SENDS GROUP ACK → notify sender
  function handleChunkGroupAck(payload) {
    const { id, groupIndex, from } = payload;
    const key = `${id}:${groupIndex}`;

    if (ackWaiters[key]) {
      ackWaiters[key](true);
      delete ackWaiters[key];
    }
  }

  //DOWNLOAD QUEUE
  function queueDownload(fileID, hostStreamID, fromFolder = false) {
    downloadQueue.push({ fileID, hostStreamID, fromFolder });
    processDownloadQueue();
  }

  function processDownloadQueue() {
    if (activeFileDownloads >= MAX_PARALLEL_DOWNLOADS) return;

    while (activeFileDownloads < MAX_PARALLEL_DOWNLOADS && downloadQueue.length > 0) {
      const { fileID, hostStreamID, fromFolder } = downloadQueue.shift();

      //If paused: stop processing to avoid infinite loop
      if (pausedDownloads.has(fileID)) {
        downloadQueue.unshift({ fileID, hostStreamID, fromFolder });
        return; //prevent CPU lock
      }

      startFileDownload(fileID, hostStreamID, fromFolder);
    }
  }

  // RECEIVER FINALIZES FILE
  function finalizeIncomingFile(id) {
    const inf = incomingFiles[id];
    if (!inf) return;

    const buffers = [];
    for (let i = 0; i < inf.totalChunks; i++) {
      const b64 = inf.buffers[i];
      if (!b64) {
        requestMissingChunks(id, inf.sender);
        return;
      }
      buffers.push(base64ToArrayBuffer(b64));
    }

    const blob = new Blob(buffers);
    const meta = files[id];
    let filename = meta?.name || `file-${id}`;

    //If part of a folder download → flatten name
    if (meta.fromFolderRequest) {
      if (meta.folderPath && meta.folderPath.trim() !== "") {
        const parts = meta.folderPath.split("/").filter(Boolean);
        filename = [...parts, meta.name].join(" - ");
      }
    }

    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.click();

    URL.revokeObjectURL(url);
    delete incomingFiles[id];
    delete meta.fromFolderRequest;

    log(`Completed download: ${filename}`);
    if (activeFileDownloads > 0) {
      activeFileDownloads--;
      processDownloadQueue();
    }
  }

  // REQUEST MISSING CHUNKS
  function requestMissingChunks(id, senderStreamID) {
    const inf = incomingFiles[id];
    if (!inf) return;

    const missing = [];
    for (let i = 0; i < inf.totalChunks; i++) {
      if (!inf.buffers[i]) missing.push(i);
    }

    sendToPeer(senderStreamID, "request-missing", {
      id,
      missing
    });
  }

  //SENDER HANDLES request-missing
  async function handleRequestMissing(payload) {
    const { id, missing } = payload;
    const of = outgoingFiles[id];
    if (!of) return;

    const file = of.file;

    for (const idx of missing) {
      const s = idx * FILE_CHUNK_BYTES;
      const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
      const buf = await file.slice(s, e).arrayBuffer();

      sendToPeer(of.to, "file-chunk", {
        id,
        index: idx,
        totalChunks: of.totalChunks,
        buffer: arrayBufferToBase64(buf),
        target: of.to,
        from: localUUID
      });
    }
  }
</script>