<!doctype html>
<html lang="en">

<head>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="-1" />

	<meta name="msapplication-TileColor" content="#2e2e2e" />
	<meta name="description"
		content="Serverless web app that allows you transmit to a high quality stream to clients to view and comment on using WEBRTC and VDO.NINJA. Communication between clients is handled using low latency and very little bandwidth, dedicating as much bandwidth to the main strea, often the feed from an edit machine. Also, we think Capybara's are awesome though that might not be relevant in this case.">
	<meta name="keywords" content="Gui Felix, Advertising, Visual Effects, Motion Graphics, Remote Pixels, vdo.ninja" />
	<meta name="robots" content="index, follow" />
	<meta name="viewport"
		content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<meta name="color-scheme" content="light dark">

	<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
	<link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/icons/favicon.ico">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
		rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@200" rel="stylesheet">
	<link rel="stylesheet" href="style.css">

	<title>RPXL | SND</title>
</head>

<body>
	<div id="mainWindow" class="mainWindow">
		<div id="topmenu" class="toolbar top hidden">
			<div class="toolbar-section left">
				<div class="toolset" id="shareTools"><button class="tool" id="shareBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">ios_share</span></button></div>
				<div class="toolset" id="addTools"><button class="tool" id="addBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">playlist_add</span></button><input id="filePicker" type="file" multiple></div>
			</div>
			<div class="toolbar-section center">
				<div class="toolset">
					<span class="tool toolwider" id="waitingButton">Waiting : <span id="waitingList">(0)</span></span>
					<span class="tool toolwider" id="connectedButton" style="pointer-events: none;">Connected : <span id="peersList">(0)</span></span>
				</div>
			</div>
			<div class="toolbar-section right">
				<div class="toolset">
				<button class="tool" id="logBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">terminal</span></button>
				</div>
			</div>
		</div>
		<div class="logAndFiles">
			<pre class="log hidden" id="log"></pre>
			<div id="subToolBar" class="subtoolbar hidden">
				<div class="toolbar-section left">
					<span id="transferSpeed">Download: 0 B/s| Upload: 0 B/s </span>
				</div>
				<div class="toolbar-section center">
					<span id="filterControls">Show &nbsp;</span>
					<span class="subToolSet filterSet"><button id="filterAll" class="active subTool">All</button><button id="filterLocal" class="subTool">Local</button><button id="filterRemote" class="subTool">Remote</button></span>
				</div>
				<div class="toolbar-section right">
					<span id="sortControls">Sort by &nbsp;</span><span class="subToolSet sortSet"><button id="sortByTime" class="active subTool">Latest</button><button id="sortByName" class="subTool">Name</button></span>
				</div>
			</div>

			<div class="file-list" id="fileList">
				<div id="loadingMessage" class="hidden">Loading files...</div>
			</div>
			<div class="copyCredit">
				<a href="changelog.html" target="_new">Updated 2026-02-01 : See more</span></a>
			</div>
		</div>

		<div id="container"></div>

		<div class="drop" id="dropArea">
			<div id="joinShareDialog" onclick="event.stopPropagation()" style="margin: 0px; border: 2px solid var(--color-med-grey); border-radius:10px; background-color:light-dark(var(--color-light-bg), var(--color-dark-grey)); box-shadow: 0 0px 40px rgba(0, 0, 0, 0.25); cursor: default!important;;">
				<h2 style="height:20px; margin:10px; color:light-dark(var(--color-dark-bg), var(--color-light-bg));">Enter code to join a share</h2>
				<input type="text" class="scode" maxlenght="8" id="shareCodeInput" style="width:300px; margin: 0px 10px 5px 10px; padding:5px 0px 5px 10px; font-size: 30px; border-radius: 5px; color: light-dark(black, white);" placeholder="XXXX-XXXX">
				<div style="margin-bottom:10px;"><button id="joinButton" class="joinbutton blue wider" style="color:light-dark(var(--color-dark-bg), var(--color-light-bg));">Join</button></div>
			</div>
			<div>
				<span id="dragDropIcon" class="material-symbols-outlined largeIcon">drive_folder_upload</span>
				<h1 id="dragDropMessage">Or drag & drop files or folders to start sharing</h1>
				<h2 id="dragDropSubMessage"style="margin:0px; transform: translateY(-20px);">(click to pick)</h2>
				<p>&nbsp;</p>
			</div>
		</div>

		<div style="position:absolute; right:25px; top:25px;   z-index: 101;" id="helpIcon">
			<a href="help.html"><span style="position:absolute; top:10px; right:50px; font-size: 24px;">Help</span><span
					class="material-symbols-outlined" style="font-size: 48px;">help</span></a>
		</div>

		<!-- Share menu -->
   		<div class="popupBG hidden" id="popupBG"></div>
		<div id="popupClipboard" class="toolpopup hidden top left share ">
			<div class="padding">
				<h2><span class="linkCopied">Link copied to clipboard</span><br><span>(Paste in messaging app to send)</span></h2>
			</div>
			<hr>
			<div class="padding">
				<h2 style="margin:10px 0px 0px 0px; padding:0px;">Or scan QR code to connect</h2>
				<div id="qrcode"></div>
				<p></p>
			</div>
			<hr>
			<div class="padding">
				<h2 style="margin:10px 0px 0px 0px; padding:0px;">Alternatively, use share code</h2>
				<h5 id="scode" class="scode" style="margin:0px; padding:0px; border:0px;"></h5>
				<br>
			</div>
		</div>

		<!-- waiting room menu -->
		<div id="popupWaitingList" class="toolpopup top middleLeft hidden">
			<div id="waiting_uuid" class="waitingList">
			</div>
		</div>
</body>

</html>

<script src="/scripts/vdoninja-sdk.js"></script>
<script src="qrcode.js"></script>
<script lang="javascript">
	//GLOBALS
	let roomName = null;
	let firstInteraction = true;
	let wakeLock = null;

	const connectedPeers = new Set();
	const waitingPeers = new Map();

	const files = {}; // id -> {file, name, size, chunks:[], progress}
	const folderUUIDs = {};   // path → uuid
	let folderMap = {}; // keeps track of folder DOM nodes
	let folderState = {}; // path → true/false
	let currentSort = 'latest'; // default sort method
	let currentFilter = 'all'; // values: 'all' | 'local' | 'remote'
	let downloadQueue = [];        // holds pending fileIDs


	const dropArea = document.getElementById('dropArea');
	const fileList = document.getElementById('fileList');
	const logEl = document.getElementById('log');
	const waitingList = document.getElementById('waitingList');
	const peersList = document.getElementById('peersList');
	const shareBtn = document.getElementById('shareBtn');
	const addBtn = document.getElementById('addBtn');
	const filePicker = document.getElementById('filePicker');
	const logBtn = document.getElementById('logBtn');
	const popupClipboard = document.getElementById('popupClipboard');
	const loadingEl = document.getElementById('loadingMessage');
	const input = document.getElementById("shareCodeInput");
	const joinWithShareCode = document.getElementById("joinButton");
	const waitingButton = document.getElementById("waitingButton");

	const devURL = window.location.origin;
	const debouncedRerender = debounce(rerenderFileTree, 100);//slow sorting index

	//setup vdo sdk's, 
	const vdo = new VDONinjaSDK({
		salt: "rpxl.app",
		allowFallback: false,
		debug: false
	});

	const vdoWR = new VDONinjaSDK({
		salt: "rpxl.app",
		allowFallback: false,
		debug: false
	});

	//GENERATE RANDOM SID
	function randomID(len) {
		const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		const arr = new Uint8Array(len);
		crypto.getRandomValues(arr);
		return Array.from(arr, n => chars[n % chars.length]).join('');
	}

	//LOG WINDOW
	function log(...args) {
		//console.log(...args);
		logEl.textContent += args.join(' ') + '\n';
		logEl.scrollTop = logEl.scrollHeight;
	}

	checkSessionURL();  //autoconnect if session ID in URL

	//CHECK IF THERE IS A CORRECT SID IN THE URL AND AUTOCONNECT
	function checkSessionURL() {
		const queryURL = window.location.search.slice(1);
		const params = new URLSearchParams(queryURL);

		if (params.has('SID')) {
			const SID = params.get('SID');
			roomName = encodeURIComponent(SID);
			if (!roomName || roomName.length !== 24) {
				log('INCORRECTLY FORMATTED SESSION ID\n\nIf you are seeing this message, the session ID supplied is invalid. Please check the link and try again.\n\nOr contact the host for assistance.\n\nAlternativesly use the 8 digit share code supplied by the host, to join the waiting room.');
				return;
			} else {
				log('SESSION ID FOUND IN URL:', roomName);

				document.getElementById('helpIcon').style.display = "none";
				document.getElementById('shareTools').style.display = "none";
				document.getElementById('waitingButton').style.display = "none";
				document.getElementById('dropArea').classList.add('hidden');
				document.getElementById('topmenu').classList.remove('hidden');
				document.getElementById('subToolBar').classList.remove('hidden')
				document.getElementById('joinShareDialog').style.display = "none";
				document.getElementById('dragDropMessage').textContent = "Drop to add files"
				document.getElementById('dragDropSubMessage').textContent = ""

				createVDOroom(roomName)
				return;
			}
		} else {
			//setup qr code and room codes, do not start room till we do something (drop files enter a code etc.)
			roomName = randomID(24);
			waitingRoom = randomID(8).toUpperCase();;
			//waitingRoom = randomID(8).toUpperCase().replace(/(.{4})(.{4})/, "$1-$2");
			scode.textContent = waitingRoom.replace(/(.{4})(.{4})/, "$1-$2");;
			url = `${devURL}/?SID=${roomName}`

			var qrcode = new QRCode("qrcode", {
				text: url,
				width: 250,
				height: 250,
				colorDark : "#141414",
				colorLight : "#f0f0f0",
				correctLevel : QRCode.CorrectLevel.H
			});

			//createVDOroom(roomName);
			//createVDOwaitingRoom(waitingRoom);
		}
	}

	//CREATE VDO ROOM (MAIN)
	async function createVDOroom(room) {
		try {
			const ctl = await vdo.autoConnect({
				room: room,
				mode: "half",	//data only
				password: "",
				claim: true
			});
		} catch (err) { 
			log('Failed:', err.message) 
		}

		log('Joined room :', room);

		flushChunkDB("OutgoingFileCache"); //remove cache if exists
		flushChunkDB("IncomingFileCache"); //remove cache if exists

		setupVDOListeners();
	}

	//CREATE WAITING ROOM (SHORT CODE)
	async function createVDOwaitingRoom(room) {
		try {
			const ctl = await vdoWR.autoConnect({
				room: room,
				mode: "half",	//data only
				password: "",
				claim: true
			});
		} catch (err) { 
			log('Failed:', err.message) 
		}
		
		log('Watching waiting room : ', room);
		setupVDOWRListeners(room);
	}

	//JOIN WAITING ROOM (SHORT CODE)
	async function joinVDOWaitingRoom(waitingRoom) {
		try {
			const ctl = await vdoWR.autoConnect({
				room: waitingRoom,
				mode: "half",	//data only
				password: ""
			});
		} catch (err) { 
			log('Failed:', err.message) 
		}

		//console.warn('Joined waiting room :', waitingRoom);
		setupVDOWRListeners();
	}

	input.addEventListener("input", e => {
		let v = input.value;

		v = v.replace(/[^a-zA-Z0-9]/g, "");
		v = v.toUpperCase();
		v = v.slice(0, 8);

		if (v.length > 4) {
			v = v.slice(0, 4) + "-" + v.slice(4);
		}

		input.value = v;
	});

	//WAKE LOCK TO PREVENT SLEEPING DURING LARGE TRANSFERS
	async function enableWakeLock() {
		try {
			wakeLock = await navigator.wakeLock.request("screen");
			wakeLock.addEventListener("release", () => {
			});
			//console.log("Wake Lock active");
		} catch (err) {
			console.error(`${err.name}, ${err.message}`);
		}
	}

	async function disableWakeLock() {
		if (!wakeLock) return;
		try {
			await wakeLock.release();
			wakeLock = null;
			//console.log("Wake Lock disabled");
		} catch (err) {
			console.error(err);
		}
	}

	//INTERFACE
	//share code join
	function joinWaitingRoom() {
		const prettyShare = input.value;
		const shareCode = input.value.replace("-", "");

		if (shareCode.length !== 8) {
			input.value = null;
			return;
		};

		joinVDOWaitingRoom(shareCode);

		document.getElementById('loadingMessage').style.display = "none";
		document.getElementById('joinShareDialog').style.display = "none";
		document.getElementById('dropArea').style.pointerEvents = "none";
		document.getElementById('dragDropIcon').textContent = "orbit";
		document.getElementById('dragDropMessage').textContent = `Joined waiting room (${prettyShare})`;
		document.getElementById('dragDropSubMessage').textContent = "the host will let you in";
	}

	//join with share code
	joinWithShareCode.addEventListener('pointerdown', joinWaitingRoom);
	// Enter key in input
	input.addEventListener("keydown", e => {
	if (e.key === "Enter") {
			e.preventDefault();
			joinWaitingRoom();
		}
	});

	//waiting room popup
	waitingButton.addEventListener('pointerdown', () => {
		popupBG.classList.remove("hidden");
		waitingButton.classList.add("selected");
		popupWaitingList.classList.remove("hidden");
	});

	//share button
	shareBtn.addEventListener('pointerdown', () => {
		navigator.clipboard.writeText(`${devURL}/snd/?SID=${roomName}`);
		popupBG.classList.remove("hidden");
		popupClipboard.classList.remove("hidden");
		shareBtn.classList.add("selected");
	});
	//hidden bg element to hide share menu
	popupBG.addEventListener("pointerdown", function(e) {
		if (e.target.matches("#popupBG")) {
			if(!popupClipboard.classList.contains("hidden")) popupClipboard.classList.add("hidden");
			if(!popupWaitingList.classList.contains("hidden")) popupWaitingList.classList.add("hidden");
			popupBG.classList.add("hidden");
			waitingButton.classList.remove("selected");
			shareBtn.classList.remove("selected");
		}
	});
	// If the tab regains focus, re-request wake lock
	document.addEventListener("visibilitychange", () => {
		if (!document.hidden && wakeLock) {
			enableWakeLock();
		}
	});
	//show log window
	logBtn.addEventListener('pointerdown', () => {
		document.getElementById('log').classList.toggle('hidden');
		logBtn.classList.toggle('selected');
	});

	// Filter - all
	document.getElementById('filterAll').addEventListener('click', () => {
		currentFilter = 'all';
		setActiveButton('.filterSet', 'filterAll');
		debouncedRerender();
	});
	// Filter - local
	document.getElementById('filterLocal').addEventListener('click', () => {
		currentFilter = 'local';
		setActiveButton('.filterSet', 'filterLocal');
		debouncedRerender();
	});
	// Filter - remote
	document.getElementById('filterRemote').addEventListener('click', () => {
		currentFilter = 'remote';
		setActiveButton('.filterSet', 'filterRemote');
		debouncedRerender();
	});

	// Sort - latest
	document.getElementById('sortByTime').addEventListener('click', () => {
		currentSort = 'latest';
		setActiveButton('.sortSet', 'sortByTime');
		rerenderFileTree();
	});
	// Sort - name
	document.getElementById('sortByName').addEventListener('click', () => {
		currentSort = 'name';
		setActiveButton('.sortSet', 'sortByName');
		rerenderFileTree();
	});

	//sets active button for filter and sort
	function setActiveButton(groupSelector, activeId) {
		document.querySelectorAll(groupSelector + ' .subTool').forEach(btn => {
			btn.classList.toggle('active', btn.id === activeId);
		});
	}

	//DRAG AND DROP AND FILE ADDING HANDLING
	addBtn.addEventListener("click", () => {
		filePicker.click();
	});
	// Always handle picking files on both desktop + mobile
	filePicker.addEventListener("change", (event) => {
		const files = event.target.files;
		const dropId = randomID(8);

		for (let i = 0; i < files.length; i++) {
			const file = files[i];

			let relativePath;
			if (file.webkitRelativePath && file.webkitRelativePath !== "") {
				relativePath = file.webkitRelativePath;
			} else {
				relativePath = file.name;
			}

			file.relativePath = `${dropId}/${relativePath}`;
			if (!isHiddenFile(file)) addFile(file);
		}

		if (firstInteraction === true) {
			createVDOroom(roomName);
			createVDOwaitingRoom(waitingRoom);

			document.getElementById('dropArea').classList.add('hidden');
			document.getElementById('joinShareDialog').style.display = "none";
			document.getElementById('helpIcon').style.display = "none";
			document.getElementById('topmenu').classList.remove('hidden');
			document.getElementById('subToolBar').classList.remove('hidden');
			document.getElementById('dragDropMessage').textContent = "Drop to add files"
			document.getElementById('dragDropSubMessage').textContent = ""

			firstInteraction = false;
		}
	});

	//check if desktop, set up drag and drop UI
	const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

	if (!isMobile) {
		//set for desktop (folders and drag drop)
		filePicker.setAttribute('webkitdirectory', "");
		filePicker.setAttribute('directory', "");

		dropArea.addEventListener('click', () => {
			if (!firstInteraction) return;
			filePicker.click();
		});

		const dropOverlay = document.getElementById('dropArea');
		let dragCounter = 0; // helps handle nested dragenter/dragleave events

		window.addEventListener('dragenter', (e) => {
			e.preventDefault();
			dragCounter++;
			dropOverlay.classList.add('dragover');
		});

		window.addEventListener('dragleave', (e) => {
			e.preventDefault();
			dragCounter--;
			if (dragCounter === 0) dropOverlay.classList.remove('dragover');
		});

		window.addEventListener('dragover', (e) => {
			e.preventDefault();
		});

		window.addEventListener('drop', (e) => {
			e.preventDefault();
			dragCounter = 0;
			dropOverlay.classList.remove('dragover');
		});

		dropArea.addEventListener('drop', async (e) => {
			e.preventDefault();
			const dropId = randomID(8);

			const items = e.dataTransfer.items;
			if (!items) return handleFileList(e.dataTransfer.files);

			if (firstInteraction === true) {
				createVDOroom(roomName);
				createVDOwaitingRoom(waitingRoom);

				document.getElementById('dropArea').classList.add('hidden');
				document.getElementById('helpIcon').style.display = "none";		
				document.getElementById('joinShareDialog').style.display = "none";
				document.getElementById('topmenu').classList.remove('hidden');
				document.getElementById('subToolBar').classList.remove('hidden');
				document.getElementById('dragDropMessage').textContent = "Drop to add files"
				document.getElementById('dragDropSubMessage').textContent = ""

				firstInteraction = false;
			}
			const promises = [];    // Process all top-level entries concurrently

			for (let i = 0; i < items.length; i++) {
				const it = items[i];
				const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
				if (!entry) {
					if (it.getAsFile) addFile(it.getAsFile());
					continue;
				}

				if (entry.isDirectory) {
					promises.push(readDirectory(entry, '', dropId));
				} else if (entry.isFile) {
					// Wrap entry.file in a promise so we can await it
					promises.push(new Promise(resolve => entry.file(file => {
						addFile(file);
						resolve();
					})));
				}
			}

			await Promise.all(promises);  // Wait for all top-level items to finish
		});
	} else {
		//if mobile only allow multiple files and not folders ---- not sure this works
		filePicker.removeAttribute('webkitdirectory');
		filePicker.removeAttribute('directory');

		dropArea.classList.add('hidden');
		dropArea.style.display = "none";

		document.getElementById('topmenu').classList.remove('hidden');
		document.getElementById('subToolBar').classList.remove('hidden');
	}

	//play beep on connect
	function playBeep(freq = 880, duration = 0.15) {
		const ctx = new (window.AudioContext || window.webkitAudioContext)();
		const osc = ctx.createOscillator();
		const gain = ctx.createGain();

		osc.type = "sine";
		osc.frequency.value = freq;
		osc.connect(gain);
		gain.connect(ctx.destination);

		osc.start();

		gain.gain.setValueAtTime(0.2, ctx.currentTime);
		gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration);

		osc.stop(ctx.currentTime + duration);
	}

	//VDO (main room) listeners
	function setupVDOListeners() {
		//log('Setting up VDO listeners');

		vdo.addEventListener(`connected`, (event) => {
			//console.log("connected to signaling server");
		});

		vdo.addEventListener(`disconnected`, (event) => {
			//console.log("disconnected to signaling server");
		});

		vdo.addEventListener(`roomJoined`, (event) => {
			//console.log("Joined room :", event.detail.room);
		});
		vdo.addEventListener('peerConnected', (event) => {
			//used to view peers that connect later in session
			playBeep(400, 1);
			const guestUUID = event.detail.uuid;
			connectedPeers[guestUUID] = guestUUID;

			if (!guestUUID) return;
			updatePeersUI();
			handleGuestJoin(guestUUID);
			log("Peer connected :", guestUUID);

			// vdo.sendData({
			// 	dataType: "listing",
			// 	totalPeers: connectedPeers
			// })

			//console.warn("peer connected",event);
		});

		vdo.addEventListener('peerDisconnected', (event) => {
			playBeep(200, 2);
			const guestUUID = event.detail.uuid;
			delete connectedPeers[guestUUID];
			updatePeersUI();
			removePeerFiles(guestUUID);
			log("Peer dis-connected :", guestUUID);
		});

		vdo.addEventListener("peerListing", (event) => {
			//console.warn("lsting", event);
			//asks for all peers in room, can be run after same as listiing????
		});

		vdo.addEventListener("data", (event) => {
			//BINARY RECEIVER ONLY
			//console.warn("data:", event);
			const rawData = event.detail.data;

			handleIncomingChunk(rawData)
		});

		//IO messages, files added, removed, downloads and chunks etc.
		vdo.addEventListener('dataReceived', (event) => {
			const uuid = event.detail.uuid;
			const data = event.detail.data;
			const payload = event.detail.data.payload;

			//console.warn('control message from main room:', event);

			// if (data.dataType === "listing") {
			// 	console.warn("rcv no.of connected users :", connectedPeers)
			// 	//handleAckChunks( payload, uuid )
			// 	return;
			// }

			if (data.dataType == 'file-announce') {
				if (files[payload.id]) return;        //ignore duplicates if already have this file
				if (!uuid) return;
				payload.uploadedBy = uuid;

				files[payload.id] = {
					id: payload.id,
					name: payload.name,
					size: payload.size,
					folderPath: payload.folderPath || '',
					uploadedBy: payload.uploadedBy,
					timestamp: payload.timestamp
				};
				debouncedRerender()
				log(`Received file meta : ${payload.folderPath} / ${payload.name} - uploaded by : ${payload.uploadedBy}`);
			}

			if (data.dataType === "request-file") {
				const fileMeta = files[payload.id];
				log(`File requested : ${fileMeta?.folderPath || ''} / ${fileMeta?.name || payload.id} - by : ${uuid}`);
				enableWakeLock();
				respondToFileRequest(payload.id, uuid);
				return;
			}
			if (data.dataType === "file-removed") {
				const id = payload.id;
				const file = files[id];
				if (file) {
					delete files[id];
					const el = document.querySelector(`.file-item[data-id="${id}"]`);
					removeElementWithFade(el);
					log(`File removed : ${file.name} - on :  ${file.uploadedBy}`);
					cleanupEmptyFolders(file.folderPath);
				}
				return;
			}

			if (data.dataType === "directory-removed") {
				const path = payload.path;

				// Remove files inside folder first
				for (const id of Object.keys(files)) {
					if (files[id].folderPath.startsWith(path)) {
						delete files[id];
						const el = document.querySelector(`.file-item[data-id="${id}"]`);
						removeElementWithFade(el);
					}
				}
				// Now remove the folder itself
				const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
				removeElementWithFade(folderDiv);
				delete folderMap[path];

				cleanupEmptyFolders(path);
				log(`Directory removed remotely : ${path}`);
				return;
			}

			if (data.dataType === "source-not-found") {
				//console.warn("source file not found", payload)
				markFileDead(payload);
				const el = document.getElementById(`icon-container_${payload}`);
				el.style.opacity = "0";
				return;
			}
			if (data.dataType === "ACK-chunks") {
				//console.warn("user:", uuid, "ack chunk", payload)
				handleAckChunks( payload, uuid )
				return;
			}

			if (data.dataType === "Download-complete") {
				onDownloadComplete(payload, uuid);
				return;
			}

		}, false);

		// //		debug only, all events i know of
		// const sdkEvents = [
		// 	"listing", "migrate", "transferred", "connected","roomJoined",	"publishing",	"alert",	"error","connectionFailed","disconnected","listing",	"peerListing", "peerConnected","peerDisconnected", "peerInfo",	"track","trackRemoved","iceConnectionStateChange",	"videoaddedtoroom",	"description","offerSDP","someonejoined","other","dataChannelOpen","dataReceived","peerLatency","bye",	"seed"
		// ];
		// //Catch-all logger
		// sdkEvents.forEach(eventName => {
		// 	vdo.addEventListener(eventName, (event) => {
		// 		console.warn(`[SDK EVENT] ${eventName}`, event.detail);
		// 	});
		// });
	}

	//VDO (Waiting room) LISTENERS
	function setupVDOWRListeners(waitingRoom) {
		//console.warn("setting up waiting room listeners",room);

		vdoWR.addEventListener(`connected`, (event) => {
		//	console.log("connected to signaling server");
		});

		vdoWR.addEventListener(`disconnected`, (event) => {
		//	console.log("disconnected to signaling server");
		});
		vdoWR.addEventListener('peerConnected', (event) => {
			playBeep(400, 1);

			const guestUUID = event.detail.uuid;
			if (!guestUUID) return;

			// convert performance timestamp to Date
			const joinedAt = Date.now() - performance.now() + event.timeStamp;

			waitingPeers.set(guestUUID, joinedAt);

			renderWaitingPeers();
			log("Peer joined waiting room:", guestUUID);
		});

		vdoWR.addEventListener("peerDisconnected", (event) => {
			const uuid = event.detail?.uuid;
			if (!uuid) return;

			waitingPeers.delete(uuid);
			renderWaitingPeers();
		});

		vdoWR.addEventListener('dataReceived', (event) => {
			const uuid = event.detail.uuid;
			const data = event.detail.data;
			const payload = event.detail.data.payload;

			//console.warn('control message waiting room:', event);
			if (data.dataType === "migrate") {
				const target = data.target;
				const newRoom = data.roomid;

				//console.warn(`Migrating to new room : ${newRoom}`);
				vdoWR.sendData({
					dataType: 'peer-disconnect',
					timestamp: Date.now()
				});

				waitingPeers.delete(uuid);
				renderWaitingPeers();

				vdoWR.disconnect();
				sleep(500); 
				createVDOroom(newRoom);

				document.getElementById('waitingButton').style.display = "none";
				document.getElementById('dropArea').classList.add('hidden');
				document.getElementById('helpIcon').style.display = "none";		
				document.getElementById('joinShareDialog').style.display = "none";
				document.getElementById('topmenu').classList.remove('hidden');
				document.getElementById('subToolBar').classList.remove('hidden');
				document.getElementById('dragDropMessage').textContent = "Drop to add files"
				document.getElementById('dragDropSubMessage').textContent = ""

				firstInteraction = false;
				return;
			}

		});
	}

	function renderWaitingPeers() {
		const container = document.getElementById("popupWaitingList");
		container.innerHTML = "";

		for (const [uuid, ts] of waitingPeers) {
			const row = document.createElement("div");
			row.className = "waitingList";
			row.dataset.uuid = uuid;

			const uuidDiv = document.createElement("div");
			uuidDiv.className = "waitingUUID";
			uuidDiv.textContent = uuid;

			const timeDiv = document.createElement("div");
			timeDiv.className = "waitingTime";
			timeDiv.textContent = formatTime(ts);

			const allowDiv = document.createElement("div");
			allowDiv.className = "waitingAllow";
			allowDiv.innerHTML = `<span class="material-symbols-outlined">check_circle</span>`;

			allowDiv.onclick = () => allowWaitingPeer(uuid);

			row.append(uuidDiv, timeDiv, allowDiv);
			container.appendChild(row);
		}

		updateWaitingCount();
	}
	function formatTime(ms) {
		const d = new Date(ms);
		return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
	}
	function allowWaitingPeer(uuid) {
		vdoWR.sendData({
			dataType: "migrate",
			roomid: roomName,
			target: uuid
		},uuid);

		log("migrating peer ",uuid ,"to main room, will join with new UUID")
	}

	function updateWaitingCount() {
		const total = waitingPeers.size;

		waitingList.textContent = total === 0 ? "(0)" : `(${total})`;

		if (total) {
			waitingButton.style.animation = "pulse 1000ms";
			setTimeout(() => waitingButton.style.animation = "none", 1000);
		}
	}

	//SHUTDOWN ACTIONS
	window.addEventListener('beforeunload', () => {
		vdo.sendData({
			dataType: 'peer-disconnect',
			timestamp: Date.now()
		});

		if (vdo) {
			vdo.sendData({
				dataType: 'peer-disconnect',
				timestamp: Date.now()
			});
			vdo.disconnect();
		}
		if (vdoWR) {
			vdoWR.sendData({
				dataType: 'peer-disconnect',
				timestamp: Date.now()
			});
			vdo.disconnect();
		}

		flushChunkDB("OutgoingFileCache"); //remove cache if exists
		flushChunkDB("IncomingFileCache"); //remove cache if exists
	});

	//SEND FILE LIST TO USER WHEN THEY CONNECT (AFTER. SHORT DELAY)
	async function handleGuestJoin(guestUUID) {
		loadingEl.classList.remove('hidden');
		await sleep(500);    // delay to ensure the peer connection is ready

		const ids = Object.keys(files);

		if (ids.length === 0) {
			log('No files to send.');
			return;
		}

		log(`Sending list of ${ids.length} files to new guest ${guestUUID}...`);

		//only send local files
		for (const id of ids) {
			const meta = files[id];
			if (meta.uploadedBy == 'local') {
				sendToPeer(guestUUID, "file-announce", meta);
			}
		}
		// Optionally wait for all announcements to process
		await sleep(500 * ids.length); // small buffer for debounced rendering
		loadingEl.classList.add('hidden');    // Hide loading message once file list is rendered
	}

	//UPDATE THE CONNECTED PEERS COUNT IN UI
	function updatePeersUI() {
		const total = Object.keys(connectedPeers).length;

		peersList.textContent = total === 0
			? '(0)'
			: `(${total})`;
	}

	//REMOVE ANY FILES THE PEER HAS UPLOADED IF THEY DISCONNECT
	function removePeerFiles(peerUUID) {
		// Collect IDs of files uploaded by the disconnected peer
		const toRemove = Object.values(files)
			.filter(f => f.uploadedBy === peerUUID)
			.map(f => f.id);

		for (const id of toRemove) {
			const fileMeta = files[id];
			const folderPath = fileMeta.folderPath; // save for cleanup
			delete files[id];      // Remove from files object

			// Remove from DOM
			const fileDiv = document.getElementById(`data-${id}`);
			if (fileDiv) fileDiv.remove();

			cleanupEmptyFolders(folderPath);
		}
	}

	//PROCESS SINGLE FILE ENTRY 
	function readFileEntry(fileEntry, path = '', dropId) {
		return new Promise((resolve, reject) => {
			fileEntry.file(file => {
				if (!file) return resolve();

				file.relativePath = `${dropId}/${path}${file.name}`;

				if (!isHiddenFile(file)) addFile(file);
				resolve();
			}, reject);
		});
	}

	//READ DIRECTORY 
	async function readDirectory(dirEntry, path = '', dropId) {
		const reader = dirEntry.createReader();
		const readEntries = () => new Promise(res => reader.readEntries(res));

		let entries = await readEntries();

		while (entries.length) {
			for (const e of entries) {
				if (e.isDirectory && !e.name.startsWith('.')) {
					await readDirectory(e, path + dirEntry.name + '/', dropId);
				}
				else if (e.isFile) {
					await readFileEntry(e, path + dirEntry.name + '/', dropId);
				}
			}
			entries = await readEntries();
		}
	}

	//HANDLE FILE LIST (fallback)
	function handleFileList(list) {
		for (let i = 0; i < list.length; i++) {
			const file = list[i];
			if (!isHiddenFile(file)) addFile(file);
			else log(`Skipping hidden file: ${file.name}`);
		}
	}

	//HIDDEN FILE FILTER 
	function isHiddenFile(pathOrFile) {
		let path = "";

		if (typeof pathOrFile === "string") path = pathOrFile;
		else if (pathOrFile.webkitRelativePath) path = pathOrFile.webkitRelativePath;
		else if (pathOrFile.relativePath) path = pathOrFile.relativePath;
		else path = pathOrFile.name || "";

		if (!path) return true;

		return path.split('/').some(part => part.startsWith('.') && part.length > 1);
	}

	//ADD FILE 
	function addFile(file) {
		if (!file) return;

		const id = randomID(8)
		const relativePath = file.relativePath || file.name;    // Use relativePath if available, otherwise fallback to file name
		const pathParts = relativePath.split('/');    // Split relative path into folder path + file name
		const fileName = pathParts.pop();
		const folderPath = pathParts.join('/');

		files[id] = {
			id,
			name: fileName,
			size: file.size,
			folderPath,        // preserves folder hierarchy
			uploadedBy: 'local',
			lastModified: file.lastModified,
			timestamp: Date.now(),
			file
		};

		debouncedRerender();  // update UI
		log(`Added: ${relativePath} (${formatBytes(file.size)})`);
		announceFile(id);    // Notify peers
	}

	//ANNOUNCE FILE (TO PEER, not used at moment, OR BROADCAST)
	function announceFile(id, targetUUID = null) {
		const meta = files[id];
		if (!meta) return;

		const payload = {
			id: meta.id,
			name: meta.name,
			size: meta.size,
			folderPath: meta.folderPath,
			//uploadedBy: meta.uploadedBy, don't send will be filled in be reciever
			timestamp: meta.timestamp
		};

		if (targetUUID) {
			sendToPeer(targetUUID, "file-announce", payload);
		} else {
			sendBroadcast("file-announce", payload);
		}
	}

	//SEND CONTROL MESSAGES (NOT DATA, FILE ADDED/REMOVED, FILE REQUESTS ETC)
	//SEND TO SPECIFIC PEER (STREAMID)
	function sendToPeer(targetUUID, dataType, payload = {}) {
		const total = Object.keys(connectedPeers).length;
		if (total === 0) return; // only send if peers connected
		vdo.sendData({
			dataType,
			payload
		}, targetUUID)
		//console.warn("sendToPeer dataType", dataType, "to", targetUUID, "payload", payload);
	}

	//send to all peers (connects, disconnects, adding or removing files)
	function sendBroadcast(dataType, payload = {}) {
		const total = Object.keys(connectedPeers).length;
		if (total === 0) return; // only send if peers connected
		vdo.sendData({
			dataType,
			payload
		});
		console.warn("broadcast", dataType);
	}

	//SORT FILES BY LATEST (DEFAULT) OR NAME
	//stops sort operation running to often
	function debounce(fn, delay) {
		let timer = null;
		return (...args) => {
			clearTimeout(timer);
			timer = setTimeout(() => fn(...args), delay);
		};
	}

	//SORTS THE FILE TREE BY DATE/NAME LOCAL/REMOTE OR ALL
	function rerenderFileTree() {
		const treeRoot = document.getElementById('fileList');

		//Save folder expand/collapse state
		folderState = {};
		for (const path in folderMap) {
			const folderDiv = folderMap[path]?.closest('.folder');
			if (!folderDiv) continue;
			const contents = folderDiv.querySelector('.folder-contents');
			//folderState[path] = contents && contents.style.display !== 'none';
			folderState[path] = contents.classList.contains('open');
		}

		//Clear tree
		treeRoot.innerHTML = '';
		folderMap = {};

		//Sort latest / name
		const fileArray = Object.values(files);
		//console.warn("filearray", fileArray);
		if (currentSort === 'name') {
			fileArray.sort((a, b) => a.name.localeCompare(b.name));
		} else {
			fileArray.sort((a, b) => b.timestamp - a.timestamp);
		}
		//Apply filter all / local / remote
		let filtered = fileArray;

		if (currentFilter === 'local') {
			filtered = filtered.filter(f => f.uploadedBy === 'local');
		}
		else if (currentFilter === 'remote') {
			filtered = filtered.filter(f => f.uploadedBy !== 'local');
		}
		//Rebuild
		for (const f of filtered) {
			renderTreeItem(f);
		}

		for (const path in folderState) {
			const contents = folderMap[path];
			if (!contents) continue;

			if (folderState[path]) {
				contents.classList.add('open');
			} else {
				contents.classList.remove('open');
			}
		}

	}

	//BUILDS THE FILE TREE
	function renderTreeItem(f) {
		const isReceiver = f.uploadedBy !== 'local'; //render in blue with download button for remote files
		///const isReceiver = files[f.id]?.file === undefined;

		const treeRoot = document.getElementById('fileList');
		const pathParts = f.folderPath ? f.folderPath.split('/') : [];
		const displayParts = [...pathParts];
		let currentContainer = treeRoot;
		let currentPath = '';
		// let logicalPath = '';
		if (/^[0-9a-f-]{36}$/.test(displayParts[0])) {
			displayParts.shift();
		}

		for (let depth = 0; depth < pathParts.length; depth++) {
			const part = pathParts[depth];
			currentPath = currentPath ? `${currentPath}/${part}` : part;

			if (!folderMap[currentPath]) {
				const folderDiv = document.createElement('div');
				folderDiv.className = 'folder ' + (isReceiver ? 'remote' : 'local');
				folderDiv.dataset.path = currentPath;

				// Apply indentation
				folderDiv.style.marginLeft = `${depth * 20}px`; // 20px per level

				const iconType = isReceiver ? 'folder-download' : 'folder-delete';
				const iconLabel = isReceiver ? 'download' : 'delete';

				folderDiv.innerHTML = `
        <div class="folder-header" data-folder="${currentPath}">
          <span class="material-symbols-outlined folder-icon">folder</span>
          <strong class="folder-text">${escapeHtml(part)}</strong>
          <span class="material-symbols-outlined ${iconType}">${iconLabel}</span>
        </div>
        <div class="folder-contents"></div>
      `;
				if (depth == 0) continue; // do not render the dropID

				currentContainer.appendChild(folderDiv);
				folderMap[currentPath] = folderDiv.querySelector('.folder-contents');

				// Expand/collapse folder
				folderDiv.querySelector('.folder-header').addEventListener('pointerdown', (e) => {
					if (e.target.classList.contains(iconType)) return;
					const contents = folderDiv.querySelector('.folder-contents');
					contents.classList.toggle('open');
					folderState[currentPath] = contents.classList.contains('open');
				});

				// Folder action
				folderDiv.querySelector(`.${iconType}`).addEventListener('pointerdown', async (e) => {
					e.stopPropagation();
					const folderPath = e.target.closest('.folder-header').dataset.folder;
					if (isReceiver) {
						requestDownload(folderPath, true);
					} else {
						if (confirm(`Remove entire directory "${folderPath}" and all its files from share?`)) {
							await deleteDirectory(folderPath);
							sendDirectoryRemoved(folderPath);
						}
					}
				});
			}
			currentContainer = folderMap[currentPath];
		}

		// Create file entry
		const fileDiv = document.createElement('div');
		fileDiv.className = 'file-item ' + (isReceiver ? 'remote' : 'local');
		fileDiv.id = `data-${f.id}`;
		fileDiv.dataset.id = f.id;
		//style object
		Object.assign(fileDiv.style, { display: 'flex', justifyContent: "space-between", alignItems: "center", padding: "2px 10px", marginLeft: `${pathParts.length}px` })

		const fileIconClass = isReceiver ? 'file-download' : 'file-delete';
		const fileIconLabel = isReceiver ? 'download' : 'delete';

		fileDiv.innerHTML = `
    <span class="file-name">${escapeHtml(f.name)}</span>
    <span class="file-size">${formatBytes(f.size)}</span>
    <span class="file-icon-container" id="icon-container_${f.id}">
      <span class="material-symbols-outlined ${fileIconClass}" id="${f.id}_icon">${fileIconLabel}</span>
    </span>
  `;

		currentContainer.appendChild(fileDiv);

		// File action
		fileDiv.querySelector(`.${fileIconClass}`).addEventListener('pointerdown', async (e) => {
			e.stopPropagation();
			if (isReceiver) {
				requestDownload(f.id, false);
			} else {
				deleteFile(f.id);
			}
		});
	}

	//FILE AND FOLDER DELETES
	// Animate when deleted and return a Promise that resolves after removal
	function removeElementWithFade(el) {
		return new Promise((resolve) => {
			if (!el) return resolve(); // nothing to remove

			el.offsetHeight;       // Trigger reflow so transition always runs
			el.classList.add('fade-slide-out');

			el.addEventListener('transitionend', () => {
				if (el.parentNode) el.parentNode.removeChild(el);
				resolve(); // resolve after removal
			}, { once: true });

			// Fallback in case transitionend doesn't fire
			setTimeout(() => {
				if (el.parentNode) el.parentNode.removeChild(el);
				resolve();
			}, 500); // CSS transition duration
		});
	}

	//REMOVE DIRECTORY(S)
	async function deleteDirectory(path) {
		if (!path) return;
		log(`Deleting directory: ${path}`);

		// Find all file IDs inside that folder (recursively)
		const toDelete = Object.keys(files).filter(id =>
			files[id].folderPath.startsWith(path)
		);

		// Delete contained files
		for (const id of toDelete) {
			const el = document.querySelector(`.file-item[data-id="${id}"]`);
			removeElementWithFade(el);
			await announceFileRemoved(id, path);
			delete files[id];
		}

		// Remove the folder DOM
		const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
		if (folderDiv) folderDiv.remove();

		delete folderMap[path];    // Remove from folderMap
		await sendDirectoryRemoved(path);    //announce directory removal to peers
		cleanupEmptyFolders(path);    //clean any now-empty parents
	}

	//ANNOUNCE DIRECTORY REMOVAL TO ALL PEERS
	async function sendDirectoryRemoved(path, targetUUID = null) {
		const peerKeys = Object.keys(connectedPeers);
		if (peerKeys.length === 0) return;      //console.log("No connected guests");

		sendBroadcast("directory-removed", { path });
		log(`Announced directory removal: ${path}`);
	}

	//REMOVE FILE FROM DOM
	async function deleteFile(id) {
		const file = files[id];
		if (!file) return;

		const folderPath = file.folderPath || '';
		delete files[id];
		const el = document.querySelector(`.file-item[data-id="${id}"]`);

		if (el) await removeElementWithFade(el);

		log(`Deleted file : / ${folderPath} / ${file.name}`);
		cleanupEmptyFolders(folderPath);
		await announceFileRemoved(id, folderPath);
	}

	//ANNOUNCE FILE REMOVAL TO ALL PEERS
	async function announceFileRemoved(id, path) {
		const total = Object.keys(connectedPeers).length;
		if (total == 0) return;

		sendBroadcast("file-removed", { id });
		log(`Announced file removal : `, id);
	}

	//CLEANUP AND REMOVE ANY EMPTY FOLDERS
	function cleanupEmptyFolders(startPath = null) {
		function isEmptyFolder(folderDiv) {
			const contents = folderDiv.querySelector('.folder-contents');
			if (!contents) return true;

			// Check if contents has any visible file-items or folder divs
			const children = Array.from(contents.children).filter(
				el => el.classList.contains('file-item') || el.classList.contains('folder')
			);

			return children.length === 0;
		}

		if (startPath) {
			let parts = startPath.split('/');
			while (parts.length > 0) {
				const path = parts.join('/');
				const folder = document.querySelector(`.folder[data-path="${path}"]`);
				if (folder && isEmptyFolder(folder)) {
					log(`Removing empty folder: ${path}`);
					folder.remove();
					delete folderMap[path];
					sendBroadcast("directory-removed", { path });
				}
				parts.pop(); // move up
			}
		} else {
			const folders = document.querySelectorAll('.folder');
			for (const folder of folders) {
				if (isEmptyFolder(folder)) {
					const path = folder.dataset.path;
					log(`Removing empty folder: ${path}`);
					folder.remove();
					delete folderMap[path];
					// sendBroadcast("directory-removed2", { path });
				}
			}
		}
	}

	//IF FILE NOT FOUND ON HOST DRIVE WHEN REQUESTED MARK AS DEAD
	function markFileDead(fileID) {
		//console.warn("marking file dead");
		const el = document.getElementById(`data-${fileID}`);
		if (!el) return;
		el.classList.add("file-dead");
	}

	//FILE DOWNLOAD UI, CIRCLE, RESTORE BACK AND CALC DL SPEED PROGRESS BARS
	const pausedDownloads = new Set(); // holds fileIDs of paused downloads
	const incomingFiles = new Map();

	function createFileProgressUI(id) {
		const container = document.getElementById(`icon-container_${id}`);
		if (!container) return;

		// Clear previous content and insert progress UI
		container.innerHTML = `
    <div class="roundProgressBarBG">
      <div class="roundProgressBarFill" id="progress-bar-${id}"></div>
      <div class="roundProgressBarCenter">
        <div class="stop-btn" id="stop-btn-${id}">✕</div>
      </div>
    </div>
  `;

		const stopBtn = document.getElementById(`stop-btn-${id}`);
		if (!stopBtn) return;
		// Style stop button
		Object.assign(stopBtn.style, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", cursor: "pointer", fontSize: "0.8em", userSelect: "none", opacity: "0.5" });

		// Stop button handler
		stopBtn.addEventListener("pointerdown", () => {
			// stop local
			//pausedDownloads.delete(id);
			//delete incomingFiles[id];
			//downloadQueue = downloadQueue.filter(job => job.fileID !== id);      // remove from queue
			// restore icon cleanly
			cancelDownload(id)
			restoreDownloadIcon(id);
		});
	}
	//if transfer is cancelled 
	function restoreDownloadIcon(id) {
		const container = document.getElementById(`icon-container_${id}`);
		if (!container) return;

		// Restore original icon
		container.innerHTML = `
    <span class="material-symbols-outlined file-download" id="${id}_icon">download</span>
  `;

		const icon = document.getElementById(`${id}_icon`);
		if (!icon) return;

		// Reattach the normal download behavior
		icon.addEventListener("pointerdown", (e) => {
			e.stopPropagation();
			requestDownload(id, false);
			createFileProgressUI(id);
		});
	}

	function markDownloadCompleted(id) {
		const fileEl = document.getElementById(`icon-container_${id}`);
		if (!fileEl) return;

		fileEl.classList.add("download-complete");

		// Set progress visually to 100%
		const bar = fileEl.querySelector(".progress-bar");
		if (bar) bar.style.backgroundImage = `conic-gradient(dodgerblue 359deg, light-dark(var(--color-light-white), var(--color-dark-grey)) 359deg)`;

		// Replace stop button with ✓ icon (but keep clickable)
		const btn = document.getElementById(`stop-btn-${id}`);
		if (btn) {
			btn.dataset.originalIcon = btn.innerHTML;   // store original
			btn.innerHTML = "✓";                         // completed icon
			//btn.classList.add("completed");

			// Clicking ✓ restores original download button
			btn.onclick = () => {
				btn.innerHTML = btn.dataset.originalIcon;
				//btn.classList.remove("completed");
				fileEl.classList.remove("download-complete");
				btn.onclick = () => handleFileDownload(id);         // restore original handler
			};
		}
	}

	function updateFileProgressUI(id, percent) {
		const bar = document.getElementById(`progress-bar-${id}`);
		if (!bar) return; // safely ignore if element removed
		if (pausedDownloads.has(id)) return;

		const pct = Math.max(0, Math.min(100, Number(percent) || 0));
		const deg = pct * 3.6; // 100% -> 360°
		bar.style.backgroundImage = `conic-gradient(dodgerblue ${deg}deg, light-dark(var(--color-light-white), var(--color-dark-grey)) ${deg}deg)`;
	}

	//CALCULATE AND SHOW SPEED OF DOWNLOAD / UPLOAD
	let bytesReceivedInInterval = 0;
	let bytesSentInInterval = 0;
	// Called whenever a chunk is received
	function onChunkReceived(chunkSize) {
		bytesReceivedInInterval += chunkSize;
	}
	// Called whenever a chunk is sent
	function onChunkSent(chunkSize) {
		bytesSentInInterval += chunkSize;
	}
	function formatSpeed(bytes) {
		if (bytes > 1e6) return (bytes / 1e6).toFixed(2) + " MB/s";
		if (bytes > 1e3) return (bytes / 1e3).toFixed(2) + " KB/s";
		return bytes + " B/s";
	}
	//update every 500ms
	setInterval(() => {
		const downloadSpeed = formatSpeed(bytesReceivedInInterval * 2); // interval 500ms → scale to 1s
		const uploadSpeed = formatSpeed(bytesSentInInterval * 2);
		document.getElementById("transferSpeed").textContent = `Download: ${downloadSpeed} | Upload: ${uploadSpeed}`;
		// Reset counters
		bytesReceivedInInterval = 0;
		bytesSentInInterval = 0;
	}, 500);

	// UTILITY - NICE FORMAT SIZE AND REMOVE ANY FUNNY CHARACTERS FROM FILE OR FOLDER NAMES
	function formatBytes(a) { if (a === 0) return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const e = Math.floor(Math.log(a) / Math.log(1024)); return (a / Math.pow(1024, e)).toFixed(2) + ' ' + units[e]; }
	function escapeHtml(s) { return String(s).replace(/[&<>\"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" })[c]); }

	//PAUSE AFTER CONNECT AND SENDING OF CONTROL MESSAGES IF PEER ADDS OR REMOVES FILES
	function sleep(ms) {
		return new Promise(r => setTimeout(r, ms));
	}


	//TX AND RX FILE REQUESTS
	// PEER REQUESTS FILE
	function requestDownload(fileID, isFolder = false) {
		//FOLDER DOWNLOAD HANDLED FIRST
		if (isFolder) {
			const folderPath = fileID;  // fileID *is* a folder path here
			log(`Requesting folder : ${folderPath}`);

			// Find all files whose folderPath starts with this folder
			const fileIDs = Object.keys(files).filter(id =>
				files[id].folderPath.startsWith(folderPath)
			);

			for (const id of fileIDs) {
				const meta = files[id];
				const host = meta.uploadedBy;

				queueDownload(id, host, true);
				createFileProgressUI(id);
			}
			return;
		}
		//SINGLE FILE DOWNLOAD
		const meta = files[fileID];
		if (!meta) return log("Requested file failed : no such file");

		log(`Requesting file : ${meta.name} - uploaded by : ${meta.uploadedBy}`);
		const host = meta.uploadedBy;
		queueDownload(fileID, host, false);
		createFileProgressUI(fileID);
	}

	///HOST SENDS FILES
	//RESPOND TO FILE REQUEST
	async function respondToFileRequest(fileID, targetUUID) {
		sending = false;
		//const conns = vdo.connections.get(targetUUID);
		//const dc = conns?.publisher?.dataChannel || conns?.viewer?.dataChannel;
		//if (!dc) return;

		const meta = files[fileID];
		if (!meta) return;

		const file = meta.file;
		const chunkSize = (256 * 1024) - 64;

		produceChunks(fileID, targetUUID, file, chunkSize)
		await refillSendCache(fileID);
		sendRAWData();
	}

	async function handleAckChunks(payload, uuid) {
			if (!payload.parts?.length) return;

			const fileID = payload.fileID;
			const parts = payload.parts;

			let filename = fileID; // fallback

			if (files[fileID]?.name) {
				filename = files[fileID].name;
			}
			if (!fileID) return;
	
			const t = transfers.get(`${fileID}:${uuid}`);
			if (!t) return;

			for (const p of parts) {
				t.pending.delete(p);
				t.inflight.delete(p);

				//console.warn("ACK recieved",p);
			}

			if (t.pending.size === 0) {
				log("Transfer cancelled or completed for file :", filename, " - by :", uuid);

				transfers.delete(`${fileID}:${uuid}`);

				// optional: also clear any send cache you keep
				if (sendCache?.has(fileID)) sendCache.delete(fileID);

				return;
			}

		// refill send cache using pending
		await refillSendCache(fileID, uuid);
	}

	//RECIEVED FILE DOWNLOAD COMPLETE MESSAGE FROM GUEST, SCHEDULE CLEAR FILE FROM CACHE DB
	function onDownloadComplete(fileID, peerUUID) {
		const f = files[fileID];
		if (!f) return;

		f.activeDownloads?.delete(peerUUID);
		log("Download complete : ", f.name, " - by : ", peerUUID);

		// If all peers done → schedule purge
		if (!f.activeDownloads || f.activeDownloads.size === 0) {
			scheduleChunkPurge(fileID);
		}
	}

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// FILE TRANSFER ENGINE
	// Simple CRC32
	function crc32(buf) {
		let crc = -1;
		for (let b of buf) crc = (crc >>> 8) ^ table[(crc ^ b) & 0xFF];
		return (crc ^ -1) >>> 0;
	}

	const table = (() => {
		let t = new Uint32Array(256);
		for (let i = 0; i < 256; i++) {
			let c = i;
			for (let j = 0; j < 8; j++) c = ((c & 1) ? 0xEDB88320 ^ (c >>> 1) : c >>> 1);
			t[i] = c >>> 0;
		}
		return t;
	})();

	//SENDER CHUNK CACHING DB creation parameters
	//const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
	const POST_DOWNLOAD_GRACE = 2 * 60 * 1000; // keep file cached for 2 minutes after file complete recieved
	const TX_DB = "OutgoingFileCache";
	const TX_STORE = "chunks";
	let txDB;

	const sendCache = new Map();
	const cacheQueue = new Map();
	const transfers = new Map(); // fileID -> TransferState
	//const MAX_CACHE_QUEUE = 8;
	const MAX_SEND_BUFFER = (2 * 1024 * 1024) + 256;
	const MEMORY_CACHE = 32;	

	async function produceChunks(fileID, targetUUID, file, chunkSize) {
		let logCache = false;
		files[fileID].chunkSize = chunkSize;
		files[fileID].activeDownloads ??= new Set();
		files[fileID].activeDownloads.add(targetUUID);

		const totalChunks = Math.ceil(file.size / chunkSize);
		const transferKey = `${fileID}:${targetUUID}`;

		const t = {
			fileID,
			targetUUID,
			totalChunks,
			pending: new Set(),
			inflight: new Set(),
			maxWritten: -1
		};

		//pending ONCE
		for (let i = 0; i < totalChunks; i++) {
			t.pending.add(i);
		}

		if (!transfers.has(transferKey)) transfers.set(transferKey, t);


		for (let i = 0; i < totalChunks; i++) {
			const chunkIndex = i;

			const cached = await idbGetChunk(fileID, chunkIndex); 			//check cache if chunk exists first

			if (cached) {
				// chunk already exists in IndexedDB
				const tID = transfers.get(transferKey);
				if (tID) {
					tID.maxWritten = Math.max(tID.maxWritten, chunkIndex);
					await refillSendCache(fileID, targetUUID);   //wake sender
				}
				if (!logCache) {
					log("File : ", file.name, "is already in cache, sending");
					logCache = true;
				}
				continue;
			}

			if (!logCache) {
				log(`Splitting ${file.name} into ${totalChunks} parts and sending`); //just once per ask
				logCache = true;
			}

			const start = i * chunkSize;
			const end = Math.min(file.size, start + chunkSize);

			if (i % 8 === 0) await Promise.resolve();

			let buffer;
			try {
				buffer = await file.slice(start, end).arrayBuffer();
			} catch (err) {
				//console.warn("Source file not found:", fileID, file.name, err);
				markFileDead(fileID);
				sendBroadcast("source-not-found", fileID);
				return;
			}

			const crc = crc32(new Uint8Array(buffer));
			const idBytes = new TextEncoder().encode(fileID);

			const headerLen = 4 + 4 + 4 + idBytes.length + 4;
			const out = new Uint8Array(headerLen + buffer.byteLength);
			const view = new DataView(out.buffer);
			let o = 0;

			view.setUint32(o, chunkIndex, true); o += 4;
			view.setUint32(o, totalChunks, true); o += 4;
			view.setUint32(o, idBytes.length, true); o += 4;
			out.set(idBytes, o); o += idBytes.length;
			view.setUint32(o, crc, true); o += 4;
			out.set(new Uint8Array(buffer), o);

			await writeChunkToIDB(fileID, chunkIndex, out.buffer);

			t.maxWritten = Math.max(t.maxWritten, chunkIndex);
			await refillSendCache(fileID, targetUUID);
		}
	}

	//CREATE, WRITE AND GET CHUNKS FROM TX_DB
	function openTxDB() {
		if (txDB) return txDB;
		txDB = new Promise((resolve, reject) => {
			const req = indexedDB.open(TX_DB, 1);
			req.onupgradeneeded = e => {
				e.target.result.createObjectStore(TX_STORE, { keyPath: "key" });
			};
			req.onsuccess = () => resolve(req.result);
			req.onerror = () => reject(req.error);
		});
		return txDB;
	}

	async function writeChunkToIDB(fileID, chunkIndex, buffer) {
		const db = await openTxDB();

		return new Promise((resolve, reject) => {
			const tx = db.transaction(TX_STORE, "readwrite");
			const store = tx.objectStore(TX_STORE);

			const req = store.put({
				key: `${fileID}:${chunkIndex}`,
				fileID,
				chunkIndex,
				data: buffer,
				ts: Date.now()
			});

			req.onerror = () => reject(req.error);
			tx.oncomplete = resolve;
			tx.onerror = () => reject(tx.error);
		});
	}

	async function idbGetChunk(fileID, chunkIndex) {
		const db = await openTxDB();

		return new Promise((resolve, reject) => {
			const tx = db.transaction(TX_STORE, "readonly");
			const req = tx.objectStore(TX_STORE).get(`${fileID}:${chunkIndex}`);

			req.onsuccess = () => resolve(req.result?.data || null);
			req.onerror = () => reject(req.error);
		});
	}


	//SENDBUFFER - MEMORY, FILLED FROM DISK CACHE
	let sending = false;

	function sendRAWData() {
		if (sending) return;
		sending = true;

		const pump = () => {
			if (!sending) return;

			for (const [key, chunk] of sendCache) {
				const [fileID, targetUUID, part] = key.split(":");
				const conns = vdo.connections.get(targetUUID);
				const dc = conns?.publisher?.dataChannel || conns?.viewer?.dataChannel;

				if (!dc || dc.bufferedAmount > MAX_SEND_BUFFER) continue;

				dc.send(chunk);
				bytesSentInInterval += chunk.byteLength;

				sendCache.delete(key);

				const t = transfers.get(`${fileID}:${targetUUID}`);
			}
			setTimeout(pump, 0);
		};
		pump();
	}

	//amount of chunks to cache in memory

	async function refillSendCache(fileID, targetUUID) {
		const t = transfers.get(`${fileID}:${targetUUID}`);
		const conns = vdo.connections.get(targetUUID);
		const dc = conns?.publisher?.dataChannel || conns?.viewer?.dataChannel;

		if (!dc) return;
		if (!t) return;

		for (const part of t.pending) {
			if (t.inflight.size >= MEMORY_CACHE) break;
			if (dc.bufferedAmount > 512_000) break;
			if (part > t.maxWritten) continue;
			if (t.inflight.has(part)) continue;
			if (sendCache.has(`${fileID}:${targetUUID}:${part}`)) continue;//stop duplicates getting queued

			const chunk = await idbGetChunk(fileID, part);
			if (!chunk) continue;

			sendCache.set(`${fileID}:${targetUUID}:${part}`, chunk);
			t.inflight.add(part);
		}
	}

	//scheduler to remove chunks when we recieve file download complete
	function scheduleChunkPurge(fileID) {
		const f = files[fileID];
		if (!f) return;

		log("Scheduling cache purge for file : ", f.name);

		f.purgeTimer = setTimeout(() => {
			purgeFileChunks(fileID);
			f.purgeTimer = null;
		}, POST_DOWNLOAD_GRACE);
	}

	async function purgeFileChunks(fileID) {
		const filename = files[fileID];
		const db = await openTxDB();
		const tx = db.transaction(TX_STORE, "readwrite");
		const store = tx.objectStore(TX_STORE);
		const req = store.getAllKeys();

		req.onsuccess = () => {
			for (const key of req.result) {
				if (key.startsWith(fileID + ":")) {
					store.delete(key);
				}
			}
		};
		log("Purging file : ", filename.name, " from cache");
	}

	//global used to empty TX and RX db's on shutdown and startup
	function flushChunkDB(db) {
		return new Promise((resolve, reject) => {
			const req = indexedDB.deleteDatabase(db);
			req.onsuccess = resolve;
			req.onerror = () => reject(req.error);
			req.onblocked = () => console.warn("DB delete blocked by open tabs");
		});
	}

	//FILE RECIEVING HANDLING
	//recieving file chunks
	async function handleIncomingChunk(buffer) {
		onChunkReceived(buffer.byteLength);

		const view = new DataView(buffer);
		let offset = 0;

		const part = view.getUint32(offset, true); offset += 4;
		const total = view.getUint32(offset, true); offset += 4;
		const idLen = view.getUint32(offset, true); offset += 4;

		const idBytes = new Uint8Array(buffer, offset, idLen);
		const fileID = new TextDecoder().decode(idBytes);
		offset += idLen;

		const crcExpected = view.getUint32(offset, true); offset += 4;
		const chunk = buffer.slice(offset);

		const crcActual = crc32(new Uint8Array(chunk));
		if (crcActual !== crcExpected) {
			console.warn("CRC Failed id:", fileID, "part", part, " of", total)
			return;
		}

		if (!incomingFiles.has(fileID)) {
			incomingFiles.set(fileID, {
				total,
				received: new Set(),
				lastAckCount: 0,
				completed: false
			});
		}

		const file = incomingFiles.get(fileID);

		if (!file.received.has(part)) {
			await storeRxChunk(fileID, part, file.total, chunk);
			file.received.add(part);
			updateFileProgressUI(fileID, (file.received.size / file.total) * 100);
		}

		//send ACK if new chunks arrived
		if (file.received.size !== file.lastAckCount) {
			file.lastAckCount = file.received.size;

			sendToPeer(files[fileID]?.uploadedBy, "ACK-chunks", {
				fileID,
				parts: [...file.received]
			});
		}

		//console.warn("received", file.received.size, "of", file.total);

		if (!file.completed && file.received.size === file.total) {
			file.completed = true;

			//console.warn("file id:", fileID, "all received");

			const stream = new ReadableStream({
				async start(controller) {
					for (let i = 0; i < file.total; i++) {
						const chunk = await getRxChunk(fileID, i);
						if (!chunk) {
							controller.error("Missing chunk " + i);
							return;
						}
						controller.enqueue(new Uint8Array(chunk));
					}
					controller.close();
				}
			});

			const blob = await new Response(stream).blob();
			onFileComplete(fileID, blob);
		}
	}

	//RECIEVER CACHE DB
	//store chunks in indexDB to free up memory
	const RX_DB = "IncomingFileCache";
	const RX_STORE = "chunks";
	let rxDB;

	function openRxDB() {
		if (rxDB) return rxDB;
		rxDB = new Promise((resolve, reject) => {
			const req = indexedDB.open(RX_DB, 1);
			req.onupgradeneeded = e => {
				e.target.result.createObjectStore(RX_STORE, { keyPath: "key" });
			};
			req.onsuccess = () => resolve(req.result);
			req.onerror = () => reject(req.error);
		});
		return rxDB;
	}

	async function storeRxChunk(fileID, part, total, data) {
		const db = await openRxDB();

		return new Promise((resolve, reject) => {
			const tx = db.transaction(RX_STORE, "readwrite");
			const store = tx.objectStore(RX_STORE);

			store.put({
				key: `${fileID}:${part}`,
				fileID,
				part,
				total,
				data,
				ts: Date.now()
			});

			tx.oncomplete = resolve;
			tx.onerror = () => reject(tx.error);
		});
	}

	async function getRxChunk(fileID, part) {
		const db = await openRxDB();
		return new Promise(res => {
			const tx = db.transaction(RX_STORE);
			const req = tx.objectStore(RX_STORE).get(`${fileID}:${part}`);
			req.onsuccess = () => res(req.result?.data);
		});
	}

	async function purgeRXChunks(fileID) {
		const meta = files[fileID];
		log("Purging chunks for", meta?.name || fileID);

		const db = await openRxDB();
		const tx = db.transaction(RX_STORE, "readwrite");
		const store = tx.objectStore(RX_STORE);

		const range = IDBKeyRange.bound(
			fileID + ":",
			fileID + ":\uffff"
		);

		return new Promise((resolve, reject) => {
			const req = store.openCursor(range);

			req.onsuccess = e => {
				const cursor = e.target.result;
				if (cursor) {
					cursor.delete();
					cursor.continue();
				} else {
					resolve();
				}
			};

			req.onerror = reject;
		});
	}

	//////////////////////////////////////////////////////////////////////////////////////////////////////
	//DOWNLOAD QUEUE
	const ackWaiters = {}; // key = `${id}:${group}` -> resolve()
	let downloadState = new Map();	//tracks state of each file in queue (queued, active, stopped, done)
	let activeFileDownloads = 0;     //download queue files currently running
	const MAX_PARALLEL_DOWNLOADS = 4; // download queue max concurrent files
	const activeStreamers = new Map();

	function queueDownload(fileID, host, fromFolder = false) {
		const state = downloadState.get(fileID);

		// Only reset RX if this is a truly fresh enqueue
		if (state !== "active" && state !== "queued") {
			incomingFiles.delete(fileID);
			purgeRXChunks(fileID);
		}

		// Prevent duplicate queue entries
		if (state === "queued" || state === "active") return;

		downloadQueue.push({ fileID, host, fromFolder });
		downloadState.set(fileID, "queued");
		processDownloadQueue();
	}

	//process files till queue full, then pause
	function processDownloadQueue() {
		if (activeFileDownloads >= MAX_PARALLEL_DOWNLOADS) return;

		while (activeFileDownloads < MAX_PARALLEL_DOWNLOADS && downloadQueue.length > 0) {
			const { fileID, host, fromFolder } = downloadQueue.shift();
			if (downloadState.get(fileID) === "active") continue;
			if (downloadState.get(fileID) === "stopped") continue;   
			startFileDownload(fileID, host, fromFolder);
		}
	}

	function startFileDownload(fileID, host, fromFolder) {
		if (downloadState.get(fileID) === "stopped") return; 

		activeFileDownloads++;
		downloadState.set(fileID, "active");

		const meta = files[fileID];
		if (!meta) {
			activeFileDownloads--;
			downloadState.delete(fileID);
			return processDownloadQueue();
		}

		if (fromFolder) meta.fromFolderRequest = true;

		sendToPeer(host, "request-file", {
			id: fileID,
			isFolder: fromFolder
		});

		enableWakeLock();
		log(`Starting download: ${meta.name} - uploaded by : ${meta.uploadedBy}`);
	}

	// // Receiver: cancel a download
	function cancelDownload(fileID) {
		const wasActive = downloadState.get(fileID) === "active";
		const meta = files[fileID];

		if (meta && meta.uploadedBy) {
			sendAbortAck(fileID);
		}

		downloadQueue = downloadQueue.filter(q => q.fileID !== fileID);    // Remove any queued entries for this file
		if (!downloadState) downloadState = new Map();    // Mark paused/cancelled state (use explicit Map for clearer semantics)
		downloadState.set(fileID, "stopped");

		if (incomingFiles[fileID]) delete incomingFiles[fileID];    // Remove partially received buffers & incoming file entry
		updateFileProgressUI(fileID, 0); // or show cancelled state

		// Clear any ack waiters for this file (so host doesn't hang)
		for (const key of Object.keys(ackWaiters)) {
			if (key.startsWith(`${fileID}:`)) {
				try { ackWaiters[key](false); } catch (e) { }
				delete ackWaiters[key];
			}
		}

		if (wasActive) {
			activeFileDownloads--;
			processDownloadQueue();
		}

		clearAckWaitersForFile(fileID)
	}

	function sendAbortAck(fileID) {
		if (downloadState.get(fileID) !== "active") return;

		const meta = files[fileID];
		if (!meta || !meta.uploadedBy) return;

		const incoming = incomingFiles.get(fileID);
		if (!incoming || !incoming.total) return;
		if (incoming.completed) return;

		// ACK every chunk index [0 .. total-1]
		const allParts = Array.from({ length: incoming.total }, (_, i) => i);

		log("Sending cancel to:", meta.uploadedBy, "for file:", meta.name, "total parts:", allParts.length);

		sendToPeer(meta.uploadedBy, "ACK-chunks", {
			fileID,
			parts: allParts
		});
	}

	function clearAckWaitersForFile(fileID) {
		for (const key of Object.keys(ackWaiters)) {
			if (key.startsWith(`${fileID}:`)) {
				try { ackWaiters[key](false); } catch (e) { }
				delete ackWaiters[key];
			}
		}
	}

	function onFileComplete(fileID, blob) {
		let filename = files[fileID]?.name || fileID;

		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = filename;
		a.click();
		URL.revokeObjectURL(url);

		const host = files[fileID]?.uploadedBy;
		sendToPeer(host, "Download-complete", fileID);

		activeStreamers.delete(fileID);

		//mark done + free queue slot
		downloadState.set(fileID, "done");
		activeFileDownloads = Math.max(0, activeFileDownloads - 1);
		markDownloadCompleted(fileID)
		processDownloadQueue();

		log("Download complete:", filename);
	}


</script>