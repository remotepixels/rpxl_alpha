<!doctype html>
<html lang="en">

<head>
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
  <meta http-equiv="Pragma" content="no-cache" />
  <meta http-equiv="Expires" content="-1" />

  <meta name="msapplication-TileColor" content="#2e2e2e" />
  <meta name="description" content="Serverless web app that allows you transmit to a high quality stream to clients to view and comment on using WEBRTC and VDO.NINJA. Communication between clients is handled using low latency and very little bandwidth, dedicating as much bandwidth to the main strea, often the feed from an edit machine. Also, we think Capybara's are awesome though that might not be relevant in this case.">
  <meta name="keywords" content="Gui Felix, Advertising, Visual Effects, Motion Graphics, Remote Pixels, vdo.ninja" />
  <meta name="robots" content="index, follow" />
  <meta name="viewport" content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="color-scheme" content="light dark">

  <link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
  <link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
  <link rel="shortcut icon" href="/icons/favicon.ico">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@200" rel="stylesheet">
  <link rel="stylesheet" href="style.css">

  <title>RPXL | SND</title>
</head>

<body>
  <div id="mainWindow" class="mainWindow">
    <div id="topmenu" class="toolbar top hidden">
      <div class="toolset" id="shareTools"><button class="tool" id="shareBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">ios_share</span></button></div>
      <div class="toolset" id="addTools"><button class="tool" id="addBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">playlist_add</span></button><input id="filePicker" type="file" multiple></div>
      <div class="toolspacer"></div>
      <div class="toolset"><span class="tool toolwider">Peers : <span id="peersList">(0)</span></span></div>
      <div class="toolspacer"></div>
      <div class="toolset"><button class="tool toolmoresettings" id="logBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">terminal</span></button></div>
    </div>

    <div class="logAndFiles">
      <pre class="log hidden" id="log"></pre>

      <div id="subToolBar" class="subtoolbar hidden">
        <span id="transferSpeed">Download: 0 B/s| Upload: 0 B/s </span>
        <span class="toolspacer"></span>
        <span id="filterControls">Show &nbsp;&nbsp;&nbsp;</span>
        <span class="subToolSet filterSet"><button id="filterAll" class="active subTool">All</button><button id="filterLocal" class="subTool">Local</button><button id="filterRemote" class="subTool">Remote</button></span>
        <span class="toolspacer"></span>
        <span id="sortControls">Sort by &nbsp;&nbsp;&nbsp;</span>
        <span class="subToolSet sortSet"><button id="sortByTime" class="active subTool">Latest</button><button id="sortByName" class="subTool">Name</button></span>
      </div>

      <div class="file-list" id="fileList">
        <div id="loadingMessage" class="hidden">Loading files...</div>
      </div>
      <div class="copyCredit"><a href="https://vdo.ninja" target="_blank">Powered by vdo.ninja</a></div>
    </div>
  </div>

  <div id="container"></div>

  <div class="drop" id="dropArea">
    <div class="material-symbols-outlined largeIcon">drive_folder_upload</div>
    <div>
      <h1>Drag & drop files or folders here</h1>
      <h2>(or click to pick)</h2>
    </div>
  </div>
  
  <div style="position:absolute; right:25px; top:25px;   z-index: 101;" id="helpIcon">
    <a href="help.html"><span style="position:absolute; top:10px; right:50px; font-size: 24px;">Help</span><span class="material-symbols-outlined" style="font-size: 48px;">help</span></a>
  </div>

  <!----- Copied links to clipboard ------>
  <div id="popupClipboard" class="toolpopup hidden">
    <div class="material-symbols-outlined largeIcon">assignment_turned_in</div>
    <div><h1>Link copied to clipboard</h1></div>
  </div>
</body>
</html>

<script src="/scripts/vdoninja-sdk.js"></script>

<script lang="javascript">
  //globals
  let iframe = null;
  let connectedPeers = {}; // map streamID -> label
  let roomName = '';
  const files = {}; // id -> {file, name, size, chunks:[], progress}
  let folderMap = {}; // keeps track of folder DOM nodes
  let folderState = {}; // path → true/false
  let currentSort = 'latest'; // default sort method
  let currentFilter = 'all'; // values: 'all' | 'local' | 'remote'
  let localUUID = randomID(20);
  let firstInteraction = true;
  let downloadQueue = [];        // holds pending fileIDs
  let wakeLock = null;

  const dropArea = document.getElementById('dropArea');
  const fileList = document.getElementById('fileList');
  const logEl = document.getElementById('log');
  const peersList = document.getElementById('peersList');
  const shareBtn = document.getElementById('shareBtn');
  const addBtn = document.getElementById('addBtn');
  const filePicker = document.getElementById('filePicker');
  const logBtn = document.getElementById('logBtn');
  const popupClipboard = document.getElementById('popupClipboard');
  const loadingEl = document.getElementById('loadingMessage');

  // Namespace used in messages sent through VDO.Ninja
  const APP_NS = 'SNDRPXL';
  const devURL = window.location.origin;
  const debouncedRerender = debounce(rerenderFileTree, 100);//slow sorting index

//vdo sdk's, 
const vdo = new VDONinjaSDK({
	salt: "rpxl.app",
	allowFallback: false,
	debug: false
});






  //GENERATE RANDOM SID
  function randomID(len = 20) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const arr = new Uint8Array(len);
    crypto.getRandomValues(arr);
    return Array.from(arr, n => chars[n % chars.length]).join('');
  }

  //LOG WINDOW
  function log(...args) {
    console.log(...args);
    logEl.textContent += args.join(' ') + '\n';
    logEl.scrollTop = logEl.scrollHeight;
  }

  log('Local Browser UUID : ', localUUID);
  checkSessionURL();  //autoconnect if session ID in URL

  //CHECK IF THERE IS A CORRECT SID IN THE URL AND AUTOCONNECT
  function checkSessionURL() {
    const queryURL = window.location.search.slice(1);
    const params = new URLSearchParams(queryURL);

    if (params.has('SID')) {
      const SID = params.get('SID');
      roomName = encodeURIComponent(SID);
      if (!roomName || roomName.length !== 20) {
        log('INCORRECTLY FORMATED SESSION ID');
        return;
      } else {
        log('SESSION ID FOUND IN URL:', roomName);
        createIframe(roomName)
        document.getElementById('helpIcon').style.display = "none";
        document.getElementById('shareTools').style.display = "none";
        document.getElementById('dropArea').classList.add('hidden');
        document.getElementById('topmenu').classList.remove('hidden');
        document.getElementById('subToolBar').classList.remove('hidden')
        return;
      }
    } else {
      roomName = randomID(20);
      enableWakeLock(); //if first peer, enable wakelock
      createIframe(roomName);
    }
  }

  //CREATE VDONINJA IFRAME 
  async function createIframe(room) {

	await vdo.connect();
	await vdo.joinRoom({
		room: room,
		mode: "half",
		label: sanitizedCurrentUserName,
		video: false,
		audio: false,
		data: true,
	})

    // if (iframe) iframe.remove();
    // const container = document.getElementById('container');
    // iframe = document.createElement('iframe');
    // iframe.allow = 'camera;microphone;fullscreen;display-capture;autoplay;';
    // iframe.src = `https://alpha.rpxl.app/vdo/?director=${room}&push=${localUUID}&cleanish&datamode`;
    // Object.assign(iframe.style, { width: "100%", height: "200px", position: "fixed", bottom: "0px", overflow: "auto", display: "none"});
    // container.appendChild(iframe);
    log('Joined room :', room);
  }

  //WAKE LOCK TO PREVENT SLEEPING DURING LARGE TRANSFERS
  async function enableWakeLock() {
    try {
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => {
       //console.log("Wake Lock was released");
      });
      //console.log("Wake Lock active");
    } catch (err) {
      console.error(`${err.name}, ${err.message}`);
    }
  }

  async function disableWakeLock() {
    if (!wakeLock) return;
    try {
      await wakeLock.release();
      wakeLock = null;
      //console.log("Wake Lock disabled");
    } catch (err) {
      console.error(err);
    }
  }

  // If the tab regains focus, re-request wake lock
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden && wakeLock) {
      enableWakeLock();
    }
  });

  //SETUP CROSS BROWSER EVENT LISTENER
  var eventMethod = window.addEventListener ? "addEventListener" : "attachEvent";
  var eventer = window[eventMethod];
  var messageEvent = eventMethod === "attachEvent" ? "onmessage" : "message";

  //EVENT LISTENER FOR MESSAGES FROM VDONINJA IFRAME
  eventer(messageEvent, function (e) {
    if (e.data.action != "view-stats-updated") {
      //log everything except the "view-stats" messages
      //console.log("iframeMessage rec---", e);
    };
    if (e.source !== iframe.contentWindow) return;

    //CONNECTION EVENTS
    if ("action" in e.data) {
      handleAction(e.data);  // delegate all connection/peer actions
    }

    let msg = null;

    //Most common incoming broadcast
    if (e.data?.dataReceived?.[APP_NS]) {
      msg = e.data.dataReceived[APP_NS];
    }
    //Fallback: sendData wrapper (peer-targeted PCS)
    else if (e.data?.sendData?.[APP_NS]) {
      msg = e.data.sendData[APP_NS];
    }
    //Deep fallback for nested quirks
    else if (e.data?.dataReceived?.sendData?.[APP_NS]) {
      msg = e.data.dataReceived.sendData[APP_NS];
    }

    if (!msg) return; // nothing to process

    const dt = msg.dataType;
    const payload = msg.payload;

    switch (msg.dataType) {
      //file and directory listing and removal
      case 'file-announce': {
        if (payload.uploadedBy === localUUID) break;        //Ignore files that were uploaded by yourself
        if (files[payload.id]) break;        //Optionally ignore duplicates if already have this file

        files[payload.id] = {
          id: payload.id,
          name: payload.name,
          size: payload.size,
          folderPath: payload.folderPath || '',
          timestamp: payload.timestamp,
          uploadedBy: payload.uploadedBy || null
        };
        debouncedRerender()
        log(`Received file meta : ${payload.folderPath} / ${payload.name} - from ${payload.uploadedBy}`);
        break;
      }
      case 'file-removed': {
        const id = payload.id;
        const file = files[id];
        if (file) {
          delete files[id];
          const el = document.querySelector(`.file-item[data-id="${id}"]`);
          removeElementWithFade(el);
          log(`File removed remotely: ${file.name}`);
          cleanupEmptyFolders(file.folderPath);
        }
        break;
      }
      case 'directory-removed': {
        const path = payload.path;
        log(`Directory removed remotely: ${path}`);

        // Remove files inside folder first
        for (const id of Object.keys(files)) {
          if (files[id].folderPath.startsWith(path)) {
            delete files[id];
            const el = document.querySelector(`.file-item[data-id="${id}"]`);
            removeElementWithFade(el);
          }
        }
        // Now remove the folder itself
        const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
        removeElementWithFade(folderDiv);
        delete folderMap[path];
        
        cleanupEmptyFolders(path);
        break;
      }
      case 'request-file': {
        const fileMeta = files[payload.id];
        log(`file requested: ${fileMeta?.folderPath || ''} / ${fileMeta?.name || payload.id} from host : ${fileMeta?.uploadedBy} -> by: ${payload.requester}`);
        enableWakeLock();
        respondToFileRequest(payload.id, payload.requester);
        break;
      }
      case 'file-chunk': {
        handleIncomingChunk(payload);
        break;
      }
      case "chunk-group-ack": {
        //console.log("ACK received for group", payload.groupIndex, "file", payload.id);
        handleChunkGroupAck(payload); 
        break;
      }
      case 'request-missing': {
        if (outgoingFiles[payload.id]) {
          try {
            handleRequestMissing(payload)
            //console.log("Requesting missing chunks")
          } catch (err) {
            console.error('Failed resend chunk', idx, err);
          }
        }
        break;
      }
      case "file-transfer-complete": {
        const { from, filename } = payload;
        log(`Received file-transfer-complete from ${from} → ${filename}`);
        break;
      }
      case 'file-not-found': {
        log('Peer reports file not found:', payload.id);
        break;
      }
      case 'file-transfer-error': {
        log('Peer transfer error:', payload.message);
        break;
      }
      case "stop-download": {
        const { id, from } = payload;
        pausedUploads[id] = "stop";    // mark pausedUploads as stop — sendChunksToPeer will pick this up and return
        if (outgoingFiles[id]) delete outgoingFiles[id];
        if (activeFileDownloads > 0) activeFileDownloads--;

        log(`Receiver ${from} requested cancel for upload ${id}`);
        break;
      }
      default:
        console.warn('Unhandled dataType', dt, payload);
    }
  }, false);

  //USER 'ACTION EVENTS' FOR USER CONNECTS AND DISCONNECTS 
  function handleAction(data) {
    if (!data.action) return;
    switch (data.action) {
      case 'guest-connected': {
        connectedPeers[data.streamID] = data.value?.label || "Guest";
        log("Guest connected:", data.streamID);
        updatePeersUI();
        handleGuestJoin(data.streamID);
        break;
      }
      case 'push-connection': {
        if (data.value === false && data.streamID) {
          log("Guest disconnected:", data.streamID);
          delete connectedPeers[data.streamID];
          removePeerFiles(data.streamID);
          updatePeersUI();
        }
        break;
      }
      case 'view-connection': {
        if (data.value) {
          connectedPeers[data.streamID] = "Viewer";
          handleGuestJoin(data.streamID);
        } else {
          delete connectedPeers[data.streamID];
          removePeerFiles(data.streamID);
        }
        updatePeersUI();
        break;
      }
      default:
      //console.warn('Unhandled connection action', data.action);
    }
  }

  //SEND FILE LIST TO USER WHEN THEY CONNECT (AFTER. SHORT DELAY)
  async function handleGuestJoin(guestUUID) {
    loadingEl.classList.remove('hidden');
    await sleep(500);    // delay to ensure the peer connection is ready
    const ids = Object.keys(files);

    if (ids.length === 0) {
      log('No files to send.');
      return;
    }
    log(`Auto-sending ${ids.length} files to new guest ${guestUUID}...`);

    for (const id of ids) {
      const meta = files[id];
      sendToPeer(guestUUID, "file-announce", meta);
    }
    // Optionally wait for all announcements to process
    await sleep(500 * ids.length); // small buffer for debounced rendering
    loadingEl.classList.add('hidden');    // Hide loading message once file list is rendered
  }

  //UPDATE THE CONNECTED PEERS COUNT IN UI
  function updatePeersUI() {
    const total = Object.keys(connectedPeers).length;

    peersList.textContent = total === 0
      ? '(0)'
      : `(${total})`;
  }

  //REMOVE ANY FILES THE PEER HAS UPLOADED IF THEY DISCONNECT
  function removePeerFiles(peerUUID) {
    // Collect IDs of files uploaded by the disconnected peer
    const toRemove = Object.values(files)
      .filter(f => f.uploadedBy === peerUUID)
      .map(f => f.id);

    for (const id of toRemove) {
      const fileMeta = files[id];
      const folderPath = fileMeta.folderPath; // save for cleanup
      delete files[id];      // Remove from files object

      // Remove from DOM
      const fileDiv = document.getElementById(`data-${id}`);
      if (fileDiv) fileDiv.remove();

      cleanupEmptyFolders(folderPath);
    }
  }

  //INTERFACE
  //share
  shareBtn.addEventListener('pointerdown', () => {
    navigator.clipboard.writeText(`${devURL}/snd/?SID=${roomName}`);
    popupClipboard.classList.remove("hidden");
    setTimeout(() => {
      popupClipboard.classList.add("hidden");
    }, 2000);
  });
  //show log window
  logBtn.addEventListener('pointerdown', () => {
    document.getElementById('log').classList.toggle('hidden');
  });
  //sets active filter button
  function setActiveButton(groupSelector, activeId) {
    document.querySelectorAll(groupSelector + ' .subTool').forEach(btn => {
      btn.classList.toggle('active', btn.id === activeId);
    });
  }
  // Filter - all
  document.getElementById('filterAll').addEventListener('click', () => {
    currentFilter = 'all';
    setActiveButton('.filterSet', 'filterAll');
    debouncedRerender();
  });
  // Filter - local
  document.getElementById('filterLocal').addEventListener('click', () => {
    currentFilter = 'local';
    setActiveButton('.filterSet', 'filterLocal');
    debouncedRerender();
  });
  // Filter - remote
  document.getElementById('filterRemote').addEventListener('click', () => {
    currentFilter = 'remote';
    setActiveButton('.filterSet', 'filterRemote');
    debouncedRerender();
  });
  // Sort - latest
  document.getElementById('sortByTime').addEventListener('click', () => {
    currentSort = 'latest';
    setActiveButton('.sortSet', 'sortByTime');
    rerenderFileTree();
  });
  // Sort - name
  document.getElementById('sortByName').addEventListener('click', () => {
    currentSort = 'name';
    setActiveButton('.sortSet', 'sortByName');
    rerenderFileTree();
  });

  //DRAG AND DROP AND FILE ADDING HANDLING
  addBtn.addEventListener("click", () => {
    filePicker.click();
  });
  // Always handle picking files on both desktop + mobile
  filePicker.addEventListener("change", (event) => {
    const files = event.target.files;

    for (let i = 0; i < files.length; i++) {
      const file = files[i];

      if (file.webkitRelativePath && file.webkitRelativePath !== "") {
        file.relativePath = file.webkitRelativePath;
      } else {
        file.relativePath = file.name;
      }

      if (!isHiddenFile(file)) addFile(file);
    }

    firstInteraction = false;

    document.getElementById('dropArea').classList.add('hidden');
    document.getElementById('dropArea').style.pointerEvents = "none";
    document.getElementById('helpIcon').style.display = "none";

    document.getElementById('topmenu').classList.remove('hidden');
    document.getElementById('subToolBar').classList.remove('hidden');
  });

  //check if desktop, set up drag and drop UI
  const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

  if (!isMobile) {
    //set for desktop (folders and drag drop)
    filePicker.setAttribute('webkitdirectory', "");
    filePicker.setAttribute('directory', "");

    dropArea.addEventListener('click', () => {
      if (!firstInteraction) return;
      filePicker.click();
    });

    const dropOverlay = document.getElementById('dropArea');
    let dragCounter = 0; // helps handle nested dragenter/dragleave events

    window.addEventListener('dragenter', (e) => {
      e.preventDefault();
      dragCounter++;
      dropOverlay.classList.add('dragover');
    });

    window.addEventListener('dragleave', (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) dropOverlay.classList.remove('dragover');
    });

    window.addEventListener('dragover', (e) => {
      e.preventDefault();
    });

    window.addEventListener('drop', (e) => {
      e.preventDefault();
      dragCounter = 0;
      dropOverlay.classList.remove('dragover');
    });

    dropArea.addEventListener('drop', async (e) => {
      e.preventDefault();

      const items = e.dataTransfer.items;
      if (!items) return handleFileList(e.dataTransfer.files);

      // Hide drop area after 1st drop
      document.getElementById('dropArea').classList.add('hidden');
      document.getElementById('helpIcon').style.display = "none";
      document.getElementById('topmenu').classList.remove('hidden');
      document.getElementById('subToolBar').classList.remove('hidden');

      const promises = [];    // Process all top-level entries concurrently

      for (let i = 0; i < items.length; i++) {
        const it = items[i];
        const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
        if (!entry) {
          if (it.getAsFile) addFile(it.getAsFile());
          continue;
        }

        if (entry.isDirectory) {
          promises.push(readDirectory(entry));
        } else if (entry.isFile) {
          // Wrap entry.file in a promise so we can await it
          promises.push(new Promise(resolve => entry.file(file => {
            addFile(file);
            resolve();
          })));
        }
      }

      await Promise.all(promises);  // Wait for all top-level items to finish
    });
  } else {
    //if mobile only allow multiple files and not folders (safer)
    filePicker.removeAttribute('webkitdirectory');
    filePicker.removeAttribute('directory');

    dropArea.classList.add('hidden');
    dropArea.style.display = "none";

    document.getElementById('topmenu').classList.remove('hidden');
    document.getElementById('subToolBar').classList.remove('hidden');
  }

  //PROCESS SINGLE FILE ENTRY 
  function readFileEntry(fileEntry, path = '') {
    return new Promise((resolve, reject) => {
      fileEntry.file(file => {
        if (!file) return resolve(); // safety check

        file.relativePath = path + file.name;

        if (!isHiddenFile(file)) addFile(file);

        resolve();
      }, reject);
    });
  }

  //READ DIRECTORY 
  async function readDirectory(dirEntry, path = '') {
    const reader = dirEntry.createReader();

    const readEntries = () => new Promise((res, rej) => reader.readEntries(res, rej));
    let entries = await readEntries();

    while (entries.length) {
      for (const e of entries) {
        if (e.isDirectory && !e.name.startsWith('.')) {
          await readDirectory(e, path + dirEntry.name + '/');
        } else if (e.isFile) {
          await readFileEntry(e, path + dirEntry.name + '/');
        }
      }
      entries = await readEntries();
    }
  }

  //HANDLE FILE LIST (fallback)
  function handleFileList(list) {
    for (let i = 0; i < list.length; i++) {
      const file = list[i];
      if (!isHiddenFile(file)) addFile(file);
      else log(`Skipping hidden file: ${file.name}`);
    }
  }

  //HIDDEN FILE FILTER 
  function isHiddenFile(pathOrFile) {
    let path = "";

    if (typeof pathOrFile === "string") path = pathOrFile;
    else if (pathOrFile.webkitRelativePath) path = pathOrFile.webkitRelativePath;
    else if (pathOrFile.relativePath) path = pathOrFile.relativePath;
    else path = pathOrFile.name || "";

    if (!path) return true;

    return path.split('/').some(part => part.startsWith('.') && part.length > 1);
  }

  //ADD FILE 
  function addFile(file) {
    if (!file) return;

    const id = generateId();
    const relativePath = file.relativePath || file.name;    // Use relativePath if available, otherwise fallback to file name
    const pathParts = relativePath.split('/');    // Split relative path into folder path + file name
    const fileName = pathParts.pop();
    const folderPath = pathParts.join('/');

    files[id] = {
      id,
      name: fileName,
      size: file.size,
      folderPath,        // preserves folder hierarchy
      uploadedBy: localUUID,
      timestamp: Date.now(),
      file
    };

    debouncedRerender();  // update UI
    log(`Added: ${relativePath} (${formatBytes(file.size)})`);
    sendFile(id);    // Notify peers
  }

  //SEND FILE (TO PEER OR BROADCAST)
  function sendFile(id, targetStreamID = null) {
    const meta = files[id];
    if (!meta) return;

    const payload = {
      id: meta.id,
      name: meta.name,
      size: meta.size,
      folderPath: meta.folderPath,
      uploadedBy: meta.uploadedBy,
      timestamp: meta.timestamp
    };

    if (targetStreamID) {
      sendToPeer(targetStreamID, "file-announce", payload);
    } else {
      sendBroadcast("file-announce", payload);
    }
  }

  //SEND TO SPECIFIC PEER (STREAMID)
  function sendToPeer(targetStreamID, dataType, payload = {}) {
    const msg = {
      sendData: {
        [APP_NS]: {
          dataType,
          payload
        }
      },
      type: "pcs",
      streamID: targetStreamID
    };

    iframe.contentWindow.postMessage(msg, "*");
    //console.log("sendToPeer →", msg);
  }

  //send to all peers (connects, disconnects, adding or removing files)
  function sendBroadcast(dataType, payload = {}) {
    const msg = {
      sendData: {
        [APP_NS]: {
          dataType,
          payload
        }
      },
      // type: "pcs"
    };

    iframe.contentWindow.postMessage({
      sendData: msg,
      type: "pcs" // Use peer connection for reliability
    }, "*");
    //console.log("sendbroadcast", msg)
  }

  //SORT FILES BY LATEST (DEFAULT) OR NAME
  //stops sort operation running to often
  function debounce(fn, delay) {
    let timer = null;
    return (...args) => {
      clearTimeout(timer);
      timer = setTimeout(() => fn(...args), delay);
    };
  }

  //SORTS THE FILETREE BY DATE/NAME LOCAL/REMOTE OR ALL
  function rerenderFileTree() {
    const treeRoot = document.getElementById('fileList');

    //Save folder expand/collapse state
    folderState = {};
    for (const path in folderMap) {
      const folderDiv = folderMap[path]?.closest('.folder');
      if (!folderDiv) continue;
      const contents = folderDiv.querySelector('.folder-contents');
      //folderState[path] = contents && contents.style.display !== 'none';
      folderState[path] = contents.classList.contains('open');
    }

    //Clear tree
    treeRoot.innerHTML = '';
    folderMap = {};

    //Sort latest / name
    const fileArray = Object.values(files);
    if (currentSort === 'name') {
      fileArray.sort((a, b) => a.name.localeCompare(b.name));
    } else {
      fileArray.sort((a, b) => b.timestamp - a.timestamp);
    }
    //Apply filter all / local / remote
    let filtered = fileArray;

    if (currentFilter === 'local') {
      filtered = filtered.filter(f => f.uploadedBy === localUUID);
    }
    else if (currentFilter === 'remote') {
      filtered = filtered.filter(f => f.uploadedBy !== localUUID);
    }
    //Rebuild
    for (const f of filtered) {
      renderTreeItem(f);
    }

    for (const path in folderState) {
      const contents = folderMap[path];
      if (!contents) continue;

      if (folderState[path]) {
        contents.classList.add('open');
      } else {
        contents.classList.remove('open');
      }
    }

  }

  //BUILDS THE FILE TREE
  function renderTreeItem(f) {
    const isReceiver = f.uploadedBy !== localUUID; // true if file came from another peer
    const treeRoot = document.getElementById('fileList');
    const pathParts = f.folderPath ? f.folderPath.split('/') : [];
    let currentContainer = treeRoot;
    let currentPath = '';

    for (let depth = 0; depth < pathParts.length; depth++) {
      const part = pathParts[depth];
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!folderMap[currentPath]) {
        const folderDiv = document.createElement('div');
        folderDiv.className = 'folder ' + (isReceiver ? 'remote' : 'local');
        folderDiv.dataset.path = currentPath;

        // Apply indentation
        folderDiv.style.marginLeft = `${depth * 20}px`; // 20px per level

        const iconType = isReceiver ? 'folder-download' : 'folder-delete';
        const iconLabel = isReceiver ? 'download' : 'delete';

        folderDiv.innerHTML = `
        <div class="folder-header" data-folder="${currentPath}">
          <span class="material-symbols-outlined folder-icon">folder</span>
          <strong class="folder-text">${escapeHtml(part)}</strong>
          <span class="material-symbols-outlined ${iconType}">${iconLabel}</span>
        </div>
        <div class="folder-contents"></div>
      `;

        currentContainer.appendChild(folderDiv);
        folderMap[currentPath] = folderDiv.querySelector('.folder-contents');

        // Expand/collapse folder
        folderDiv.querySelector('.folder-header').addEventListener('pointerdown', (e) => {
          if (e.target.classList.contains(iconType)) return;
          const contents = folderDiv.querySelector('.folder-contents');
          contents.classList.toggle('open');
          folderState[currentPath] = contents.classList.contains('open');
        });

        // Folder action
        folderDiv.querySelector(`.${iconType}`).addEventListener('pointerdown', async (e) => {
          e.stopPropagation();
          const folderPath = e.target.closest('.folder-header').dataset.folder;
          if (isReceiver) {
            requestDownload(folderPath, true);
          } else {
            if (confirm(`Remove entire directory "${folderPath}" and all its files from share?`)) {
              await deleteDirectory(folderPath);
              sendDirectoryRemoved(folderPath);
            }
          }
        });
      }
      currentContainer = folderMap[currentPath];
    }

    // Create file entry
    const fileDiv = document.createElement('div');
    fileDiv.className = 'file-item ' + (isReceiver ? 'remote' : 'local');
    fileDiv.id = `data-${f.id}`;
    fileDiv.dataset.id = f.id;
    //style object
    Object.assign(fileDiv.style, {display: 'flex', justifyContent: "space-between", alignItems: "center", padding: "2px 10px", marginLeft: `${pathParts.length}px`})

    const fileIconClass = isReceiver ? 'file-download' : 'file-delete';
    const fileIconLabel = isReceiver ? 'download' : 'delete';

    fileDiv.innerHTML = `
    <span class="file-name">${escapeHtml(f.name)}</span>
    <span class="file-size">${formatBytes(f.size)}</span>
    <span class="file-icon-container" id="icon-container_${f.id}">
      <span class="material-symbols-outlined ${fileIconClass}" id="${f.id}_icon">${fileIconLabel}</span>
    </span>
  `;

    currentContainer.appendChild(fileDiv);

    // File action
    fileDiv.querySelector(`.${fileIconClass}`).addEventListener('pointerdown', async (e) => {
      e.stopPropagation();
      if (isReceiver) {
        requestDownload(f.id, false);
      } else {
        deleteFile(f.id);
      }
    });
  }

  //FILE AND FOLDER DELETES
  // Animate when deleted and return a Promise that resolves after removal
  function removeElementWithFade(el) {
    return new Promise((resolve) => {
      if (!el) return resolve(); // nothing to remove

      el.offsetHeight;       // Trigger reflow so transition always runs
      el.classList.add('fade-slide-out');

      el.addEventListener('transitionend', () => {
        if (el.parentNode) el.parentNode.removeChild(el);
        resolve(); // resolve after removal
      }, { once: true });

      // Fallback in case transitionend doesn't fire
      setTimeout(() => {
        if (el.parentNode) el.parentNode.removeChild(el);
        resolve();
      }, 500); // CSS transition duration
    });
  }

  //REMOVE DIRECTORY(S)
  async function deleteDirectory(path) {
    if (!path) return;
    log(`Deleting directory: ${path}`);

    // Find all file IDs inside that folder (recursively)
    const toDelete = Object.keys(files).filter(id =>
      files[id].folderPath.startsWith(path)
    );

    // Delete contained files
    for (const id of toDelete) {
      const el = document.querySelector(`.file-item[data-id="${id}"]`);
      removeElementWithFade(el);
      await sendFileRemoved(id, path);
      delete files[id];
    }

    // Remove the folder DOM
    const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
    if (folderDiv) folderDiv.remove();

    delete folderMap[path];    // Remove from folderMap
    await sendDirectoryRemoved(path);    //announce directory removal to peers
    cleanupEmptyFolders(path);    //clean any now-empty parents
  }

  //ANNOUNCE DIRECTORY REMOVAL TO ALL PEERS
  async function sendDirectoryRemoved(path, targetUUID = null) {
    const peerKeys = Object.keys(connectedPeers);
    if (peerKeys.length === 0) return;      //console.log("No connected guests");

    sendBroadcast("directory-removed", { path });
    log(`Announced directory removal: ${path}`);
  }

  async function deleteFile(id) {
    const file = files[id];
    if (!file) return;

    const folderPath = file.folderPath || '';
    delete files[id];
    const el = document.querySelector(`.file-item[data-id="${id}"]`);

    if (el) await removeElementWithFade(el);

    log(`Deleted file : / ${folderPath} / ${file.name}`);
    cleanupEmptyFolders(folderPath);
    await sendFileRemoved(id, folderPath);
  }

  //ANNOUNCE FILE REMOVAL TO ALL PEERS
  async function sendFileRemoved(id, path) {
    const total = Object.keys(connectedPeers).length;
    if (total == 0) return;

    sendBroadcast("file-removed", { id });
    log(`Announced file removal : `, id);
  }

  //CLEANUP AND REMOVE ANY EMPTY FOLDERS
  function cleanupEmptyFolders(startPath = null) {
    function isEmptyFolder(folderDiv) {
      const contents = folderDiv.querySelector('.folder-contents');
      if (!contents) return true;

      // Check if contents has any visible file-items or folder divs
      const children = Array.from(contents.children).filter(
        el => el.classList.contains('file-item') || el.classList.contains('folder')
      );

      return children.length === 0;
    }

    if (startPath) {
      let parts = startPath.split('/');
      while (parts.length > 0) {
        const currentPath = parts.join('/');
        const folder = document.querySelector(`.folder[data-path="${currentPath}"]`);
        if (folder && isEmptyFolder(folder)) {
          log(`Removing empty folder: ${currentPath}`);
          folder.remove();
          delete folderMap[currentPath];
        }
        parts.pop(); // move up
      }
    } else {
      const folders = document.querySelectorAll('.folder');
      for (const folder of folders) {
        if (isEmptyFolder(folder)) {
          const path = folder.dataset.path;
          log(`Removing empty folder: ${path}`);
          folder.remove();
          delete folderMap[path];
        }
      }
    }
  }

  //FILE DOWNLOAD UI, CIRCLE, RESTORE BACK AND CALC DL SPEED PROGRESS BARS
  function createFileProgressUI(id) {
    const container = document.getElementById(`icon-container_${id}`);
    if (!container) return;

    // Clear previous content and insert progress UI
    container.innerHTML = `
    <div class="roundProgressBarBG">
      <div class="roundProgressBarFill" id="progress-bar-${id}"></div>
      <div class="roundProgressBarCenter">
        <div class="stop-btn" id="stop-btn-${id}">✕</div>
      </div>
    </div>
  `;

    const stopBtn = document.getElementById(`stop-btn-${id}`);
    if (!stopBtn) return;
    // Style stop button
    Object.assign(stopBtn.style, {position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", cursor: "pointer", fontSize: "0.8em", userSelect: "none", opacity: "0.5"});

    // Stop button handler
    stopBtn.addEventListener("pointerdown", () => {
      log(`Stopping download: ${id}`);

      // stop local
      pausedDownloads.delete(id);
      delete incomingFiles[id];
      downloadQueue = downloadQueue.filter(job => job.fileID !== id);      // remove from queue

      // restore icon cleanly
      restoreDownloadIcon(id);
      cancelDownload(id)
    });
  }
  //if transfer is cancelled 
  function restoreDownloadIcon(id) {
    const container = document.getElementById(`icon-container_${id}`);
    if (!container) return;

    // Restore original icon
    container.innerHTML = `
    <span class="material-symbols-outlined file-download" id="${id}_icon">download</span>
  `;

    const icon = document.getElementById(`${id}_icon`);
    if (!icon) return;

    // Reattach the normal download behavior
    icon.addEventListener("pointerdown", (e) => {
      e.stopPropagation();
      requestDownload(id, false);
      createFileProgressUI(id);
    });
  }

  function markDownloadCompleted(id) {
    const fileEl = document.getElementById(`icon-container_${id}`);
    if (!fileEl) return;

    fileEl.classList.add("download-complete");

    // Set progress visually to 100%
    const bar = fileEl.querySelector(".progress-bar");
    if (bar) bar.style.backgroundImage = `conic-gradient(dodgerblue 359deg, light-dark(var(--color-light-white), var(--color-dark-grey)) 359deg)`;

    // Replace stop button with ✓ icon (but keep clickable)
    const btn = document.getElementById(`stop-btn-${id}`);
    if (btn) {
      btn.dataset.originalIcon = btn.innerHTML;   // store original
      btn.innerHTML = "✓";                         // completed icon
      btn.classList.add("completed");

      // Clicking ✓ restores original download button
      btn.onclick = () => {
        btn.innerHTML = btn.dataset.originalIcon;
        btn.classList.remove("completed");
        fileEl.classList.remove("download-complete");
        btn.onclick = () => handleFileDownload(id);         // restore original handler
      };
    }
  }

  function updateFileProgressUI(id, percent) {
    const bar = document.getElementById(`progress-bar-${id}`);
    if (!bar) return; // safely ignore if element removed
    if (pausedDownloads.has(id)) return;

    const pct = Math.max(0, Math.min(100, Number(percent) || 0));
    const deg = pct * 3.6; // 100% -> 360°
    bar.style.backgroundImage = `conic-gradient(dodgerblue ${deg}deg, light-dark(var(--color-light-white), var(--color-dark-grey)) ${deg}deg)`;
  }

  //CALCULATE AND SHOW SPEED OF DOWNLOAD / UPLOAD
  let bytesReceivedInInterval = 0;
  let bytesSentInInterval = 0;
  // Called whenever a chunk is received
  function onChunkReceived(chunkSize) {
    bytesReceivedInInterval += chunkSize;
  }
  // Called whenever a chunk is sent
  function onChunkSent(chunkSize) {
    bytesSentInInterval += chunkSize;
  }
  function formatSpeed(bytes) {
    if (bytes > 1e6) return (bytes / 1e6).toFixed(2) + " MB/s";
    if (bytes > 1e3) return (bytes / 1e3).toFixed(2) + " KB/s";
    return bytes + " B/s";
  }
  //update every 500ms
  setInterval(() => {
    const downloadSpeed = formatSpeed(bytesReceivedInInterval * 2); // interval 500ms → scale to 1s
    const uploadSpeed = formatSpeed(bytesSentInInterval * 2);
    document.getElementById("transferSpeed").textContent = `Download: ${downloadSpeed} | Upload: ${uploadSpeed}`;
    // Reset counters
    bytesReceivedInInterval = 0;
    bytesSentInInterval = 0;
  }, 500);

  // UTILITY, CREATE FILE ID'S, NICE FORMAT SIZE AND REMOVE ANY FUNNY CHARACTERS
  function generateId() { return Math.random().toString(36).slice(2, 10); }
  function formatBytes(a) { if (a === 0) return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const e = Math.floor(Math.log(a) / Math.log(1024)); return (a / Math.pow(1024, e)).toFixed(2) + ' ' + units[e]; }
  function escapeHtml(s) { return String(s).replace(/[&<>\"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" })[c]); }

  function arrayBufferToBase64(buffer) {
    const bytes = new Uint8Array(buffer);
    let binary = "";
    for (let i = 0; i < bytes.length; i += 0x8000) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + 0x8000));
    }
    return btoa(binary);
  }

  function base64ToArrayBuffer(base64) {
    const bin = atob(base64);
    const len = bin.length;
    const out = new Uint8Array(len);
    for (let i = 0; i < len; i++) out[i] = bin.charCodeAt(i);
    return out.buffer;
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  //////////////////////////////////////////////////////////////////////////////
  //  FILE TRANSFER ENGINE
  const FILE_CHUNK_BYTES = 128 * 1024;  //128 seems to be upper liimit chrome / safari / firefox
  const GROUP_SIZE = 64;             //how many chunks to send before waiting for ack 128 seems to be upper liimit
  const ACK_TIMEOUT_MS = 3000;
  const MAX_CHUNK_RETRIES = 3;
  const CHUNK_SEND_DELAY = 1;     //delay to not flood RTC channel minimum 1ms
  let activeFileDownloads = 0;     //how many are running
  const MAX_PARALLEL_DOWNLOADS = 6; // 
  const outgoingFiles = {};
  const incomingFiles = {};
  const pausedDownloads = new Set(); // holds fileIDs of paused downloads
  const pausedUploads = {};  // sender-side pause flags
  const ackWaiters = {}; // key = `${id}:${group}` -> resolve()
  
  // RECEIVER REQUESTS FILE
  function requestDownload(fileID, isFolder = false) {

    //FOLDER DOWNLOAD HANDLED FIRST
    if (isFolder) {
      const folderPath = fileID;  // fileID *is* a folder path here
      log(`Requesting folder : ${folderPath}`);

      // Find all files whose folderPath starts with this folder
      const fileIDs = Object.keys(files).filter(id =>
        files[id].folderPath.startsWith(folderPath)
      );

      for (const id of fileIDs) {
        const meta = files[id];
        const hostStreamID = meta.uploadedBy;

        queueDownload(id, hostStreamID, true);
        createFileProgressUI(id);
      }
      return;
    }
    //SINGLE FILE DOWNLOAD
    const meta = files[fileID];
    if (!meta) return log("requestDownload: no such file");

    log(`Requesting file : ${fileID}`);
    const hostStreamID = meta.uploadedBy;
    queueDownload(fileID, hostStreamID, false);
    createFileProgressUI(fileID);
  }

  // HOST RECEIVES REQUEST → starts sending
  async function respondToFileRequest(fileID, requesterStreamID) {
    if (!fileID || !requesterStreamID) return;

    const meta = files[fileID];
    const file = meta?.file;

    if (pausedUploads[fileID]) delete pausedUploads[fileID];

    if (!file) {
      sendToPeer(requesterStreamID, "file-not-found", { id: fileID });
      return;
    }

    const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);

    outgoingFiles[fileID] = {
      id: fileID,
      file,
      meta,
      totalChunks,
      groupStatus: {}
    };

    activeFileDownloads++;

    try {
      await sendChunksToPeer(fileID, requesterStreamID);
    } catch (err) {
      sendToPeer(requesterStreamID, "file-transfer-error", {
        id: fileID,
        message: err.message || "Unknown error"
      });
    } finally {
      delete outgoingFiles[fileID];
      activeFileDownloads--;
    }
  }

  async function sendChunksToPeer(fileID, targetUUID) {
    const of = outgoingFiles[fileID];
    if (!of) return;

    const file = of.file;
    const totalChunks = Math.ceil(file.size / FILE_CHUNK_BYTES);
    const groupCount = Math.ceil(totalChunks / GROUP_SIZE);

    for (let group = 0; group < groupCount; group++) {
      let acknowledged = false;

      for (let attempt = 0; attempt <= MAX_CHUNK_RETRIES; attempt++) {
        const start = group * GROUP_SIZE;
        const end = Math.min(totalChunks, start + GROUP_SIZE);

        // send each chunk in the group
        for (let idx = start; idx < end; idx++) {
          if (pausedUploads[fileID] === "stop") throw new Error("upload-stopped-by-host");

          const s = idx * FILE_CHUNK_BYTES;
          const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
          const buf = await file.slice(s, e).arrayBuffer();
          onChunkSent(buf.byteLength);
          sendToPeer(targetUUID, "file-chunk", {
            id: fileID,
            index: idx,
            totalChunks,
            buffer: arrayBufferToBase64(buf),
            from: localUUID,
            target: targetUUID
          });
          await sleep(CHUNK_SEND_DELAY);
        }

        acknowledged = await waitForGroupAck(fileID, group, targetUUID);        // wait for ACK for this group
        if (acknowledged) break;
      }
      if (!acknowledged) throw new Error(`Group ${group} failed`);
    }
    sendToPeer(targetUUID, "file-transfer-complete", { id: fileID, totalChunks });
  }

  function waitForGroupAck(id, group, fromUUID) {
    return new Promise(resolve => {
      const key = `${id}:${group}`;
      ackWaiters[key] = resolve;

      setTimeout(() => {
        if (ackWaiters[key]) {
          delete ackWaiters[key];
          resolve(false);
        }
      }, ACK_TIMEOUT_MS);
    });
  }

  // RECEIVER HANDLES CHUNK
  async function handleIncomingChunk(payload) {
    const { id, index, totalChunks, buffer, target, from } = payload;

    if (target !== localUUID) return;

    const chunkSize = base64ToArrayBuffer(buffer).byteLength;
    onChunkReceived(chunkSize);  //track received bytes

    if (!incomingFiles[id]) {
      incomingFiles[id] = {
        id,
        totalChunks,
        buffers: {},
        received: 0,
        sender: from
      };
    }

    const inf = incomingFiles[id];

    // Store chunk if first time
    if (!inf.buffers[index]) {
      inf.buffers[index] = buffer;
      inf.received++;

      const percent = (inf.received / inf.totalChunks) * 100;
      updateFileProgressUI(id, percent);
    }

    const group = Math.floor(index / GROUP_SIZE);    // Determine group

    //handle group ACK
    if (isGroupComplete(inf, group)) {
      sendToPeer(from, "chunk-group-ack", {
        id,
        groupIndex: group,
        from: localUUID
      });
    }
    //check full file complete
    if (inf.received === inf.totalChunks) {
      finalizeIncomingFile(id);
    }
  }

  function isGroupComplete(file, group) {
    const start = group * GROUP_SIZE;
    const end = Math.min(file.totalChunks, start + GROUP_SIZE);
    for (let i = start; i < end; i++) {
      if (!file.buffers[i]) return false;
    }
    return true;
  }

  // RECEIVER SENDS GROUP ACK → notify sender
  function handleChunkGroupAck(payload) {
    const { id, groupIndex } = payload;
    const key = `${id}:${groupIndex}`;

    if (ackWaiters[key]) {
      ackWaiters[key](true);
      delete ackWaiters[key];
    }
  }

  //DOWNLOAD QUEUE
  // Use a Map to track each file's download state: "queued", "active", "stopped", "done"
  let downloadState = new Map();

  function queueDownload(fileID, hostStreamID, fromFolder = false) {
    downloadQueue.push({ fileID, hostStreamID, fromFolder });
    downloadState.set(fileID, "queued");
    processDownloadQueue();
  }

  function processDownloadQueue() {
    if (activeFileDownloads >= MAX_PARALLEL_DOWNLOADS) return;

    while (activeFileDownloads < MAX_PARALLEL_DOWNLOADS && downloadQueue.length > 0) {
      const { fileID, hostStreamID, fromFolder } = downloadQueue.shift();
      if (downloadState.get(fileID) === "stopped") continue;      // If user explicitly stopped this one, skip it
      startFileDownload(fileID, hostStreamID, fromFolder);
    }
  }

  function startFileDownload(fileID, fileHostStreamID, fromFolder) {
    if (downloadState.get(fileID) === "stopped") return;    // If already stopped/removed by user, don't start

    activeFileDownloads++;
    downloadState.set(fileID, "active");

    const meta = files[fileID];
    if (!meta) {
      activeFileDownloads--;
      downloadState.delete(fileID);
      return processDownloadQueue();
    }

    if (fromFolder) meta.fromFolderRequest = true;

    sendToPeer(fileHostStreamID, "request-file", {
      id: fileID,
      requester: localUUID,
      isFolder: fromFolder
    });
    enableWakeLock();
    log(`Starting download: ${meta.name}`);
  }

  // RECEIVER FINALIZES FILE
    function finalizeIncomingFile(id) {
      const inf = incomingFiles[id];
      if (!inf) return;
      downloadState.set(id, "done")
      clearAckWaitersForFile(id)

      const buffers = [];
      for (let i = 0; i < inf.totalChunks; i++) {
        const b64 = inf.buffers[i];
        if (!b64) {
          const missing = [];
          for (let j = 0; j < inf.totalChunks; j++) {
            if (!inf.buffers[j]) missing.push(j);
          }

          sendToPeer(inf.sender, "request-missing", {
            id,
            missing,
            from: localUUID
          });

          return;
        }
        buffers.push(base64ToArrayBuffer(b64));
      }

      const blob = new Blob(buffers);
      const meta = files[id];
      let filename = meta?.name || `file-${id}`;

      //If part of a folder download → flatten name
      if (meta.fromFolderRequest) {
        if (meta.folderPath && meta.folderPath.trim() !== "") {
          const parts = meta.folderPath.split("/").filter(Boolean);
          filename = [...parts, meta.name].join(" - ");
        }
      }

      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.click();

      URL.revokeObjectURL(url);
      delete incomingFiles[id];
      delete meta.fromFolderRequest;

      sendToPeer(inf.sender, "file-transfer-complete", { filename: filename, from: localUUID });
      markDownloadCompleted(id);
      disableWakeLock();

      log(`Completed download: ${filename}`);
      if (activeFileDownloads > 0) {
        activeFileDownloads--;
        processDownloadQueue();
      }
    }

  //SENDER HANDLES request-missing
  async function handleRequestMissing(payload) {
    const { id, missing } = payload;
    const of = outgoingFiles[id];
    
    if (!of) return;

    const file = of.file;

    for (const idx of missing) {
      const s = idx * FILE_CHUNK_BYTES;
      const e = Math.min(file.size, s + FILE_CHUNK_BYTES);
      const buf = await file.slice(s, e).arrayBuffer();

      sendToPeer(of.to, "file-chunk", {
        id,
        index: idx,
        totalChunks: of.totalChunks,
        buffer: arrayBufferToBase64(buf),
        target: of.to,
        from: localUUID
      });
    }
  }

  // Receiver: cancel a download (user action)
  function cancelDownload(fileID) {
    downloadQueue = downloadQueue.filter(q => q.fileID !== fileID);    // Remove any queued entries for this file
    if (!downloadState) downloadState = new Map();    // Mark paused/cancelled state (use explicit Map for clearer semantics)
    downloadState.set(fileID, "stopped");

    if (incomingFiles[fileID]) delete incomingFiles[fileID];    // Remove partially received buffers & incoming file entry
    updateFileProgressUI(fileID, 0); // or show cancelled state

    // Clear any ack waiters for this file (so host doesn't hang)
    for (const key of Object.keys(ackWaiters)) {
      if (key.startsWith(`${fileID}:`)) {
        try { ackWaiters[key](false); } catch (e) { }
        delete ackWaiters[key];
      }
    }

    // If this file was active, decrement activeFileDownloads and continue the queue
    if (activeFileDownloads > 0) {
      activeFileDownloads--;
      processDownloadQueue();
    }

    // Notify host to abort sending this file (so host-side stops quickly)
    const meta = files[fileID];
    if (meta && meta.uploadedBy) {
      sendToPeer(meta.uploadedBy, "stop-download", { id: fileID, from: localUUID });
    }
    clearAckWaitersForFile(fileID)
    log(`Cancelled download: ${fileID}`);
  }

  function clearAckWaitersForFile(fileID) {
    for (const key of Object.keys(ackWaiters)) {
      if (key.startsWith(`${fileID}:`)) {
        try { ackWaiters[key](false); } catch (e) { }
        delete ackWaiters[key];
      }
    }
  }

</script>