<!doctype html>
<html lang="en">

<head>
	<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />
	<meta http-equiv="Pragma" content="no-cache" />
	<meta http-equiv="Expires" content="-1" />

	<meta name="msapplication-TileColor" content="#2e2e2e" />
	<meta name="description"
		content="Serverless web app that allows you transmit to a high quality stream to clients to view and comment on using WEBRTC and VDO.NINJA. Communication between clients is handled using low latency and very little bandwidth, dedicating as much bandwidth to the main strea, often the feed from an edit machine. Also, we think Capybara's are awesome though that might not be relevant in this case.">
	<meta name="keywords" content="Gui Felix, Advertising, Visual Effects, Motion Graphics, Remote Pixels, vdo.ninja" />
	<meta name="robots" content="index, follow" />
	<meta name="viewport"
		content="viewport-fit=cover, width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no" />
	<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
	<meta name="color-scheme" content="light dark">

	<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
	<link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
	<link rel="shortcut icon" href="/icons/favicon.ico">
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,100..900;1,100..900&display=swap"
		rel="stylesheet">
	<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght@200" rel="stylesheet">
	<link rel="stylesheet" href="style.css">

	<title>RPXL | SND</title>
</head>

<body>
	<div id="mainWindow" class="mainWindow">
		<div id="topmenu" class="toolbar top hidden">
			<div class="toolbar-section left">
				<div class="toolset" id="shareTools"><button class="tool" id="shareBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">ios_share</span></button></div>
				<div class="toolset" id="addTools"><button class="tool" id="addBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">playlist_add</span></button><input id="filePicker" type="file" multiple></div>
			</div>
			<div class="toolbar-section center">
				<div class="toolset"><span class="tool toolwider">Peers : <span id="peersList">(0)</span></span></div>
			</div>
			<div class="toolbar-section right">
				<div class="toolset"><span class="tool toolwider">XXXX-XXXX</span><button class="tool toolmoresettings" id="logBtn" aria-expanded="false" role="button"><span class="material-symbols-outlined">terminal</span></button></div>
			</div>
		</div>
		<div class="logAndFiles">
			<pre class="log hidden" id="log"></pre>

			<div id="subToolBar" class="subtoolbar hidden">
				<div class="toolbar-section left">
					<span id="transferSpeed">Download: 0 B/s| Upload: 0 B/s </span>
				</div>
				<div class="toolbar-section center">
					<span id="filterControls">Show &nbsp;&nbsp;&nbsp;</span>
					<span class="subToolSet filterSet"><button id="filterAll" class="active subTool">All</button><button
							id="filterLocal" class="subTool">Local</button><button id="filterRemote"
							class="subTool">Remote</button></span>
				</div>
				<div class="toolbar-section right">
					<span id="sortControls">Sort by &nbsp;&nbsp;&nbsp;</span>
					<span class="subToolSet sortSet"><button id="sortByTime" class="active subTool">Latest</button><button
							id="sortByName" class="subTool">Name</button></span>
				</div>
			</div>


			<!-- <div id="subToolBar" class="subtoolbar hidden">
				<span id="transferSpeed">Download: 0 B/s| Upload: 0 B/s </span>
				<span class="toolspacer"></span>
				<span id="filterControls">Show &nbsp;&nbsp;&nbsp;</span>
				<span class="subToolSet filterSet"><button id="filterAll" class="active subTool">All</button><button
						id="filterLocal" class="subTool">Local</button><button id="filterRemote"
						class="subTool">Remote</button></span>
				<span class="toolspacer"></span>
				<span id="sortControls">Sort by &nbsp;&nbsp;&nbsp;</span>
				<span class="subToolSet sortSet"><button id="sortByTime" class="active subTool">Latest</button><button
						id="sortByName" class="subTool">Name</button></span>
			</div> -->

			<div class="file-list" id="fileList">
				<div id="loadingMessage" class="hidden">Loading files...</div>
			</div>
			<div class="copyCredit">
				<a href="changelog.html" target="_new">Updated 2026-02-01 : See more</span></a>
			</div>
		</div>

		<div id="container"></div>

		<div class="drop" id="dropArea">
			<div>
				<h2>Enter share code to join</h2>
				<h2><input type="text" maxlenght="8" id="project" name="clientName" placeholder="XXXX-XXXX"
						contenteditable="true">
				</h2>

			</div>
			<div class="material-symbols-outlined largeIcon">drive_folder_upload</div>
			<div>
				<h1>Drag & drop files or folders to start share</h1>
				<h2>(click to pick)</h2>

			</div>
		</div>

		<div style="position:absolute; right:25px; top:25px;   z-index: 101;" id="helpIcon">
			<a href="help.html"><span style="position:absolute; top:10px; right:50px; font-size: 24px;">Help</span><span
					class="material-symbols-outlined" style="font-size: 48px;">help</span></a>
		</div>

		<!----- Copied links to clipboard ------>
		<div id="popupClipboard" class="toolpopup hidden">
			<div>
				Share code
			</div>
			<div>
				<h5>WWWW-WWWW</h5>
			</div>
			<!-- <div class="material-symbols-outlined">assignment_turned_in</div> -->
			<div>
				Full link copied to clipboard<br>
				<a href=help.html" target="_new">(Click here for more information)</a>
			</div>
		</div>
</body>

</html>

<script src="/scripts/vdoninja-sdk.js"></script>
<script lang="javascript">
	//globals
	//let iframe = null;
	const connectedPeers = new Set();
	//let connectedPeers = {}; // map streamID -> label
	let roomName = '';
	const files = {}; // id -> {file, name, size, chunks:[], progress}
	const folderUUIDs = {};   // path → uuid
	let folderMap = {}; // keeps track of folder DOM nodes
	let folderState = {}; // path → true/false
	let currentSort = 'latest'; // default sort method
	let currentFilter = 'all'; // values: 'all' | 'local' | 'remote'
	//let localUUID = randomID(24);
	let firstInteraction = true;
	let downloadQueue = [];        // holds pending fileIDs
	let wakeLock = null;

	const dropArea = document.getElementById('dropArea');
	const fileList = document.getElementById('fileList');
	const logEl = document.getElementById('log');
	const peersList = document.getElementById('peersList');
	const shareBtn = document.getElementById('shareBtn');
	const addBtn = document.getElementById('addBtn');
	const filePicker = document.getElementById('filePicker');
	const logBtn = document.getElementById('logBtn');
	const popupClipboard = document.getElementById('popupClipboard');
	const loadingEl = document.getElementById('loadingMessage');

	// Namespace used in messages sent through VDO.Ninja
	//const APP_NS = 'SNDRPXL';
	const devURL = window.location.origin;
	const debouncedRerender = debounce(rerenderFileTree, 100);//slow sorting index
	let ctl = null;

	//setup vdo sdk's, 
	const vdo = new VDONinjaSDK({
		salt: "rpxl.app",
		allowFallback: false,
		debug: false
	});

	//GENERATE RANDOM SID
	function randomID(len) {
		const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
		const arr = new Uint8Array(len);
		crypto.getRandomValues(arr);
		return Array.from(arr, n => chars[n % chars.length]).join('');
	}

	//LOG WINDOW
	function log(...args) {
		//console.log(...args);
		logEl.textContent += args.join(' ') + '\n';
		logEl.scrollTop = logEl.scrollHeight;
	}

	//log('Local Browser UUID : ', localUUID);
	checkSessionURL();  //autoconnect if session ID in URL

	//CHECK IF THERE IS A CORRECT SID IN THE URL AND AUTOCONNECT
	function checkSessionURL() {
		const queryURL = window.location.search.slice(1);
		const params = new URLSearchParams(queryURL);

		if (params.has('SID')) {
			const SID = params.get('SID');
			roomName = encodeURIComponent(SID);
			if (!roomName || roomName.length !== 24) {
				log('INCORRECTLY FORMATTED SESSION ID\n\nIf you are seeing this message, the session ID supplied is invalid. Please check the link and try again.\n\nOr contact the host for assistance.');
				return;
			} else {
				log('SESSION ID FOUND IN URL:', roomName);
				createIframe(roomName)
				document.getElementById('helpIcon').style.display = "none";
				document.getElementById('shareTools').style.display = "none";
				document.getElementById('dropArea').classList.add('hidden');
				document.getElementById('topmenu').classList.remove('hidden');
				document.getElementById('subToolBar').classList.remove('hidden')
				return;
			}
		} else {
			roomName = randomID(24);
			enableWakeLock(); //if first peer, enable wakelock
			createIframe(roomName);
		}
	}

	//CREATE VDONINJA IFRAME 
	async function createIframe(room) {

		try {
			ctl = await vdo.autoConnect({
				room: room,
				mode: "half",	//data only
				password: ""
			});
			//log('Announced as', ctl.streamID, 'in', room);
		} catch (err) { log('Failed:', err.message) }

		log('Joined room :', room);

		flushChunkDB("OutgoingFileCache"); //remove cache if exists
		flushChunkDB("IncomingFileCache"); //remove cache if exists
		setupVDOListeners();
	}

	//WAKE LOCK TO PREVENT SLEEPING DURING LARGE TRANSFERS
	async function enableWakeLock() {
		try {
			wakeLock = await navigator.wakeLock.request("screen");
			wakeLock.addEventListener("release", () => {
				//console.log("Wake Lock was released");
			});
			//console.log("Wake Lock active");
		} catch (err) {
			console.error(`${err.name}, ${err.message}`);
		}
	}

	async function disableWakeLock() {
		if (!wakeLock) return;
		try {
			await wakeLock.release();
			wakeLock = null;
			//console.log("Wake Lock disabled");
		} catch (err) {
			console.error(err);
		}
	}

	// If the tab regains focus, re-request wake lock
	document.addEventListener("visibilitychange", () => {
		if (!document.hidden && wakeLock) {
			enableWakeLock();
		}
	});

	function playBeep(freq = 880, duration = 0.15) {
		const ctx = new (window.AudioContext || window.webkitAudioContext)();
		const osc = ctx.createOscillator();
		const gain = ctx.createGain();

		osc.type = "sine";
		osc.frequency.value = freq;
		osc.connect(gain);
		gain.connect(ctx.destination);

		osc.start();

		gain.gain.setValueAtTime(0.2, ctx.currentTime);
		gain.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration);

		osc.stop(ctx.currentTime + duration);
	}

	function setupVDOListeners() {
		//log('Setting up VDO listeners');

		vdo.addEventListener(`connected`, (event) => {
			console.log("connected to signaling server");
		});

		vdo.addEventListener(`disconnected`, (event) => {
			//console.log("disconnected to signaling server");
		});

		vdo.addEventListener(`roomJoined`, (event) => {
			//console.log("Joined room :", event.detail.room);
		});
		vdo.addEventListener('peerConnected', (event) => {
			//used to view peers that connect later in session (ignore streamID as will often be wrong)
			playBeep(400, 1);
			const guestUUID = event.detail.uuid;
			connectedPeers[guestUUID] = guestUUID;

			if (!guestUUID) return;
			updatePeersUI();
			handleGuestJoin(guestUUID);
			log("Peer connected:", guestUUID);
			//console.warn("peer connected",event);
		});

		vdo.addEventListener('peerDisconnected', (event) => {
			playBeep(200, 2);
			const guestUUID = event.detail.uuid;
			delete connectedPeers[guestUUID];
			removePeerFiles(guestUUID);
			log("Peer dis-connected:", guestUUID);
		});

		vdo.addEventListener("peerListing", (event) => {
			//asks for all peers in room, can be run after same as listiing????
		});

		vdo.addEventListener("data", (event) => {
			//raw data reciever
			//console.warn("data:", event);
			//if (!(event.detail.data instanceof ArrayBuffer)) return;
			const rawData = event.detail.data;

			handleIncomingChunk(rawData)
			//console.log(`Chunk ${part+1}/${total} for ${fileID}`);

		});

		vdo.addEventListener('dataReceived', (event) => {
			const uuid = event.detail.uuid;
			const data = event.detail.data;
			const payload = event.detail.data.payload;

			//log('control message:', uuid);

			if (data.dataType == 'file-announce') {
				if (files[payload.id]) return;        //ignore duplicates if already have this file
				if (!uuid) return;
				payload.uploadedBy = uuid;

				files[payload.id] = {
					id: payload.id,
					name: payload.name,
					size: payload.size,
					folderPath: payload.folderPath || '',
					uploadedBy: payload.uploadedBy,
					timestamp: payload.timestamp
				};
				debouncedRerender()
				log(`Received file meta : ${payload.folderPath} / ${payload.name} - uploaded by : ${payload.uploadedBy}`);
			}

			if (data.dataType === "request-file") {
				const fileMeta = files[payload.id];
				log(`File requested: ${fileMeta?.folderPath || ''} / ${fileMeta?.name || payload.id} - by : ${uuid}`);
				enableWakeLock();
				respondToFileRequest(payload.id, uuid);
				return;
			}
			if (data.dataType === "file-removed") {
				const id = payload.id;
				const file = files[id];
				if (file) {
					delete files[id];
					const el = document.querySelector(`.file-item[data-id="${id}"]`);
					removeElementWithFade(el);
					log(`File removed: ${file.name} - on :  ${file.uploadedBy}`);
					cleanupEmptyFolders(file.folderPath);
				}
				return;
			}

			if (data.dataType === "directory-removed") {
				const path = payload.path;

				// Remove files inside folder first
				for (const id of Object.keys(files)) {
					if (files[id].folderPath.startsWith(path)) {
						delete files[id];
						const el = document.querySelector(`.file-item[data-id="${id}"]`);
						removeElementWithFade(el);
					}
				}
				// Now remove the folder itself
				const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
				removeElementWithFade(folderDiv);
				delete folderMap[path];

				cleanupEmptyFolders(path);
				log(`Directory removed remotely: ${path}`);
				return;
			}

			if (data.dataType === "source-not-found") {
				//console.warn("source file not found", payload)
				markFileDead(payload);
				const el = document.getElementById(`icon-container_${payload}`);
				el.style.opacity = "0";
				return;
			}

			if (data.dataType === "Resend-chunk") {
				onResendChunkRequest(payload, uuid)
				return;
			}

			if (data.dataType === "Download-complete") {
				onDownloadComplete(payload, uuid);
				return;
			}

		}, false);
	}


	//////shutdown actions
	window.addEventListener('beforeunload', () => {
		vdo.sendData({
			dataType: 'peer-disconnect',
			timestamp: Date.now()
		});

		if (vdo) {
			vdo.disconnect();
		}

		flushChunkDB("OutgoingFileCache"); //remove cache if exists
		flushChunkDB("IncomingFileCache"); //remove cache if exists

	});

	//SEND FILE LIST TO USER WHEN THEY CONNECT (AFTER. SHORT DELAY)
	async function handleGuestJoin(guestUUID) {
		loadingEl.classList.remove('hidden');
		await sleep(500);    // delay to ensure the peer connection is ready
		const ids = Object.keys(files);

		if (ids.length === 0) {
			log('No files to send.');
			return;
		}
		log(`Auto-sending ${ids.length} files to new guest ${guestUUID}...`);

		//only send local files
		for (const id of ids) {
			const meta = files[id];
			if (meta.uploadedBy == 'local') {
				sendToPeer(guestUUID, "file-announce", meta);
			}
		}
		// Optionally wait for all announcements to process
		await sleep(500 * ids.length); // small buffer for debounced rendering
		loadingEl.classList.add('hidden');    // Hide loading message once file list is rendered
	}

	//UPDATE THE CONNECTED PEERS COUNT IN UI
	function updatePeersUI() {
		const total = Object.keys(connectedPeers).length;

		peersList.textContent = total === 0
			? '(0)'
			: `(${total})`;
	}

	//REMOVE ANY FILES THE PEER HAS UPLOADED IF THEY DISCONNECT
	function removePeerFiles(peerUUID) {
		// Collect IDs of files uploaded by the disconnected peer
		const toRemove = Object.values(files)
			.filter(f => f.uploadedBy === peerUUID)
			.map(f => f.id);

		for (const id of toRemove) {
			const fileMeta = files[id];
			const folderPath = fileMeta.folderPath; // save for cleanup
			delete files[id];      // Remove from files object

			// Remove from DOM
			const fileDiv = document.getElementById(`data-${id}`);
			if (fileDiv) fileDiv.remove();

			cleanupEmptyFolders(folderPath);
		}
	}

	//INTERFACE
	//share
	shareBtn.addEventListener('pointerdown', () => {
		navigator.clipboard.writeText(`${devURL}/snd/?SID=${roomName}`);
		popupClipboard.classList.remove("hidden");
		setTimeout(() => {
			popupClipboard.classList.add("hidden");
		}, 10000);
	});
	//show log window
	logBtn.addEventListener('pointerdown', () => {
		document.getElementById('log').classList.toggle('hidden');
	});
	//sets active filter button
	function setActiveButton(groupSelector, activeId) {
		document.querySelectorAll(groupSelector + ' .subTool').forEach(btn => {
			btn.classList.toggle('active', btn.id === activeId);
		});
	}
	// Filter - all
	document.getElementById('filterAll').addEventListener('click', () => {
		currentFilter = 'all';
		setActiveButton('.filterSet', 'filterAll');
		debouncedRerender();
	});
	// Filter - local
	document.getElementById('filterLocal').addEventListener('click', () => {
		currentFilter = 'local';
		setActiveButton('.filterSet', 'filterLocal');
		debouncedRerender();
	});
	// Filter - remote
	document.getElementById('filterRemote').addEventListener('click', () => {
		currentFilter = 'remote';
		setActiveButton('.filterSet', 'filterRemote');
		debouncedRerender();
	});
	// Sort - latest
	document.getElementById('sortByTime').addEventListener('click', () => {
		currentSort = 'latest';
		setActiveButton('.sortSet', 'sortByTime');
		rerenderFileTree();
	});
	// Sort - name
	document.getElementById('sortByName').addEventListener('click', () => {
		currentSort = 'name';
		setActiveButton('.sortSet', 'sortByName');
		rerenderFileTree();
	});

	//DRAG AND DROP AND FILE ADDING HANDLING
	addBtn.addEventListener("click", () => {
		filePicker.click();
	});
	// Always handle picking files on both desktop + mobile
	filePicker.addEventListener("change", (event) => {
		const files = event.target.files;
		const dropId = randomID(8);

		for (let i = 0; i < files.length; i++) {
			const file = files[i];

			let relativePath;
			if (file.webkitRelativePath && file.webkitRelativePath !== "") {
				relativePath = file.webkitRelativePath;
			} else {
				relativePath = file.name;
			}

			file.relativePath = `${dropId}/${relativePath}`;
			if (!isHiddenFile(file)) addFile(file);
		}

		firstInteraction = false;

		document.getElementById('dropArea').classList.add('hidden');
		//document.getElementById('dropArea').style.pointerEvents = "none";
		document.getElementById('helpIcon').style.display = "none";
		document.getElementById('topmenu').classList.remove('hidden');
		document.getElementById('subToolBar').classList.remove('hidden');
	});

	//check if desktop, set up drag and drop UI
	const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

	if (!isMobile) {
		//set for desktop (folders and drag drop)
		filePicker.setAttribute('webkitdirectory', "");
		filePicker.setAttribute('directory', "");

		dropArea.addEventListener('click', () => {
			if (!firstInteraction) return;
			filePicker.click();
		});

		const dropOverlay = document.getElementById('dropArea');
		let dragCounter = 0; // helps handle nested dragenter/dragleave events

		window.addEventListener('dragenter', (e) => {
			e.preventDefault();
			dragCounter++;
			dropOverlay.classList.add('dragover');
		});

		window.addEventListener('dragleave', (e) => {
			e.preventDefault();
			dragCounter--;
			if (dragCounter === 0) dropOverlay.classList.remove('dragover');
		});

		window.addEventListener('dragover', (e) => {
			e.preventDefault();
		});

		window.addEventListener('drop', (e) => {
			e.preventDefault();
			dragCounter = 0;
			dropOverlay.classList.remove('dragover');
		});

		dropArea.addEventListener('drop', async (e) => {
			e.preventDefault();
			const dropId = randomID(8);

			const items = e.dataTransfer.items;
			if (!items) return handleFileList(e.dataTransfer.files);

			// Hide drop area after 1st drop
			document.getElementById('dropArea').classList.add('hidden');
			document.getElementById('helpIcon').style.display = "none";
			document.getElementById('topmenu').classList.remove('hidden');
			document.getElementById('subToolBar').classList.remove('hidden');

			const promises = [];    // Process all top-level entries concurrently

			for (let i = 0; i < items.length; i++) {
				const it = items[i];
				const entry = it.webkitGetAsEntry && it.webkitGetAsEntry();
				if (!entry) {
					if (it.getAsFile) addFile(it.getAsFile());
					continue;
				}

				if (entry.isDirectory) {
					promises.push(readDirectory(entry, '', dropId));
				} else if (entry.isFile) {
					// Wrap entry.file in a promise so we can await it
					promises.push(new Promise(resolve => entry.file(file => {
						addFile(file);
						resolve();
					})));
				}
			}

			await Promise.all(promises);  // Wait for all top-level items to finish
		});
	} else {
		//if mobile only allow multiple files and not folders (safer)
		filePicker.removeAttribute('webkitdirectory');
		filePicker.removeAttribute('directory');

		dropArea.classList.add('hidden');
		dropArea.style.display = "none";

		document.getElementById('topmenu').classList.remove('hidden');
		document.getElementById('subToolBar').classList.remove('hidden');
	}

	//PROCESS SINGLE FILE ENTRY 
	function readFileEntry(fileEntry, path = '', dropId) {
		return new Promise((resolve, reject) => {
			fileEntry.file(file => {
				if (!file) return resolve();

				file.relativePath = `${dropId}/${path}${file.name}`;

				if (!isHiddenFile(file)) addFile(file);
				resolve();
			}, reject);
		});
	}

	//READ DIRECTORY 
	async function readDirectory(dirEntry, path = '', dropId) {
		const reader = dirEntry.createReader();
		const readEntries = () => new Promise(res => reader.readEntries(res));

		let entries = await readEntries();

		while (entries.length) {
			for (const e of entries) {
				if (e.isDirectory && !e.name.startsWith('.')) {
					await readDirectory(e, path + dirEntry.name + '/', dropId);
				}
				else if (e.isFile) {
					await readFileEntry(e, path + dirEntry.name + '/', dropId);
				}
			}
			entries = await readEntries();
		}
	}

	//HANDLE FILE LIST (fallback)
	function handleFileList(list) {
		for (let i = 0; i < list.length; i++) {
			const file = list[i];
			if (!isHiddenFile(file)) addFile(file);
			else log(`Skipping hidden file: ${file.name}`);
		}
	}

	//HIDDEN FILE FILTER 
	function isHiddenFile(pathOrFile) {
		let path = "";

		if (typeof pathOrFile === "string") path = pathOrFile;
		else if (pathOrFile.webkitRelativePath) path = pathOrFile.webkitRelativePath;
		else if (pathOrFile.relativePath) path = pathOrFile.relativePath;
		else path = pathOrFile.name || "";

		if (!path) return true;

		return path.split('/').some(part => part.startsWith('.') && part.length > 1);
	}

	//ADD FILE 
	function addFile(file) {
		if (!file) return;

		const id = randomID(8)
		const relativePath = file.relativePath || file.name;    // Use relativePath if available, otherwise fallback to file name
		const pathParts = relativePath.split('/');    // Split relative path into folder path + file name
		const fileName = pathParts.pop();
		const folderPath = pathParts.join('/');

		files[id] = {
			id,
			name: fileName,
			size: file.size,
			folderPath,        // preserves folder hierarchy
			uploadedBy: 'local',
			lastModified: file.lastModified,
			timestamp: Date.now(),
			file
		};

		debouncedRerender();  // update UI
		log(`Added: ${relativePath} (${formatBytes(file.size)})`);
		announceFile(id);    // Notify peers
	}

	//SEND FILE (TO PEER OR BROADCAST)
	function announceFile(id, targetUUID = null) {
		const meta = files[id];
		if (!meta) return;

		const payload = {
			id: meta.id,
			name: meta.name,
			size: meta.size,
			folderPath: meta.folderPath,
			//uploadedBy: meta.uploadedBy, don't send will be filled in be reciever
			timestamp: meta.timestamp
		};

		if (targetUUID) {
			sendToPeer(targetUUID, "file-announce", payload);
		} else {
			sendBroadcast("file-announce", payload);
		}
	}

	//SEND TO SPECIFIC PEER (STREAMID)
	function sendToPeer(targetUUID, dataType, payload = {}) {
		const total = Object.keys(connectedPeers).length;
		if (total === 0) return; // only send if peers connected
		vdo.sendData({
			dataType,
			payload
		}, targetUUID)
		//console.warn("sendToPeer dataType", dataType, "to", targetUUID);
	}

	//send to all peers (connects, disconnects, adding or removing files)
	function sendBroadcast(dataType, payload = {}) {
		const total = Object.keys(connectedPeers).length;
		if (total === 0) return; // only send if peers connected
		vdo.sendData({
			dataType,
			payload
		});
		//console.warn("broadcast", dataType);
	}

	//SORT FILES BY LATEST (DEFAULT) OR NAME
	//stops sort operation running to often
	function debounce(fn, delay) {
		let timer = null;
		return (...args) => {
			clearTimeout(timer);
			timer = setTimeout(() => fn(...args), delay);
		};
	}

	//SORTS THE FILETREE BY DATE/NAME LOCAL/REMOTE OR ALL
	function rerenderFileTree() {
		const treeRoot = document.getElementById('fileList');

		//Save folder expand/collapse state
		folderState = {};
		for (const path in folderMap) {
			const folderDiv = folderMap[path]?.closest('.folder');
			if (!folderDiv) continue;
			const contents = folderDiv.querySelector('.folder-contents');
			//folderState[path] = contents && contents.style.display !== 'none';
			folderState[path] = contents.classList.contains('open');
		}

		//Clear tree
		treeRoot.innerHTML = '';
		folderMap = {};

		//Sort latest / name
		const fileArray = Object.values(files);
		//console.warn("filearray", fileArray);
		if (currentSort === 'name') {
			fileArray.sort((a, b) => a.name.localeCompare(b.name));
		} else {
			fileArray.sort((a, b) => b.timestamp - a.timestamp);
		}
		//Apply filter all / local / remote
		let filtered = fileArray;

		if (currentFilter === 'local') {
			filtered = filtered.filter(f => f.uploadedBy === 'local');
		}
		else if (currentFilter === 'remote') {
			filtered = filtered.filter(f => f.uploadedBy !== 'local');
		}
		//Rebuild
		for (const f of filtered) {
			renderTreeItem(f);
		}

		for (const path in folderState) {
			const contents = folderMap[path];
			if (!contents) continue;

			if (folderState[path]) {
				contents.classList.add('open');
			} else {
				contents.classList.remove('open');
			}
		}

	}

	//BUILDS THE FILE TREE
	function renderTreeItem(f) {
		const isReceiver = f.uploadedBy !== 'local'; //render in blue with download button for remote files
		///const isReceiver = files[f.id]?.file === undefined;

		const treeRoot = document.getElementById('fileList');
		const pathParts = f.folderPath ? f.folderPath.split('/') : [];
		const displayParts = [...pathParts];
		let currentContainer = treeRoot;
		let currentPath = '';
		// let logicalPath = '';
		if (/^[0-9a-f-]{36}$/.test(displayParts[0])) {
			displayParts.shift();
		}

		for (let depth = 0; depth < pathParts.length; depth++) {
			const part = pathParts[depth];
			currentPath = currentPath ? `${currentPath}/${part}` : part;

			if (!folderMap[currentPath]) {
				const folderDiv = document.createElement('div');
				folderDiv.className = 'folder ' + (isReceiver ? 'remote' : 'local');
				folderDiv.dataset.path = currentPath;

				// Apply indentation
				folderDiv.style.marginLeft = `${depth * 20}px`; // 20px per level

				const iconType = isReceiver ? 'folder-download' : 'folder-delete';
				const iconLabel = isReceiver ? 'download' : 'delete';

				folderDiv.innerHTML = `
        <div class="folder-header" data-folder="${currentPath}">
          <span class="material-symbols-outlined folder-icon">folder</span>
          <strong class="folder-text">${escapeHtml(part)}</strong>
          <span class="material-symbols-outlined ${iconType}">${iconLabel}</span>
        </div>
        <div class="folder-contents"></div>
      `;
				if (depth == 0) continue; // do not render the dropID

				currentContainer.appendChild(folderDiv);
				folderMap[currentPath] = folderDiv.querySelector('.folder-contents');

				// Expand/collapse folder
				folderDiv.querySelector('.folder-header').addEventListener('pointerdown', (e) => {
					if (e.target.classList.contains(iconType)) return;
					const contents = folderDiv.querySelector('.folder-contents');
					contents.classList.toggle('open');
					folderState[currentPath] = contents.classList.contains('open');
				});

				// Folder action
				folderDiv.querySelector(`.${iconType}`).addEventListener('pointerdown', async (e) => {
					e.stopPropagation();
					const folderPath = e.target.closest('.folder-header').dataset.folder;
					if (isReceiver) {
						requestDownload(folderPath, true);
					} else {
						if (confirm(`Remove entire directory "${folderPath}" and all its files from share?`)) {
							await deleteDirectory(folderPath);
							sendDirectoryRemoved(folderPath);
						}
					}
				});
			}
			currentContainer = folderMap[currentPath];
		}

		// Create file entry
		const fileDiv = document.createElement('div');
		fileDiv.className = 'file-item ' + (isReceiver ? 'remote' : 'local');
		fileDiv.id = `data-${f.id}`;
		fileDiv.dataset.id = f.id;
		//style object
		Object.assign(fileDiv.style, { display: 'flex', justifyContent: "space-between", alignItems: "center", padding: "2px 10px", marginLeft: `${pathParts.length}px` })

		const fileIconClass = isReceiver ? 'file-download' : 'file-delete';
		const fileIconLabel = isReceiver ? 'download' : 'delete';

		fileDiv.innerHTML = `
    <span class="file-name">${escapeHtml(f.name)}</span>
    <span class="file-size">${formatBytes(f.size)}</span>
    <span class="file-icon-container" id="icon-container_${f.id}">
      <span class="material-symbols-outlined ${fileIconClass}" id="${f.id}_icon">${fileIconLabel}</span>
    </span>
  `;

		currentContainer.appendChild(fileDiv);

		// File action
		fileDiv.querySelector(`.${fileIconClass}`).addEventListener('pointerdown', async (e) => {
			e.stopPropagation();
			if (isReceiver) {
				requestDownload(f.id, false);
			} else {
				deleteFile(f.id);
			}
		});
	}

	//FILE AND FOLDER DELETES
	// Animate when deleted and return a Promise that resolves after removal
	function removeElementWithFade(el) {
		return new Promise((resolve) => {
			if (!el) return resolve(); // nothing to remove

			el.offsetHeight;       // Trigger reflow so transition always runs
			el.classList.add('fade-slide-out');

			el.addEventListener('transitionend', () => {
				if (el.parentNode) el.parentNode.removeChild(el);
				resolve(); // resolve after removal
			}, { once: true });

			// Fallback in case transitionend doesn't fire
			setTimeout(() => {
				if (el.parentNode) el.parentNode.removeChild(el);
				resolve();
			}, 500); // CSS transition duration
		});
	}

	//REMOVE DIRECTORY(S)
	async function deleteDirectory(path) {
		if (!path) return;
		log(`Deleting directory: ${path}`);

		// Find all file IDs inside that folder (recursively)
		const toDelete = Object.keys(files).filter(id =>
			files[id].folderPath.startsWith(path)
		);

		// Delete contained files
		for (const id of toDelete) {
			const el = document.querySelector(`.file-item[data-id="${id}"]`);
			removeElementWithFade(el);
			await announceFileRemoved(id, path);
			delete files[id];
		}

		// Remove the folder DOM
		const folderDiv = document.querySelector(`.folder[data-path="${path}"]`);
		if (folderDiv) folderDiv.remove();

		delete folderMap[path];    // Remove from folderMap
		await sendDirectoryRemoved(path);    //announce directory removal to peers
		cleanupEmptyFolders(path);    //clean any now-empty parents
	}

	//ANNOUNCE DIRECTORY REMOVAL TO ALL PEERS
	async function sendDirectoryRemoved(path, targetUUID = null) {
		const peerKeys = Object.keys(connectedPeers);
		if (peerKeys.length === 0) return;      //console.log("No connected guests");

		sendBroadcast("directory-removed", { path });
		log(`Announced directory removal: ${path}`);
	}

	async function deleteFile(id) {
		const file = files[id];
		if (!file) return;

		const folderPath = file.folderPath || '';
		delete files[id];
		const el = document.querySelector(`.file-item[data-id="${id}"]`);

		if (el) await removeElementWithFade(el);

		log(`Deleted file : / ${folderPath} / ${file.name}`);
		cleanupEmptyFolders(folderPath);
		await announceFileRemoved(id, folderPath);
	}

	//ANNOUNCE FILE REMOVAL TO ALL PEERS
	async function announceFileRemoved(id, path) {
		const total = Object.keys(connectedPeers).length;
		if (total == 0) return;

		sendBroadcast("file-removed", { id });
		log(`Announced file removal : `, id);
	}

	//CLEANUP AND REMOVE ANY EMPTY FOLDERS
	function cleanupEmptyFolders(startPath = null) {
		function isEmptyFolder(folderDiv) {
			const contents = folderDiv.querySelector('.folder-contents');
			if (!contents) return true;

			// Check if contents has any visible file-items or folder divs
			const children = Array.from(contents.children).filter(
				el => el.classList.contains('file-item') || el.classList.contains('folder')
			);

			return children.length === 0;
		}

		if (startPath) {
			let parts = startPath.split('/');
			while (parts.length > 0) {
				const path = parts.join('/');
				const folder = document.querySelector(`.folder[data-path="${path}"]`);
				if (folder && isEmptyFolder(folder)) {
					log(`Removing empty folder: ${path}`);
					folder.remove();
					delete folderMap[path];
					sendBroadcast("directory-removed", { path });
				}
				parts.pop(); // move up
			}
		} else {
			const folders = document.querySelectorAll('.folder');
			for (const folder of folders) {
				if (isEmptyFolder(folder)) {
					const path = folder.dataset.path;
					log(`Removing empty folder: ${path}`);
					folder.remove();
					delete folderMap[path];
					// sendBroadcast("directory-removed2", { path });
				}
			}
		}
	}

	function markFileDead(fileID) {
		//console.warn("marking file dead");
		const el = document.getElementById(`data-${fileID}`);
		if (!el) return;
		el.classList.add("file-dead");
	}

	//FILE DOWNLOAD UI, CIRCLE, RESTORE BACK AND CALC DL SPEED PROGRESS BARS
	const pausedDownloads = new Set(); // holds fileIDs of paused downloads
	const incomingFiles = new Map();

	function createFileProgressUI(id) {
		const container = document.getElementById(`icon-container_${id}`);
		if (!container) return;

		// Clear previous content and insert progress UI
		container.innerHTML = `
    <div class="roundProgressBarBG">
      <div class="roundProgressBarFill" id="progress-bar-${id}"></div>
      <div class="roundProgressBarCenter">
        <div class="stop-btn" id="stop-btn-${id}">✕</div>
      </div>
    </div>
  `;

		const stopBtn = document.getElementById(`stop-btn-${id}`);
		if (!stopBtn) return;
		// Style stop button
		Object.assign(stopBtn.style, { position: "absolute", top: "50%", left: "50%", transform: "translate(-50%, -50%)", cursor: "pointer", fontSize: "0.8em", userSelect: "none", opacity: "0.5" });

		// Stop button handler
		stopBtn.addEventListener("pointerdown", () => {
			log(`Stopping download: ${id}`);

			// stop local
			pausedDownloads.delete(id);
			delete incomingFiles[id];
			downloadQueue = downloadQueue.filter(job => job.fileID !== id);      // remove from queue

			// restore icon cleanly
			restoreDownloadIcon(id);
			cancelDownload(id)
		});
	}
	//if transfer is cancelled 
	function restoreDownloadIcon(id) {
		const container = document.getElementById(`icon-container_${id}`);
		if (!container) return;

		// Restore original icon
		container.innerHTML = `
    <span class="material-symbols-outlined file-download" id="${id}_icon">download</span>
  `;

		const icon = document.getElementById(`${id}_icon`);
		if (!icon) return;

		// Reattach the normal download behavior
		icon.addEventListener("pointerdown", (e) => {
			e.stopPropagation();
			requestDownload(id, false);
			createFileProgressUI(id);
		});
	}

	function markDownloadCompleted(id) {
		const fileEl = document.getElementById(`icon-container_${id}`);
		if (!fileEl) return;

		fileEl.classList.add("download-complete");

		// Set progress visually to 100%
		const bar = fileEl.querySelector(".progress-bar");
		if (bar) bar.style.backgroundImage = `conic-gradient(dodgerblue 359deg, light-dark(var(--color-light-white), var(--color-dark-grey)) 359deg)`;

		// Replace stop button with ✓ icon (but keep clickable)
		const btn = document.getElementById(`stop-btn-${id}`);
		if (btn) {
			btn.dataset.originalIcon = btn.innerHTML;   // store original
			btn.innerHTML = "✓";                         // completed icon
			btn.classList.add("completed");

			// Clicking ✓ restores original download button
			btn.onclick = () => {
				btn.innerHTML = btn.dataset.originalIcon;
				btn.classList.remove("completed");
				fileEl.classList.remove("download-complete");
				btn.onclick = () => handleFileDownload(id);         // restore original handler
			};
		}
	}

	function updateFileProgressUI(id, percent) {
		const bar = document.getElementById(`progress-bar-${id}`);
		if (!bar) return; // safely ignore if element removed
		if (pausedDownloads.has(id)) return;

		const pct = Math.max(0, Math.min(100, Number(percent) || 0));
		const deg = pct * 3.6; // 100% -> 360°
		bar.style.backgroundImage = `conic-gradient(dodgerblue ${deg}deg, light-dark(var(--color-light-white), var(--color-dark-grey)) ${deg}deg)`;
	}

	//CALCULATE AND SHOW SPEED OF DOWNLOAD / UPLOAD
	let bytesReceivedInInterval = 0;
	let bytesSentInInterval = 0;
	// Called whenever a chunk is received
	function onChunkReceived(chunkSize) {
		bytesReceivedInInterval += chunkSize;
	}
	// Called whenever a chunk is sent
	function onChunkSent(chunkSize) {
		bytesSentInInterval += chunkSize;
	}
	function formatSpeed(bytes) {
		if (bytes > 1e6) return (bytes / 1e6).toFixed(2) + " MB/s";
		if (bytes > 1e3) return (bytes / 1e3).toFixed(2) + " KB/s";
		return bytes + " B/s";
	}
	//update every 500ms
	setInterval(() => {
		const downloadSpeed = formatSpeed(bytesReceivedInInterval * 2); // interval 500ms → scale to 1s
		const uploadSpeed = formatSpeed(bytesSentInInterval * 2);
		document.getElementById("transferSpeed").textContent = `Download: ${downloadSpeed} | Upload: ${uploadSpeed}`;
		// Reset counters
		bytesReceivedInInterval = 0;
		bytesSentInInterval = 0;
	}, 500);

	// UTILITY, CREATE FILE ID'S, NICE FORMAT SIZE AND REMOVE ANY FUNNY CHARACTERS
	function formatBytes(a) { if (a === 0) return '0 B'; const units = ['B', 'KB', 'MB', 'GB', 'TB']; const e = Math.floor(Math.log(a) / Math.log(1024)); return (a / Math.pow(1024, e)).toFixed(2) + ' ' + units[e]; }
	function escapeHtml(s) { return String(s).replace(/[&<>\"']/g, c => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" })[c]); }

	//pause when sending or retrying
	function sleep(ms) {
		return new Promise(r => setTimeout(r, ms));
	}


	//TX AND RX FILe REQUESTS
	// PEER REQUESTS FILE
	function requestDownload(fileID, isFolder = false) {
		//FOLDER DOWNLOAD HANDLED FIRST
		if (isFolder) {
			const folderPath = fileID;  // fileID *is* a folder path here
			log(`Requesting folder : ${folderPath}`);

			// Find all files whose folderPath starts with this folder
			const fileIDs = Object.keys(files).filter(id =>
				files[id].folderPath.startsWith(folderPath)
			);

			for (const id of fileIDs) {
				const meta = files[id];
				const host = meta.uploadedBy;

				queueDownload(id, host, true);
				createFileProgressUI(id);
			}
			return;
		}
		//SINGLE FILE DOWNLOAD
		const meta = files[fileID];
		if (!meta) return log("Requested file failed : no such file");

		log(`Requesting file : ${meta.name} - uploaded by : ${meta.uploadedBy}`);
		const host = meta.uploadedBy;
		queueDownload(fileID, host, false);
		createFileProgressUI(fileID);
	}

	///HOST SENDS FILES
	//RESPOND TO FILE REQUEST
	async function respondToFileRequest(fileID, targetUUID) {
		sending = false;
		const conns = vdo.connections.get(targetUUID);
		const dc = conns?.publisher?.dataChannel || conns?.viewer?.dataChannel;
		if (!dc) return;

		const meta = files[fileID];
		if (!meta) return;

		const file = meta.file;
		const chunkSize = 256 * 1024 - 128;

		produceChunks(fileID, targetUUID, file, chunkSize)
		await refillSendCache(fileID);
		sendRAWData(dc);
	}

	//RECIEVED FILE DOWNLOAD COMPLETE MESSAGE FROM GUEST, SCHEDULE CLEAR FILE FROM CACHE DB
	function onDownloadComplete(fileID, peerUUID) {
		const f = files[fileID];
		if (!f) return;

		f.activeDownloads?.delete(peerUUID);
		log("Download complete : ", f.name, " - by peer : ", peerUUID, "remaining:", f.activeDownloads.size);

		// If all peers done → schedule purge
		if (!f.activeDownloads || f.activeDownloads.size === 0) {
			scheduleChunkPurge(fileID);
		}
	}






































	// FILE TRANSFER ENGINE

	// Simple CRC32
	function crc32(buf) {
		let crc = -1;
		for (let b of buf) crc = (crc >>> 8) ^ table[(crc ^ b) & 0xFF];
		return (crc ^ -1) >>> 0;
	}

	const table = (() => {
		let t = new Uint32Array(256);
		for (let i = 0; i < 256; i++) {
			let c = i;
			for (let j = 0; j < 8; j++) c = ((c & 1) ? 0xEDB88320 ^ (c >>> 1) : c >>> 1);
			t[i] = c >>> 0;
		}
		return t;
	})();

	//SENDER CHUNK CACHING DB creation parameters
	//const CACHE_TTL = 5 * 60 * 1000; // 5 minutes
	const POST_DOWNLOAD_GRACE = 2 * 60 * 1000; // keep file cached for 2 minutes after file complete recieved
	const TX_DB = "OutgoingFileCache";
	const TX_STORE = "chunks";
	let txDB;

	const sendCache = new Map();
	const cacheQueue = new Map();
	const transfers = new Map(); // fileID -> TransferState
	const MAX_CACHE_QUEUE = 8;
	//let cacheWorkerRunning = false;

	async function produceChunks(fileID, targetUUID, file, chunkSize) {
		let logCache = false;
		//if (!cacheWorkerRunning) startCacheWorker();
		files[fileID].chunkSize = chunkSize;
		files[fileID].activeDownloads ??= new Set();
		files[fileID].activeDownloads.add(targetUUID);

		const totalChunks = Math.ceil(file.size / chunkSize);

		transfers.set(fileID, {
			fileID,
			totalChunks,
			nextToRead: 0,
			nextToSend: 0,
			maxWritten: -1,
			inflight: new Set()
		});

		for (let i = 0; i < totalChunks; i++) {
			const chunkIndex = i;

			const cached = await idbGetChunk(fileID, chunkIndex); 			//check cache if chunk exists first

			if (cached) {
				// chunk already exists in IndexedDB
				const t = transfers.get(fileID);
				if (t) {
					t.maxWritten = Math.max(t.maxWritten, chunkIndex);
					refillSendCache(fileID);   //wake sender
				}
				if (!logCache) {
					log("File : ", file.name, "is already in cache");
					logCache = true;
				}
				continue;
			}

			if (!logCache) {
				log(`Splitting ${file.name} into ${totalChunks} parts`); //just once per ask
				logCache = true;
			}

			const start = i * chunkSize;
			const end = Math.min(file.size, start + chunkSize);

			if (i % 8 === 0) await Promise.resolve();

			let buffer;
			try {
					buffer = await file.slice(start, end).arrayBuffer();
				} catch (err) {
					//console.warn("Source file not found:", fileID, file.name, err);
					markFileDead(fileID);
					sendBroadcast("source-not-found", fileID);
					return;
				}
				
			const crc = crc32(new Uint8Array(buffer));
			const idBytes = new TextEncoder().encode(fileID);

			const headerLen = 4 + 4 + 4 + idBytes.length + 4;
			const out = new Uint8Array(headerLen + buffer.byteLength);
			const view = new DataView(out.buffer);
			let o = 0;

			view.setUint32(o, chunkIndex, true); o += 4;
			view.setUint32(o, totalChunks, true); o += 4;
			view.setUint32(o, idBytes.length, true); o += 4;
			out.set(idBytes, o); o += idBytes.length;
			view.setUint32(o, crc, true); o += 4;
			out.set(new Uint8Array(buffer), o);

			await writeChunkToIDB(fileID, chunkIndex, out.buffer);

			const t = transfers.get(fileID);
			t.maxWritten = Math.max(t.maxWritten, chunkIndex);
			refillSendCache(fileID);
		}
	}

	//CREATE, WRITE AND GET CHUNKS FROM TX_DB
	function openTxDB() {
		if (txDB) return txDB;
		txDB = new Promise((resolve, reject) => {
			const req = indexedDB.open(TX_DB, 1);
			req.onupgradeneeded = e => {
				e.target.result.createObjectStore(TX_STORE, { keyPath: "key" });
			};
			req.onsuccess = () => resolve(req.result);
			req.onerror = () => reject(req.error);
		});
		return txDB;
	}

	async function writeChunkToIDB(fileID, chunkIndex, buffer) {
		const db = await openTxDB();

		return new Promise((resolve, reject) => {
			const tx = db.transaction(TX_STORE, "readwrite");
			const store = tx.objectStore(TX_STORE);

			const req = store.put({
				key: `${fileID}:${chunkIndex}`,
				fileID,
				chunkIndex,
				data: buffer,
				ts: Date.now()
			});

			req.onerror = () => reject(req.error);
			tx.oncomplete = resolve;
			tx.onerror = () => reject(tx.error);
		});
	}

	async function idbGetChunk(fileID, chunkIndex) {
		const db = await openTxDB();

		return new Promise((resolve, reject) => {
			const tx = db.transaction(TX_STORE, "readonly");
			const req = tx.objectStore(TX_STORE).get(`${fileID}:${chunkIndex}`);

			req.onsuccess = () => resolve(req.result?.data || null);
			req.onerror = () => reject(req.error);
		});
	}


	//SENDBUFFER - MEMORY, FILLED FROM DISK CACHE
	let sending = false;

	function sendRAWData(dc) {
		if (sending) return;
		sending = true;

		const pump = () => {
			if (!sending) return;

			const MAX_SEND_BUFFER = 1_000_000;

			for (const [key, chunk] of sendCache) {
				if (dc.bufferedAmount > MAX_SEND_BUFFER) break;

				dc.send(chunk);

				const [fileID, index] = key.split(":");
				const t = transfers.get(fileID);

				sendCache.delete(key);
				t.inflight.delete(Number(index));
				t.nextToSend++;

				refillSendCache(fileID);
			}

			requestAnimationFrame(pump);
		};

		pump();
	}

	const WINDOW = 8;	//amount of chunks to cache in memory

	async function refillSendCache(fileID) {
		const t = transfers.get(fileID);
		if (!t) return;

		while (
			t.inflight.size < WINDOW &&
			t.nextToRead <= t.maxWritten &&   //critical
			t.nextToRead < t.totalChunks
		) {
			const chunk = await idbGetChunk(fileID, t.nextToRead);

			sendCache.set(`${fileID}:${t.nextToRead}`, chunk);
			t.inflight.add(t.nextToRead);
			t.nextToRead++;
		}
	}

	//scheduler to remove chunks when we recieve file download complete
	function scheduleChunkPurge(fileID) {
		const f = files[fileID];
		if (!f) return;

		log("Scheduling chunk purge for", fileID);

		f.purgeTimer = setTimeout(() => {
			purgeFileChunks(fileID);
			f.purgeTimer = null;
		}, POST_DOWNLOAD_GRACE);
	}

	async function purgeFileChunks(fileID) {
		const db = await openTxDB();
		const tx = db.transaction(TX_STORE, "readwrite");
		const store = tx.objectStore(TX_STORE);
		const req = store.getAllKeys();

		req.onsuccess = () => {
			for (const key of req.result) {
				if (key.startsWith(fileID + ":")) {
					store.delete(key);
				}
			}
		};
		log("Purging chunks for", fileID);
	}

	//global used to empty TX and RX db's on shutdown and startup
	function flushChunkDB(db) {
		return new Promise((resolve, reject) => {
			const req = indexedDB.deleteDatabase(db);
			req.onsuccess = resolve;
			req.onerror = () => reject(req.error);
			req.onblocked = () => console.warn("DB delete blocked by open tabs");
		});
	}

















	//FILE RECIEVING HANDLING
	//recieving file chunks
	async function handleIncomingChunk(buffer) {
		onChunkReceived(buffer.byteLength);

		const view = new DataView(buffer);
		let offset = 0;

		const part = view.getUint32(offset, true); offset += 4;
		const total = view.getUint32(offset, true); offset += 4;
		const idLen = view.getUint32(offset, true); offset += 4;

		const idBytes = new Uint8Array(buffer, offset, idLen);
		const fileID = new TextDecoder().decode(idBytes);
		offset += idLen;

		const crcExpected = view.getUint32(offset, true); offset += 4;
		const chunk = buffer.slice(offset);

		// CRC check
		const crcActual = crc32(new Uint8Array(chunk));
		if (crcActual !== crcExpected) {
			const host = files[fileID]?.uploadedBy;
			const payload = { fileID, part };

			console.warn("CRC error for :", fileID, " chunk : ", part, "asking for resend from :", host);
			sendToPeer(host, "Resend-chunk", payload)
			return;
		}

		if (!incomingFiles.has(fileID)) {
			incomingFiles.set(fileID, { total, receivedCount: 0 });
		}

		const file = incomingFiles.get(fileID);

		// Write to IndexedDB, NOT RAM
		await storeRxChunk(fileID, part, total, chunk);
		file.receivedCount++;
		console.log(`${fileID}: chunk ${part}/${total - 1}`);

		const percent = (file.receivedCount / total) * 100;
		updateFileProgressUI(fileID, percent)
		// Completion
		// if (file.receivedCount === total) {
		// 	//console.log(`File ${fileID} complete (assembling)`);

		// 	const buffers = [];
		// 	for (let i = 1; i <= total; i++) {
		// 		buffers.push(await getRxChunk(fileID, i));
		// 	}

		// 	const blob = new Blob(buffers);
		// 	incomingFiles.delete(fileID);

		// 	onFileComplete(fileID, blob);
		// }
		
	}

	async function assembleFileStream(fileID, total) {
			const stream = new ReadableStream({
				async start(controller) {
					for (let i = 1; i <= total; i++) {
						const chunk = await getRxChunk(fileID, i);
						controller.enqueue(chunk);
					}
					controller.close();
				}
			});

			return new Response(stream).blob();
		}

	//RECIEVER CACHE DB
	//store chunks in indexDB to free up memory
	const RX_DB = "IncomingFileCache";
	const RX_STORE = "chunks";
	let rxDB;

	function openRxDB() {
		if (rxDB) return rxDB;
		rxDB = new Promise((resolve, reject) => {
			const req = indexedDB.open(RX_DB, 1);
			req.onupgradeneeded = e => {
				e.target.result.createObjectStore(RX_STORE, { keyPath: "key" });
			};
			req.onsuccess = () => resolve(req.result);
			req.onerror = () => reject(req.error);
		});
		return rxDB;
	}

	async function storeRxChunk(fileID, part, total, data) {
		const db = await openRxDB();
		const tx = db.transaction(RX_STORE, "readwrite");
		tx.objectStore(RX_STORE).put({
			key: `${fileID}:${part}`,
			fileID,
			part,
			total,
			data
		});
	}

	async function getRxChunk(fileID, part) {
		const db = await openRxDB();
		return new Promise(res => {
			const tx = db.transaction(RX_STORE);
			const req = tx.objectStore(RX_STORE).get(`${fileID}:${part}`);
			req.onsuccess = () => res(req.result?.data);
		});
	}

	async function purgeRXChunks(fileID) {
		log("Purging chunks for", fileID);

		const db = await openRxDB();
		const tx = db.transaction(RX_STORE, "readwrite");
		const store = tx.objectStore(RX_STORE);
		const req = store.getAllKeys();

		req.onsuccess = () => {
			for (const key of req.result) {
				if (key.startsWith(fileID + ":")) {
					store.delete(key);
				}
			}
		};
	}

	//cleanup after file complete, send OK to host
	function onFileComplete(fileID, blob) {
		// Try to resolve original filename
		let filename = fileID; // fallback

		if (files[fileID]?.name) {
			filename = files[fileID].name;
		}

		// Download
		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = filename;
		a.click();

		URL.revokeObjectURL(url);

		const host = files[fileID]?.uploadedBy;
		sendToPeer(host, "Download-complete", fileID)
		markDownloadCompleted(fileID);
		log("Download complete:", filename);
		purgeRXChunks(fileID); //delete cached file data
	}

























	//DOWNLOAD QUEUE
	const ackWaiters = {}; // key = `${id}:${group}` -> resolve()
	let downloadState = new Map();	//tracks state of each file in queue (queued, active, stopped, done)
	let activeFileDownloads = 0;     //download queue files currently running
	const MAX_PARALLEL_DOWNLOADS = 6; // download queue max concurrent files

	//create and populate
	function queueDownload(fileID, host, fromFolder = false) {
		downloadQueue.push({ fileID, host, fromFolder });
		downloadState.set(fileID, "queued");
		processDownloadQueue();
	}
	//process files till queue full, then pause
	function processDownloadQueue() {
		if (activeFileDownloads >= MAX_PARALLEL_DOWNLOADS) return;

		while (activeFileDownloads < MAX_PARALLEL_DOWNLOADS && downloadQueue.length > 0) {
			const { fileID, host, fromFolder } = downloadQueue.shift();
			if (downloadState.get(fileID) === "stopped") continue;      // If user explicitly stopped this one, skip it
			startFileDownload(fileID, host, fromFolder);
		}
	}

	function startFileDownload(fileID, host, fromFolder) {
		if (downloadState.get(fileID) === "stopped") return;    // If already stopped/removed by user, don't start

		activeFileDownloads++;
		downloadState.set(fileID, "active");

		const meta = files[fileID];
		if (!meta) {
			activeFileDownloads--;
			downloadState.delete(fileID);
			return processDownloadQueue();
		}

		if (fromFolder) meta.fromFolderRequest = true;

		sendToPeer(host, "request-file", {
			id: fileID,
			isFolder: fromFolder
		});

		enableWakeLock();
		//(`Starting download: ${meta.name} - uploaded by : ${meta.uploadedBy}`);
	}

	// // Receiver: cancel a download (user action)
	function cancelDownload(fileID) {
		downloadQueue = downloadQueue.filter(q => q.fileID !== fileID);    // Remove any queued entries for this file
		if (!downloadState) downloadState = new Map();    // Mark paused/cancelled state (use explicit Map for clearer semantics)
		downloadState.set(fileID, "stopped");

		if (incomingFiles[fileID]) delete incomingFiles[fileID];    // Remove partially received buffers & incoming file entry
		updateFileProgressUI(fileID, 0); // or show cancelled state

		// Clear any ack waiters for this file (so host doesn't hang)
		for (const key of Object.keys(ackWaiters)) {
			if (key.startsWith(`${fileID}:`)) {
				try { ackWaiters[key](false); } catch (e) { }
				delete ackWaiters[key];
			}
		}

		// If this file was active, decrement activeFileDownloads and continue the queue
		if (activeFileDownloads > 0) {
			activeFileDownloads--;
			processDownloadQueue();
		}

		// Notify host to abort sending this file (so host-side stops quickly)
		const meta = files[fileID];
		if (meta && meta.uploadedBy) {
			//sendToPeer(meta.uploadedBy, "stop-download", { id: fileID, from: localUUID });
		}
		clearAckWaitersForFile(fileID)
		log(`Cancelled download: ${fileID}`);
	}

	function clearAckWaitersForFile(fileID) {
		for (const key of Object.keys(ackWaiters)) {
			if (key.startsWith(`${fileID}:`)) {
				try { ackWaiters[key](false); } catch (e) { }
				delete ackWaiters[key];
			}
		}
	}
























	// class FileChunkStreamer {
	// 	constructor(fileID, meta, onComplete, onProgress) {
	// 		this.fileID = fileID;
	// 		this.meta = meta;
	// 		this.total = 0;
	// 		this.received = new Map();
	// 		this.receivedCount = 0;
	// 		this.onComplete = onComplete;
	// 		this.onProgress = onProgress;
	// 		this.cancelled = false;
	// 	}

	// 	async handleChunk(buffer) {
	// 		if (this.cancelled) return;

	// 		const view = new DataView(buffer);
	// 		let o = 0;

	// 		const part = view.getUint32(o, true); o += 4;
	// 		this.total = view.getUint32(o, true); o += 4;
	// 		const idLen = view.getUint32(o, true); o += 4;

	// 		const idBytes = new Uint8Array(buffer, o, idLen);
	// 		const fileID = new TextDecoder().decode(idBytes);
	// 		o += idLen;

	// 		const crcExpected = view.getUint32(o, true); o += 4;
	// 		const chunk = buffer.slice(o);

	// 		// CRC check
	// 		const crcActual = crc32(new Uint8Array(chunk));
	// 		if (crcActual !== crcExpected) {
	// 			console.warn("CRC mismatch", fileID, part);
	// 			requestResend(fileID, part);
	// 			return;
	// 		}

	// 		if (!this.received.has(part)) {
	// 			this.received.set(part, chunk);
	// 			this.receivedCount++;
	// 			onChunkReceived(chunk.byteLength);
	// 		}

	// 		this.onProgress?.(this.receivedCount, this.total);

	// 		if (this.receivedCount === this.total) {
	// 			await this.finish();
	// 		}
	// 	}

	// 	async finish() {
	// 		if (this.cancelled) return;

	// 		const buffers = [];
	// 		for (let i = 1; i <= this.total; i++) {
	// 			buffers.push(this.received.get(i));
	// 		}

	// 		const blob = new Blob(buffers);
	// 		this.received.clear();

	// 		this.onComplete(this.fileID, blob);
	// 	}

	// 	cancel() {
	// 		this.cancelled = true;
	// 		this.received.clear();
	// 	}
	// }

	// const activeStreamers = new Map();

	// function getStreamer(fileID) {
	// 	if (!activeStreamers.has(fileID)) {
	// 		const meta = files[fileID];
	// 		const streamer = new FileChunkStreamer(
	// 			fileID,
	// 			meta,
	// 			onFileComplete,
	// 			(received, total) => updateFileProgressUI(fileID, received / total)
	// 		);
	// 		activeStreamers.set(fileID, streamer);
	// 	}
	// 	return activeStreamers.get(fileID);
	// }

	// function handleIncomingChunk(buffer) {
	// 	const view = new DataView(buffer);
	// 	let idLen = view.getUint32(8, true);
	// 	const idBytes = new Uint8Array(buffer, 12, idLen);
	// 	const fileID = new TextDecoder().decode(idBytes);

	// 	const streamer = getStreamer(fileID);
	// 	streamer.handleChunk(buffer);
	// }


	function onFileComplete(fileID, blob) {
		let filename = files[fileID]?.name || fileID;

		const url = URL.createObjectURL(blob);
		const a = document.createElement("a");
		a.href = url;
		a.download = filename;
		a.click();
		URL.revokeObjectURL(url);

		const host = files[fileID]?.uploadedBy;
		sendToPeer(host, "Download-complete", fileID);

		activeStreamers.delete(fileID);
		log("Download complete:", filename);
	}

	function cancelDownload(fileID) {
		downloadQueue = downloadQueue.filter(q => q.fileID !== fileID);
		downloadState.set(fileID, "stopped");

		const streamer = activeStreamers.get(fileID);
		if (streamer) streamer.cancel();
		activeStreamers.delete(fileID);

		delete incomingFiles[fileID];
		clearAckWaitersForFile(fileID);

		if (activeFileDownloads > 0) activeFileDownloads--;
		processDownloadQueue();

		log("Cancelled download:", fileID);
	}

	async function assembleFileStream(fileID, total) {
		const stream = new ReadableStream({
			async start(controller) {
				for (let i = 1; i <= total; i++) {
					const chunk = await getRxChunk(fileID, i);
					controller.enqueue(chunk);
				}
				controller.close();
			}
		});

		return new Response(stream).blob();
	}

</script>